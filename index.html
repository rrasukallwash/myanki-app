<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyAnkiApp v16.03.05</title>
    <style>
        /* v12.03.2: CSSå¤‰æ•°å®šç¾©ï¼ˆã‚«ãƒ©ãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºï¼‰ */
        :root {
            /* 1. èƒŒæ™¯è‰² */
            --bg-main: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-section: #ffffff;
            --bg-item: #ffffff;
            --bg-modal: #ffffff;
            --bg-header-start: #667eea;
            --bg-header-end: #764ba2;
            --bg-input: #ffffff;
            
            /* 2. æ–‡å­—è‰² */
            --text-main: #333333;
            --text-sub: #666666;
            --text-link: #667eea;
            --text-placeholder: #999999;
            
            /* 3. ãƒœãƒ¼ãƒ€ãƒ¼ãƒ»åŒºåˆ‡ã‚Šç·š */
            --border-color: #dddddd;
            --divider-color: #e0e0e0;
            
            /* 4. ãƒœã‚¿ãƒ³ */
            --btn-primary-bg: #667eea;
            --btn-primary-text: #ffffff;
            --btn-secondary-bg: #95a5a6;
            --btn-secondary-text: #ffffff;
            --btn-danger-bg: #e74c3c;
            --btn-danger-text: #ffffff;
            --btn-hover-bg: #5568d3;
            --btn-disabled-bg: #cccccc;
            --btn-disabled-text: #999999;
            
            /* 5. ã‚¿ãƒ– */
            --tab-bg-inactive: transparent;
            --tab-bg-active: rgba(255, 255, 255, 0.2);
            --tab-text: rgba(255, 255, 255, 0.8);
            
            /* 6. ã‚«ãƒ¼ãƒ‰å­¦ç¿’ç”»é¢ */
            --card-study-bg-start: #f093fb;
            --card-study-bg-end: #f5576c;
            --card-study-stat-bg: #f8f9fa;
            
            /* 7. çŠ¶æ…‹è¡¨ç¤º */
            --color-success: #27ae60;
            --color-error: #e74c3c;
            --color-warning: #f39c12;
            --color-info: #3498db;
            
            /* 8. PDFãƒãƒ¼ã‚«ãƒ¼ */
            --marker-yellow: rgba(255, 255, 0, 0.4);
            --marker-red: rgba(255, 0, 0, 0.3);
            --marker-green: rgba(0, 255, 0, 0.3);
            --marker-blue: rgba(0, 150, 255, 0.3);
            
            /* 9. ãã®ä»–UIè¦ç´  */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --hover-bg: #f8f9fa;
            --selected-bg: #e3f2fd;
            --scrollbar-color: #cccccc;
            --icon-color: #666666;
        }
        body.theme-dark {
            --bg-main: #1a1a1a;
            --bg-section: #2a2a2a;
            --bg-item: #2a2a2a;
            --bg-modal: #2a2a2a;
            --bg-header-start: #2c3e50;
            --bg-header-end: #34495e;
            --bg-input: #333333;
            
            --text-main: #f0f0f0;
            --text-sub: #bbbbbb;
            --text-link: #8b9cff;
            --text-placeholder: #777777;
            
            --border-color: #444444;
            --divider-color: #444444;
            
            --btn-primary-bg: #667eea;
            --btn-primary-text: #ffffff;
            --btn-secondary-bg: #555555;
            --btn-secondary-text: #ffffff;
            --btn-danger-bg: #e74c3c;
            --btn-danger-text: #ffffff;
            --btn-hover-bg: #5568d3;
            --btn-disabled-bg: #444444;
            --btn-disabled-text: #777777;
            
            --tab-bg-inactive: transparent;
            --tab-bg-active: rgba(255, 255, 255, 0.2);
            --tab-text: rgba(255, 255, 255, 0.9);
            
            --card-study-bg-start: #3a3a3a;
            --card-study-bg-end: #4a4a4a;
            --card-study-stat-bg: #333333;
            
            --shadow-color: rgba(0, 0, 0, 0.5);
            --hover-bg: #333333;
            --selected-bg: #3a4a5a;
            --scrollbar-color: #555555;
            --icon-color: #aaaaaa;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: var(--bg-main);
            color: var(--text-main);
            font-family: 'Segoe UI', Meirio, sans-serif;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        .tab.active {
            background: white;
            color: #667eea;
        }
        
        .tab:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .tab.active:hover {
            background: white;
        }
        
        .section {
            display: none;
        }
        
        .section.active {
            display: block;
        }
        
        .card-creator, .card-viewer, .card-list, .pdf-viewer {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            height: 20px;
            cursor: pointer;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }
        
        /* v5.01: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—é¸æŠã‚¿ãƒ– */
        .card-type-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .card-type-tab {
            background: transparent;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .card-type-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .card-type-tab:hover {
            color: #667eea;
        }
        
        /* v5.01: ç©´åŸ‹ã‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .cloze-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .cloze-preview {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #667eea;
        }
        
        .cloze-preview-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .cloze-text {
            color: #333;
            line-height: 1.6;
        }
        
        .cloze-blank {
            background: #fff3cd;
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
            color: #856404;
        }
        
        /* v10.03: ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ãªç©´åŸ‹ã‚ */
        .cloze-clickable {
            background: #fff3cd;
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
            color: #856404;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cloze-clickable:hover {
            background: #ffc107;
            transform: scale(1.05);
        }
        
        .cloze-revealed {
            background: rgba(102, 126, 234, 0.3);
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
            color: white;
        }
        
        .cloze-answer-hidden {
            background: #667eea;
            color: #667eea;
            padding: 2px 10px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }
        
        .cloze-answer-shown {
            background: #27ae60;
            color: white;
            padding: 2px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;  /* v15.01.10: ãƒãƒ¼ã‚«ãƒ¼ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚ºã«çµ±ä¸€ */
            border-radius: 6px;  /* v15.01.10: ãƒãƒ¼ã‚«ãƒ¼ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚ºã«çµ±ä¸€ */
            font-size: 14px;  /* v15.01.10: ãƒãƒ¼ã‚«ãƒ¼ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚ºã«çµ±ä¸€ */
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            background: var(--btn-hover-bg);
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-danger {
            background: var(--btn-danger-bg);
            color: var(--btn-danger-text);
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-danger:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-success {
            background: #27ae60;
        }
        
        .btn-success:hover {
            background: #229954;
        }
        
        .btn-success:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-secondary {
            background: var(--btn-secondary-bg);
            color: var(--btn-secondary-text);
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .btn-secondary:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-warning {
            background: #f39c12;
        }
        
        .btn-warning:hover {
            background: #e67e22;
        }
        
        .card {
            background: linear-gradient(135deg, var(--card-study-bg-start) 0%, var(--card-study-bg-end) 100%);
            min-height: 300px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.3s;
            padding: 40px;
            margin-bottom: 20px;
            position: relative;
        }
        
        .card:hover {
            transform: scale(1.02);
        }
        
        .card-content {
            color: white;
            font-size: 24px;
            text-align: center;
            word-wrap: break-word;
            width: 100%;
        }
        
        .card-category {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .card-direction {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* v5.01: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒãƒƒã‚¸ */
        .card-type-badge {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .card-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .card-info {
            color: #666;
            font-size: 14px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }
        
        .empty-state h2 {
            margin-bottom: 10px;
            color: #666;
        }
        
        .card-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 5px solid #667eea;
            cursor: move; /* v10.02: ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã‚’ç¤ºã™ */
            transition: all 0.2s;
        }
        
        /* v10.02: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¹ã‚¿ã‚¤ãƒ« */
        .card-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .card-item.drag-over {
            border-top: 3px solid #667eea;
            margin-top: 20px;
        }
        
        .card-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        /* v10.02: ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ« */
        .drag-handle {
            font-size: 20px;
            color: #999;
            cursor: move;
            user-select: none;
            margin-right: 5px;
        }
        
        .card-item-title {
            font-weight: bold;
            color: #333;
        }
        
        .card-item-category {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .card-item-reverse-badge {
            background: #f39c12;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        /* v5.01: ç©´åŸ‹ã‚ãƒãƒƒã‚¸ */
        .card-item-cloze-badge {
            background: #9b59b6;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        /* v5.02: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ãƒãƒƒã‚¸ */
        .card-item-typing-badge {
            background: #16a085;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 5px;
        }
        
        /* v5.02: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */
        .typing-input-container {
            margin: 20px 0;
        }
        
        .typing-input {
            width: 100%;
            padding: 15px;
            font-size: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(255,255,255,0.9);
            color: #333;
            text-align: center;
        }
        
        .typing-input:focus {
            outline: none;
            border-color: white;
            background: white;
        }
        
        .typing-input.correct {
            border-color: #27ae60;
            background: #d5f4e6;
        }
        
        .typing-input.incorrect {
            border-color: #e74c3c;
            background: #fadbd8;
        }
        
        /* v5.02.1: æ–‡å­—æ•°è­¦å‘Š */
        .length-warning {
            background: #fff3cd;
            border-left: 4px solid #f39c12;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 4px;
            color: #856404;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* v5.02.1: æ–‡å­—ã”ã¨ã®åˆ¤å®šçµæœ */
        .typing-character-result {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .typing-character-result-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .typing-character-display {
            font-size: 24px;
            letter-spacing: 2px;
            font-family: monospace;
        }
        
        .char-correct {
            color: #27ae60;
            font-weight: bold;
        }
        
        .char-incorrect {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .typing-result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
        }
        
        .typing-result.correct {
            background: #27ae60;
            color: white;
        }
        
        .typing-result.incorrect {
            background: #e74c3c;
            color: white;
        }
        
        .typing-answers-list {
            margin-top: 10px;
        }
        
        .typing-answer-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .typing-answer-item input {
            flex: 1;
        }
        
        .typing-answer-item button {
            padding: 8px 16px;
        }
        
        .card-item-content {
            color: #666;
            margin-bottom: 10px;
        }
        
        .card-item-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        /* v10.02.1: ã‚«ãƒ¼ãƒ‰çµ±è¨ˆæƒ…å ± */
        .card-stats {
            font-size: 11px;
            color: #666;
            margin-left: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .sync-status {
            text-align: center;
            color: white;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .sync-status.synced {
            color: #2ecc71;
        }
        
        .sync-status.syncing {
            color: #f39c12;
        }
        
        .filter-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filter-group input,
        .filter-group select {
            flex: 1;
            min-width: 200px;
        }
        
        .pdf-upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .pdf-upload-area:hover {
            background: #e9ecef;
            border-color: #5568d3;
        }
        
        .pdf-upload-area.dragover {
            background: #d4e3fc;
            border-color: #667eea;
        }
        
        .pdf-upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #pdfFileInput {
            display: none;
        }
        
        .pdf-canvas-container {
            background: #525659;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
            overflow: auto;
            max-height: 70vh;
            position: relative;
        }
        
        .canvas-wrapper {
            position: relative;
            display: inline-block;
            margin: 0 auto;
            transition: transform 0.05s ease-out;
        }
        
        #pdfCanvas {
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: block;
            margin: 0 auto;
        }
        
        #markerCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }
        
        /* v14.00.14: previewCanvasç”¨ã®CSS */
        #previewCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€šéã•ã›ã‚‹ */
            z-index: 10; /* markerCanvasã®ä¸Šã«è¡¨ç¤º */
        }
        
        .marker-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .color-selector {
            display: flex;
            gap: 8px;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.active {
            border-color: #333;
            transform: scale(1.15);
        }
        
        .marker-label {
            font-weight: bold;
            color: #333;
        }
        
        .pdf-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
        }
        
        .pdf-info {
            color: #666;
            font-weight: bold;
        }
        
        .zoom-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .pdf-filename {
            background: #e9ecef;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            color: #495057;
            margin-bottom: 15px;
            display: inline-block;
        }
        
        .pdf-controls-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .row-label {
            color: #666;
            font-weight: bold;
            font-size: 14px;
            margin-right: 5px;
        }
        
        .separator {
            color: #999;
            font-weight: bold;
            margin: 0 5px;
        }
        
        .color-btn, .sheet-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            background: #fff;
        }
        
        .color-btn:hover, .sheet-btn:hover {
            transform: scale(1.05);
        }
        
        .color-btn.active, .sheet-btn.active {
            border-color: #333;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
        }
        
        .color-btn.yellow, .sheet-btn.yellow { color: #f39c12; }
        .color-btn.red, .sheet-btn.red { color: #e74c3c; }
        .color-btn.green, .sheet-btn.green { color: #27ae60; }
        .color-btn.blue, .sheet-btn.blue { color: #3498db; }
        
        .sheet-btn.all { 
            color: white;
            background: #34495e;
        }
        
        .sheet-btn.all.active {
            background: #2c3e50;
        }
        
        .instant-delete-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            font-size: 14px;
            color: #333;
            font-weight: bold;
        }
        
        .instant-delete-label input[type="checkbox"] {
            width: auto;
            height: auto;
            cursor: pointer;
        }
        
        .btn-mode-on {
            background: #27ae60 !important;
        }
        
        .btn-mode-on:hover {
            background: #229954 !important;
        }
        
        .btn-mode-off {
            background: #95a5a6 !important;
        }
        
        .btn-mode-off:hover {
            background: #7f8c8d !important;
        }
        
        /* v7.00: ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã‚¹ã‚¿ã‚¤ãƒ« */
        .btn-disabled {
            background: #bdc3c7 !important;
            color: #7f8c8d !important;
            cursor: not-allowed !important;
            opacity: 0.6;
        }
        
        .btn-disabled:hover {
            background: #bdc3c7 !important;
            transform: none !important;
        }
        
        .color-btn.disabled, .sheet-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        
        .redsheet-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            align-items: center;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .redsheet-label {
            color: #666;
            font-weight: bold;
            font-size: 14px;
            margin-right: 5px;
        }
        
        .redsheet-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            background: #fff;
        }
        
        .redsheet-btn:hover {
            transform: scale(1.05);
        }
        
        .redsheet-btn.active {
            border-color: #333;
            box-shadow: 0 0 8px rgba(0,0,0,0.2);
        }
        
        .redsheet-btn.yellow { color: #f39c12; }
        .redsheet-btn.red { color: #e74c3c; }
        .redsheet-btn.green { color: #27ae60; }
        .redsheet-btn.blue { color: #3498db; }
        .redsheet-btn.all { 
            color: white;
            background: #34495e;
        }
        
        .redsheet-btn.all.active {
            background: #2c3e50;
        }
        
        #markerCanvas.edit-mode {
            cursor: move !important;
        }
        
        #markerCanvas.delete-mode {
            cursor: not-allowed !important;
        }
        
        /* v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ« */
        #markerCanvas.study-mode {
            cursor: pointer !important;
        }
        
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
        }
        
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
        
        .textLayer ::selection {
            background: rgba(0, 0, 255, 0.3);
        }
        
        .deck-manager, .card-manager {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }
        
        .deck-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 5px solid #667eea;
        }
        
        .deck-item.child-deck {
            margin-left: 30px;
            border-left-color: #95a5a6;
        }
        
        .deck-item.grandchild-deck {
            margin-left: 60px;
            border-left-color: #bdc3c7;
        }
        
        .deck-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .deck-name {
            font-weight: bold;
            font-size: 18px;
            color: #333;
        }
        
        /* v6.01: ãƒ‡ãƒƒã‚­åã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã‚¹ã‚¿ã‚¤ãƒ« */
        .deck-header > div[onclick] {
            transition: background 0.2s;
            padding: 5px;
            border-radius: 5px;
            margin: -5px;
        }
        
        .deck-header > div[onclick]:hover {
            background: rgba(102, 126, 234, 0.1);
        }
        
        .deck-count {
            color: #666;
            font-size: 14px;
        }
        
        .deck-actions {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .deck-actions .btn {
            padding: 6px 12px;
            font-size: 14px;
            margin: 0;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 14px;
            margin-right: 5px;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            margin: 0;
            color: #333;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover,
        .close:focus {
            color: #000;
        }
        
        /* v10.00.1: ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .deck-selector-item {
            padding: 12px 15px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            border: 2px solid transparent;
        }
        
        .deck-selector-item:hover {
            background: #f0f0f0;
        }
        
        .deck-selector-item.selected {
            background: #e8f0fe;
            border-color: #667eea;
        }
        
        .deck-selector-item.child-deck {
            margin-left: 20px;
        }
        
        .deck-selector-item.grandchild-deck {
            margin-left: 40px;
        }
        
        /* v7.00.2: PDFå­¦ç¿’ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆå­¦ç¿’ãƒœã‚¿ãƒ³ã‚’ã€ŒPDFå­¦ç¿’ã€ã®å³æ¨ªã«é…ç½®ï¼‰ */
        .pdf-header {
            display: flex;
            align-items: center;
            gap: 20px;  /* h2ã¨ãƒœã‚¿ãƒ³ã®é–“éš” */
            margin-bottom: 20px;
        }
        
        .pdf-header h2 {
            margin: 0;
        }
        
        /* v7.02: å­¦ç¿’çµ±è¨ˆãƒ‘ãƒãƒ«ï¼ˆ2è¡Œæ§‹æˆï¼‰ */
        .study-stats {
            display: flex;
            flex-direction: column;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: opacity 0.3s;
        }
        
        .study-stats.inactive {
            opacity: 0.5;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .stat-separator {
            color: #ddd;
            font-weight: normal;
        }
        
        /* v8.02.3: æ›¸ãè¾¼ã¿ä¸Šé™è­¦å‘ŠãƒãƒŠãƒ¼ */
        .write-limit-warning {
            display: none;
            padding: 12px 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        
        .write-limit-warning.warning-80 {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #f39c12;
        }
        
        .write-limit-warning.warning-95 {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #e74c3c;
        }
        
        .write-limit-warning.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #e74c3c;
        }
        
        /* v12.00: ã‚¢ã‚¤ã‚³ãƒ³ã¨è‰²é¸æŠãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .icon-btn:hover, .color-picker-btn:hover {
            transform: scale(1.1);
            transition: transform 0.2s;
        }
        
        .icon-btn:active, .color-picker-btn:active {
            transform: scale(0.95);
        }
        
        .icon-btn, .color-picker-btn {
            transition: all 0.2s;
        }


        /* v12.00.2: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .deck-item {
            transition: all 0.2s;
        }
        
        .deck-item.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
        
        .deck-item.drag-over {
            background: rgba(102, 126, 234, 0.1);
            border: 2px dashed #667eea;
        }
        
        .drag-handle {
            cursor: move;
            font-size: 18px;
            color: #999;
            margin-right: 10px;
            user-select: none;
        }
        
        .drag-handle:hover {
            color: #667eea;
        }


/* v12.01: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .pagination button {
            padding: 8px 16px;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .pagination button:hover:not(:disabled) {
            background: #667eea;
            color: white;
        }
        
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pagination .current-page {
            background: #667eea;
            color: white;
        }
        
        .pagination-info {
            color: #666;
            font-size: 14px;
        }


        /* v12.03: ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ */
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        body.dark-mode .container {
            background: #1a1a1a;
        }
        
        body.dark-mode .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        body.dark-mode .tab {
            color: rgba(255, 255, 255, 0.7);
        }
        
        body.dark-mode .tab:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }
        
        body.dark-mode .tab.active {
            background: var(--tab-bg-active);
            color: white;
        }
        
        body.dark-mode .section {
            background: #2a2a2a;
        }
        
        body.dark-mode .card-creator,
        body.dark-mode .deck-container,
        body.dark-mode .deck-item {
            background: #2a2a2a;
            border-color: #444;
        }
        
        body.dark-mode input,
        body.dark-mode textarea,
        body.dark-mode select {
            background: #333;
            color: #e0e0e0;
            border-color: #555;
        }
        
        body.dark-mode .btn {
            background: #4a5568;
            color: white;
        }
        
        body.dark-mode .btn:hover {
            background: #5a6678;
        }
        
        body.dark-mode .btn-secondary {
            background: #555;
        }
        
        body.dark-mode .btn-secondary:hover {
            background: #666;
        }
        
        body.dark-mode .card-item {
            background: #2a2a2a;
            border-color: #444;
        }
        
        body.dark-mode .card-item:hover {
            background: #333;
        }
        
        body.dark-mode .modal-content {
            background: #2a2a2a;
            color: #e0e0e0;
        }
        
        body.dark-mode .empty-state {
            color: #999;
        }
        
        body.dark-mode label,
        body.dark-mode small {
            color: #bbb;
        }
        
        /* v12.03: ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚¯ãƒ©ã‚¹ */
        body.font-small {
            font-size: 12px;
        }
        
        body.font-medium {
            font-size: 14px; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ */
        }
        
        body.font-large {
            font-size: 16px;
        }
        
        body.font-xlarge {
            font-size: 18px;
        }
        
        /* v14.02.1.2: ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

    </style>
</head>
<body>
    <!-- v15.01.16: Firebase Authentication ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ -->
    <div id="loginScreen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 10000; display: flex; align-items: center; justify-content: center;">
        <div style="background: white; padding: 40px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <h2 style="text-align: center; color: #667eea; margin-bottom: 30px;">ğŸ“š MyAnkiApp ãƒ­ã‚°ã‚¤ãƒ³</h2>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</label>
                <input type="email" id="loginEmail" placeholder="example@email.com" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰</label>
                <input type="password" id="loginPassword" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
            </div>
            <div style="margin-bottom: 15px; padding: 10px; background: #e3f2fd; border-radius: 8px; font-size: 13px; color: #1976d2;">
                â„¹ï¸ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã¯è‡ªå‹•çš„ã«ç¶­æŒã•ã‚Œã¾ã™
            </div>
            <button onclick="loginWithEmail()" style="width: 100%; padding: 15px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-bottom: 10px;">ãƒ­ã‚°ã‚¤ãƒ³</button>
            <div id="loginError" style="color: #e74c3c; text-align: center; margin-top: 10px; font-weight: bold; display: none;"></div>
        </div>
    </div>
    
    <!-- v15.01.16: ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªç”»é¢ -->
    <div id="mainApp" style="display: none;">
    <div class="container">
        <h1>ğŸ“š MyAnkiApp <span style="font-size: 0.5em; color: rgba(255,255,255,0.8);">v16.03.05</span>
            <button onclick="logout()" style="float: right; background: #e74c3c; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; margin-top: 10px;">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
        </h1>
        
        <div class="sync-status" id="syncStatus">ğŸ”„ åŒæœŸä¸­...</div>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('home')">ãƒ›ãƒ¼ãƒ </button>
            <button class="tab" onclick="switchTab('study')">å­¦ç¿’</button>
            <button class="tab" onclick="switchTab('stats')">çµ±è¨ˆ</button>
            <button class="tab" onclick="switchTab('pdf')">PDF</button>
            <button class="tab" onclick="switchTab('cards')">ã‚«ãƒ¼ãƒ‰ç®¡ç†</button>
            <button class="tab" onclick="switchTab('settings')">è¨­å®š</button>
        </div>
        
        <div id="home-section" class="section active">
            <div class="deck-manager">
                <h2 style="margin-bottom: 20px;">ãƒ‡ãƒƒã‚­ä¸€è¦§</h2>
                <button class="btn" onclick="createNewDeck()" style="margin-bottom: 20px;">æ–°è¦ãƒ‡ãƒƒã‚­ä½œæˆ</button>
                <div id="deckList"></div>
            </div>
        </div>
        
        <div id="study-section" class="section">
            <div class="card-viewer">
                <h2 style="margin-bottom: 20px;">ã‚«ãƒ¼ãƒ‰å­¦ç¿’</h2>
                
                <!-- v8.02.3: æ›¸ãè¾¼ã¿ä¸Šé™è­¦å‘ŠãƒãƒŠãƒ¼ -->
                <div id="writeLimitWarning" class="write-limit-warning"></div>
                
                <div id="studyDeckSelector" style="margin-bottom: 20px;">
                    <div class="input-group">
                        <label for="studyDeckId">å­¦ç¿’ã™ã‚‹ãƒ‡ãƒƒã‚­ã‚’é¸æŠ</label>
                        <select id="studyDeckId" onchange="loadStudySession()">
                            <option value="">ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                        </select>
                    </div>
                    
                    <!-- v8.01: å­¦ç¿’è¨­å®š -->
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 15px 0;">
                        <h4 style="margin-bottom: 10px;">å­¦ç¿’è¨­å®š</h4>
                        
                        <div class="input-group">
                            <label for="studyMode">å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰</label>
                            <select id="studyMode">
                                <option value="mixed">æ··åˆå­¦ç¿’ï¼ˆæ–°è¦+å¾©ç¿’ï¼‰</option>
                                <option value="new">æ–°è¦ã‚«ãƒ¼ãƒ‰ã®ã¿</option>
                                <option value="review">å¾©ç¿’ã‚«ãƒ¼ãƒ‰ã®ã¿</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 15px; margin-top: 10px;">
                            <div class="input-group" style="flex: 1;">
                                <label for="newCardsLimit">æ–°è¦ã‚«ãƒ¼ãƒ‰ä¸Šé™</label>
                                <input type="number" id="newCardsLimit" value="20" min="0" max="100" style="width: 100%;">
                            </div>
                            
                            <div class="input-group" style="flex: 1;">
                                <label for="reviewCardsLimit">å¾©ç¿’ã‚«ãƒ¼ãƒ‰ä¸Šé™</label>
                                <input type="number" id="reviewCardsLimit" value="200" min="0" max="500" style="width: 100%;">
                            </div>
                        </div>
                        
                        <!-- v8.01.1: å‡ºé¡Œé †è¨­å®š -->
                        <div style="display: flex; gap: 15px; margin-top: 10px;">
                            <div class="input-group" style="flex: 1;">
                                <label for="newCardOrder">æ–°è¦ã‚«ãƒ¼ãƒ‰å‡ºé¡Œé †</label>
                                <select id="newCardOrder">
                                    <option value="added">è¿½åŠ é †</option>
                                    <option value="random">ãƒ©ãƒ³ãƒ€ãƒ </option>
                                </select>
                            </div>
                            
                            <div class="input-group" style="flex: 1;">
                                <label for="reviewCardOrder">å¾©ç¿’ã‚«ãƒ¼ãƒ‰å‡ºé¡Œé †</label>
                                <select id="reviewCardOrder">
                                    <option value="due">æœŸé™é †</option>
                                    <option value="random">ãƒ©ãƒ³ãƒ€ãƒ </option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- v8.01.2: æ–°è¦ã¨å¾©ç¿’ã‚’æ··ãœã‚‹è¨­å®š -->
                        <div class="checkbox-group" style="margin-top: 10px;">
                            <input type="checkbox" id="mixNewAndReview">
                            <label for="mixNewAndReview">æ–°è¦ã‚«ãƒ¼ãƒ‰ã¨å¾©ç¿’ã‚«ãƒ¼ãƒ‰ã‚’æ··ãœã‚‹</label>
                        </div>
                        
                        <div class="checkbox-group" style="margin-top: 10px;">
                            <input type="checkbox" id="includeSubdecks" checked>
                            <label for="includeSubdecks">ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’å«ã‚ã‚‹</label>
                        </div>
                    </div>
                    
                    <button class="btn" onclick="startStudySession()">å­¦ç¿’é–‹å§‹</button>
                </div>
                
                <div id="studyCardDisplay" style="display: none;">
                    <div id="studyStatsPanel" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 10px;">
                        <div style="display: flex; justify-content: space-between; flex-wrap: wrap; gap: 15px;">
                            <div>
                                <strong>æ–°è¦:</strong> <span id="newCardsCount">0</span>
                            </div>
                            <div>
                                <strong>å­¦ç¿’ä¸­:</strong> <span id="learningCardsCount">0</span>
                            </div>
                            <div>
                                <strong>å¾©ç¿’:</strong> <span id="reviewCardsCount">0</span>
                            </div>
                            <div>
                                <strong>å†å­¦ç¿’:</strong> <span id="relearnCardsCount">0</span>
                            </div>
                            <div id="waitingCardsInfo" style="display: none; color: #f39c12; font-weight: bold;">
                                <strong>â³ å¾…æ©Ÿä¸­:</strong> <span id="waitingCardsCount">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div id="studyCardContainer"></div>
                    
                    <div id="studyControls" style="margin-top: 20px;"></div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="endStudySession()">å­¦ç¿’çµ‚äº†</button>
                    </div>
                </div>
                
                <div id="studyComplete" style="display: none; text-align: center; padding: 40px;">
                    <h2>ğŸ‰ å­¦ç¿’å®Œäº†ï¼</h2>
                    <p style="margin: 20px 0;">æœ¬æ—¥ã®å­¦ç¿’ç›®æ¨™ã‚’é”æˆã—ã¾ã—ãŸ</p>
                    <button class="btn" onclick="endStudySession()">æˆ»ã‚‹</button>
                </div>
            </div>
        </div>
        
        <!-- v8.02: çµ±è¨ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div id="stats-section" class="section">
            <div class="deck-manager">
                <h2 style="margin-bottom: 20px;">ğŸ“Š å­¦ç¿’çµ±è¨ˆ</h2>
                
                <!-- v8.02.2: å…¨ä½“çµ±è¨ˆ -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">å…¨ä½“ã®çµ±è¨ˆ</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç·ã‚«ãƒ¼ãƒ‰æ•°</div>
                            <div style="font-size: 24px; font-weight: bold; color: #333;" id="totalCards">0</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">æ–°è¦ã‚«ãƒ¼ãƒ‰</div>
                            <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="totalNew">0</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #f39c12;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">å­¦ç¿’ä¸­</div>
                            <div style="font-size: 24px; font-weight: bold; color: #f39c12;" id="totalLearning">0</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">å¾©ç¿’ã‚«ãƒ¼ãƒ‰</div>
                            <div style="font-size: 24px; font-weight: bold; color: #3498db;" id="totalReview">0</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">Youngï¼ˆ21æ—¥æœªæº€ï¼‰</div>
                            <div style="font-size: 24px; font-weight: bold; color: #27ae60;" id="totalYoung">0</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #16a085;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">Matureï¼ˆ21æ—¥ä»¥ä¸Šï¼‰</div>
                            <div style="font-size: 24px; font-weight: bold; color: #16a085;" id="totalMature">0</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ä»Šæ—¥ã®å­¦ç¿’æ™‚é–“</div>
                            <div style="font-size: 24px; font-weight: bold; color: #9b59b6;" id="todayStudyTime">0åˆ†</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #e67e22;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ä»Šæ—¥ã®æ­£ç­”ç‡</div>
                            <div style="font-size: 24px; font-weight: bold; color: #e67e22;" id="todayAccuracy">N/A</div>
                        </div>
                    </div>
                </div>
                
                <!-- v8.02.3: å­¦ç¿’å±¥æ­´ -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">å­¦ç¿’å±¥æ­´</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 10px;">ä»Šé€±ã®å­¦ç¿’æ™‚é–“</div>
                            <div style="font-size: 20px; font-weight: bold; color: #667eea;" id="weekStudyTime">0æ™‚é–“0åˆ†</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">å¹³å‡: <span id="weekAvgTime">0åˆ†/æ—¥</span></div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 10px;">ä»Šæœˆã®å­¦ç¿’æ™‚é–“</div>
                            <div style="font-size: 20px; font-weight: bold; color: #667eea;" id="monthStudyTime">0æ™‚é–“0åˆ†</div>
                            <div style="font-size: 12px; color: #999; margin-top: 5px;">å­¦ç¿’æ—¥æ•°: <span id="monthStudyDays">0æ—¥</span></div>
                        </div>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                        <div style="font-size: 14px; color: #666; margin-bottom: 10px; font-weight: bold;">è©•ä¾¡ãƒœã‚¿ãƒ³ã®é›†è¨ˆï¼ˆä»Šæ—¥ï¼‰</div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                            <div>
                                <div style="font-size: 12px; color: #666;">ã‚‚ã†ä¸€åº¦</div>
                                <div style="font-size: 20px; font-weight: bold; color: #e74c3c;" id="todayAgain">0</div>
                            </div>
                            <div>
                                <div style="font-size: 12px; color: #666;">é›£ã—ã„</div>
                                <div style="font-size: 20px; font-weight: bold; color: #f39c12;" id="todayHard">0</div>
                            </div>
                            <div>
                                <div style="font-size: 12px; color: #666;">æ™®é€š</div>
                                <div style="font-size: 20px; font-weight: bold; color: #3498db;" id="todayGood">0</div>
                            </div>
                            <div>
                                <div style="font-size: 12px; color: #666;">ç°¡å˜</div>
                                <div style="font-size: 20px; font-weight: bold; color: #27ae60;" id="todayEasy">0</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- v8.02.3: Firestoreä½¿ç”¨çŠ¶æ³ -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">ğŸ’¾ Firestoreä½¿ç”¨çŠ¶æ³</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ä»Šæ—¥ã®æ›¸ãè¾¼ã¿</div>
                            <div style="font-size: 24px; font-weight: bold; color: #667eea;" id="firestoreWrites">0å›</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #95a5a6;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ä¸Šé™</div>
                            <div style="font-size: 24px; font-weight: bold; color: #95a5a6;">20,000å›/æ—¥</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ä½¿ç”¨ç‡</div>
                            <div style="font-size: 24px; font-weight: bold; color: #3498db;" id="firestoreUsage">0%</div>
                        </div>
                    </div>
                </div>
                
                <!-- v14.02.1: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è©³ç´° -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">ğŸ“Š ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è©³ç´°</h3>
                    
                    <!-- ç·ä½¿ç”¨é‡ -->
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #667eea;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div>
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç·ãƒ‡ãƒ¼ã‚¿é‡ï¼ˆæ¨å®šï¼‰</div>
                                <div style="font-size: 32px; font-weight: bold; color: #667eea;" id="totalStorageSize">è¨ˆç®—ä¸­...</div>
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                                    â€»ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å«ã‚€æ¨å®šå€¤ã€‚å®Ÿéš›ã®Firestoreã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¨ã®èª¤å·®ã¯Â±10-20%ç¨‹åº¦ã§ã™
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç·ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•°</div>
                                <div style="font-size: 28px; font-weight: bold; color: #3498db;" id="totalDocuments">0ä»¶</div>
                            </div>
                        </div>
                        <div style="background: white; height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="storageProgress" style="height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div style="font-size: 12px; color: #999; margin-top: 5px;">ç„¡æ–™æ : 1GB</div>
                    </div>
                    
                    <!-- ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³åˆ¥å†…è¨³ -->
                    <div style="margin-bottom: 15px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³åˆ¥å†…è¨³</h4>
                        <div id="storageBreakdown" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px;">
                            <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                        </div>
                    </div>
                    
                    <button class="btn btn-secondary" onclick="calculateStorageUsage()" style="width: 100%;">ğŸ”„ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—</button>
                    
                    <!-- v14.02.2: å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´å‰Šé™¤ -->
                    <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #f39c12;">
                        <h4 style="color: #856404; margin-bottom: 15px;">ğŸ—‘ï¸ å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã®å‰Šé™¤</h4>
                        <p style="font-size: 14px; color: #856404; margin-bottom: 15px;">
                            å¤ã„å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å‰Šé™¤ã—ã¦ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ã‚’ç¯€ç´„ã§ãã¾ã™ã€‚<br>
                            â€»ã‚«ãƒ¼ãƒ‰ã®å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆeaseã€intervalç­‰ï¼‰ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ã€‚
                        </p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label style="font-size: 14px; color: #856404; font-weight: bold; display: block; margin-bottom: 8px;">å‰Šé™¤å¯¾è±¡</label>
                                <select id="deleteSessionPeriod" onchange="previewSessionDeletion()" style="width: 100%; padding: 10px; border: 1px solid #f39c12; border-radius: 5px;">
                                    <option value="30">30æ—¥ã‚ˆã‚Šå‰</option>
                                    <option value="90">90æ—¥ã‚ˆã‚Šå‰</option>
                                    <option value="180">180æ—¥ã‚ˆã‚Šå‰</option>
                                    <option value="365">1å¹´ã‚ˆã‚Šå‰</option>
                                    <option value="custom">ã‚«ã‚¹ã‚¿ãƒ æ—¥ä»˜ã‚ˆã‚Šå‰</option>
                                </select>
                                
                                <div id="customDateInput" style="display: none; margin-top: 10px;">
                                    <input type="date" id="customDeleteDate" onchange="previewSessionDeletion()" style="width: 100%; padding: 10px; border: 1px solid #f39c12; border-radius: 5px;">
                                </div>
                            </div>
                            
                            <div>
                                <label style="font-size: 14px; color: #856404; font-weight: bold; display: block; margin-bottom: 8px;">å‰Šé™¤ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</label>
                                <div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #f39c12;">
                                    <div style="font-size: 14px; color: #666; margin-bottom: 5px;">å‰Šé™¤å¯¾è±¡åˆè¨ˆ</div>
                                    <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="deletePreviewCount">è¨ˆç®—ä¸­...</div>
                                    <div style="font-size: 12px; color: #999; margin-top: 5px;" id="deletePreviewSize">-</div>
                                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #f0f0f0; font-size: 12px; color: #666;">
                                        <div id="deletePreviewDetails">-</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <button class="btn btn-danger" onclick="deleteOldSessions()" style="width: 100%;">ğŸ—‘ï¸ å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å‰Šé™¤</button>
                        
                        <!-- v14.02.3: é–‹ç™ºè€…ç”¨ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ -->
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 2px dashed #f39c12;">
                            <p style="font-size: 12px; color: #999; margin-bottom: 10px;">
                                ğŸ§ª é–‹ç™ºè€…ç”¨ï¼šå‰Šé™¤æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆç”¨ã«å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’ä½œæˆã—ã¾ã™
                            </p>
                            <button class="btn btn-secondary" onclick="createTestSessions()" style="width: 100%; font-size: 13px;">
                                ğŸ§ª ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆ100ä»¶ã®å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ï¼‰
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- v14.02.6: ãƒ‡ãƒ¼ã‚¿å®¹é‡ã®æœ€é©åŒ– -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px; color: #667eea;">ğŸ”§ ãƒ‡ãƒ¼ã‚¿å®¹é‡ã®æœ€é©åŒ–</h3>
                    <p style="font-size: 14px; color: #666; margin-bottom: 20px;">
                        ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã—ã¦å‰Šé™¤ã—ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ã‚’æœ€é©åŒ–ã—ã¾ã™ã€‚
                    </p>
                    
                    <button class="btn" onclick="scanForOptimization()" style="width: 100%; margin-bottom: 20px;">
                        ğŸ” ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒ³ã‚’å®Ÿè¡Œ
                    </button>
                    
                    <div id="optimizationResults" style="display: none;">
                        <!-- å­¤ç«‹ã‚«ãƒ¼ãƒ‰ -->
                        <div id="orphanCardsSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #f39c12;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #856404; margin: 0;">âš ï¸ å­¤ç«‹ã‚«ãƒ¼ãƒ‰</h4>
                                <span style="font-size: 20px; font-weight: bold; color: #e74c3c;" id="orphanCardsCount">0ä»¶</span>
                            </div>
                            <p style="font-size: 13px; color: #856404; margin-bottom: 10px;">
                                ãƒ‡ãƒƒã‚­ãŒå­˜åœ¨ã—ãªã„ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ãƒ‡ãƒƒã‚­ã«ç§»å‹•ã™ã‚‹ã‹ã€ç·¨é›†ã€ã¾ãŸã¯å‰Šé™¤ã§ãã¾ã™ã€‚
                            </p>
                            <div id="orphanCardsList" style="max-height: 400px; overflow-y: auto; background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                                <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                            </div>
                            <button class="btn btn-danger" onclick="deleteAllOrphanCards()" style="width: 100%;">
                                ğŸ—‘ï¸ ã™ã¹ã¦ã®å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                            </button>
                        </div>
                        
                        <!-- å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼ -->
                        <div id="orphanMarkersSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #f39c12;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #856404; margin: 0;">âš ï¸ å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼</h4>
                                <span style="font-size: 20px; font-weight: bold; color: #e74c3c;" id="orphanMarkersCount">0ä»¶</span>
                            </div>
                            <p style="font-size: 13px; color: #856404; margin-bottom: 10px;">
                                å¯¾å¿œã™ã‚‹PDFãŒå­˜åœ¨ã—ãªã„ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚
                            </p>
                            <div id="orphanMarkersList" style="max-height: 150px; overflow-y: auto; background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 13px;">
                            </div>
                            <button class="btn btn-danger" onclick="deleteOrphanMarkers()" style="width: 100%;">
                                ğŸ—‘ï¸ å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
                            </button>
                        </div>
                        
                        <!-- é‡è¤‡ã‚«ãƒ¼ãƒ‰ -->
                        <div id="duplicateCardsSection" style="display: none; background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #3498db;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #1565c0; margin: 0;">ğŸ“‹ é‡è¤‡ã‚«ãƒ¼ãƒ‰</h4>
                                <span style="font-size: 20px; font-weight: bold; color: #1565c0;" id="duplicateCardsCount">0ã‚°ãƒ«ãƒ¼ãƒ—</span>
                            </div>
                            <p style="font-size: 13px; color: #1565c0; margin-bottom: 10px;">
                                åŒã˜å†…å®¹ã®ã‚«ãƒ¼ãƒ‰ãŒè¤‡æ•°è¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚é‡è¤‡ã‚’å‰Šé™¤ã§ãã¾ã™ã€‚
                            </p>
                            <div id="duplicateCardsList" style="max-height: 150px; overflow-y: auto; background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 13px;">
                            </div>
                            <button class="btn" onclick="showDuplicateCardsDetail()" style="width: 100%; background: #3498db; border-color: #3498db;">
                                ğŸ“‹ é‡è¤‡ã‚«ãƒ¼ãƒ‰ã®è©³ç´°ã‚’è¡¨ç¤º
                            </button>
                        </div>
                        
                        <!-- æœªä½¿ç”¨ã‚¿ã‚° -->
                        <div id="unusedTagsSection" style="display: none; background: #f3e5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #9c27b0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #6a1b9a; margin: 0;">ğŸ·ï¸ æœªä½¿ç”¨ã‚¿ã‚°</h4>
                                <span style="font-size: 20px; font-weight: bold; color: #6a1b9a;" id="unusedTagsCount">0ä»¶</span>
                            </div>
                            <p style="font-size: 13px; color: #6a1b9a; margin-bottom: 10px;">
                                ã‚«ãƒ¼ãƒ‰ã«ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„ã‚¿ã‚°ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚
                            </p>
                            <div id="unusedTagsList" style="max-height: 150px; overflow-y: auto; background: white; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 13px;">
                            </div>
                            <p style="font-size: 12px; color: #999; margin-top: 10px;">
                                â„¹ï¸ æœªä½¿ç”¨ã‚¿ã‚°ã¯è‡ªå‹•çš„ã«è¡¨ç¤ºã‹ã‚‰é™¤å¤–ã•ã‚Œã¾ã™ã€‚æ‰‹å‹•å‰Šé™¤ã¯ä¸è¦ã§ã™ã€‚
                            </p>
                        </div>
                        
                        <!-- æœ€é©åŒ–å®Œäº† -->
                        <div id="optimizationComplete" style="display: none; background: #d4edda; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745;">
                            <h4 style="color: #155724; margin: 0 0 10px 0;">âœ… æœ€é©åŒ–ã®å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã¯ã‚ã‚Šã¾ã›ã‚“</h4>
                            <p style="font-size: 13px; color: #155724; margin: 0;">
                                ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã¯é©åˆ‡ã«ç®¡ç†ã•ã‚Œã¦ã„ã¾ã™ã€‚
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- v14.02.8: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px; color: #667eea;">ğŸ” ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯</h3>
                    <p style="font-size: 14px; color: #666; margin-bottom: 20px;">
                        ãƒ‡ãƒ¼ã‚¿ã®ä¸æ•´åˆã‚„ç ´æã‚’ãƒã‚§ãƒƒã‚¯ã—ã€è‡ªå‹•ä¿®å¾©ã§ãã¾ã™ã€‚
                    </p>
                    
                    <button class="btn" onclick="runIntegrityCheck()" style="width: 100%; margin-bottom: 20px;">
                        ğŸ” æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
                    </button>
                    
                    <div id="integrityCheckResults" style="display: none;">
                        <!-- ãƒã‚§ãƒƒã‚¯çµæœã®è¡¨ç¤º -->
                        <div id="integrityCheckSummary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="color: #667eea; margin-bottom: 10px;">ãƒã‚§ãƒƒã‚¯çµæœã‚µãƒãƒªãƒ¼</h4>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 24px; font-weight: bold; color: #27ae60;" id="integrityOkCount">0</div>
                                    <div style="font-size: 13px; color: #666;">æ­£å¸¸</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 24px; font-weight: bold; color: #f39c12;" id="integrityWarningCount">0</div>
                                    <div style="font-size: 13px; color: #666;">è­¦å‘Š</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="integrityErrorCount">0</div>
                                    <div style="font-size: 13px; color: #666;">ã‚¨ãƒ©ãƒ¼</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- è©³ç´°çµæœ -->
                        <div id="integrityCheckDetails" style="max-height: 400px; overflow-y: auto;">
                            <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                        </div>
                        
                        <!-- è‡ªå‹•ä¿®å¾©ãƒœã‚¿ãƒ³ -->
                        <div id="integrityFixSection" style="display: none; margin-top: 15px;">
                            <button class="btn" onclick="autoFixIntegrityIssues()" style="width: 100%; background: #f39c12; border-color: #f39c12;">
                                ğŸ”§ è‡ªå‹•ä¿®å¾©ã‚’å®Ÿè¡Œ
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆ -->
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px; color: #667eea;">âš ï¸ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆ</h3>
                    
                    <!-- ã‚¢ãƒ©ãƒ¼ãƒˆçŠ¶æ…‹è¡¨ç¤º -->
                    <div id="storageAlertStatus">
                        <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                    </div>
                    
                    <!-- å‰Šé™¤æ¨å¥¨é …ç›® -->
                    <div id="storageRecommendations" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">å‰Šé™¤æ¨å¥¨é …ç›®</h4>
                        <div id="storageRecommendationsList">
                            <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                        </div>
                    </div>
                    
                    <!-- ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡æ¨ç§»ã‚°ãƒ©ãƒ•ï¼ˆç°¡æ˜“ç‰ˆï¼‰ -->
                    <div style="margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã®æ¨ç§»</h4>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                            <div id="storageHistoryChart" style="height: 100px; position: relative;">
                                <!-- ç°¡æ˜“çš„ãªãƒãƒ¼ãƒãƒ£ãƒ¼ãƒˆ -->
                            </div>
                            <div style="font-size: 12px; color: #999; margin-top: 10px; text-align: center;">
                                éå»7æ—¥é–“ã®ä½¿ç”¨é‡æ¨ç§»
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- v8.02.1: ãƒ‡ãƒƒã‚­ã”ã¨ã®çµ±è¨ˆ -->
                <div style="background: white; padding: 20px; border-radius: 10px;">
                    <h3 style="margin-bottom: 15px;">ãƒ‡ãƒƒã‚­ã”ã¨ã®çµ±è¨ˆ</h3>
                    <div id="deckStats"></div>
                </div>
            </div>
        </div>
        
        <div id="cards-section" class="section">
            <div class="card-manager">
                <h2 style="margin-bottom: 20px;">ã‚«ãƒ¼ãƒ‰ç®¡ç†</h2>
                
                <div class="card-creator">
                    <h3 style="margin-bottom: 15px;">æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆ</h3>
                    
                    <!-- v5.01: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—é¸æŠã‚¿ãƒ– -->
                    <div class="card-type-tabs">
                        <button class="card-type-tab active" onclick="switchCardType('basic')">åŸºæœ¬ã‚«ãƒ¼ãƒ‰</button>
                        <button class="card-type-tab" onclick="switchCardType('cloze')">ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰</button>
                        <button class="card-type-tab" onclick="switchCardType('typing')">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰</button>
                    </div>
                    
                    <!-- v6.00: ã‚«ãƒ†ã‚´ãƒªâ†’ãƒ‡ãƒƒã‚­ã«å¤‰æ›´ -->
                    <div class="input-group">
                        <label for="deckId">ãƒ‡ãƒƒã‚­</label>
                        <select id="deckId">
                            <option value="">ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                        </select>
                    </div>
                    
                    <!-- åŸºæœ¬ã‚«ãƒ¼ãƒ‰å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                    <div id="basicCardInputs">
                        <div class="input-group">
                            <label for="question">å•é¡Œ</label>
                            <textarea id="question" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ãŒæ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸå¹´ã¯ï¼Ÿ"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="answer">ç­”ãˆ</label>
                            <textarea id="answer" placeholder="ä¾‹ï¼š1603å¹´"></textarea>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="enableReverse">
                            <label for="enableReverse">é€†æ–¹å‘ã‚‚å­¦ç¿’ï¼ˆç­”ãˆâ†’å•é¡Œï¼‰</label>
                        </div>
                    </div>
                    
                    <!-- v5.01: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                    <div id="clozeCardInputs" style="display: none;">
                        <div class="input-group">
                            <label for="clozeText">ãƒ†ã‚­ã‚¹ãƒˆ</label>
                            <textarea id="clozeText" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ã¯1603å¹´ã«æ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸã€‚"></textarea>
                        </div>
                        <div class="cloze-controls">
                            <button class="btn btn-secondary" onclick="insertCloze()">é¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«</button>
                            <button class="btn btn-secondary" onclick="removeCloze()">ç©´åŸ‹ã‚ã‚’å‰Šé™¤</button>
                        </div>
                        <div class="cloze-preview">
                            <div class="cloze-preview-label">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼:</div>
                            <div id="clozePreview" class="cloze-text">ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</div>
                        </div>
                    </div>
                    
                    <!-- v5.02: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                    <div id="typingCardInputs" style="display: none;">
                        <div class="input-group">
                            <label for="typingQuestion">å•é¡Œ</label>
                            <textarea id="typingQuestion" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ãŒæ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸå¹´ã¯ï¼Ÿ"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="typingAnswer">æ­£è§£</label>
                            <input type="text" id="typingAnswer" placeholder="ä¾‹ï¼š1603å¹´">
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="typingCaseSensitive">
                            <label for="typingCaseSensitive">å¤§æ–‡å­—å°æ–‡å­—ãƒ»å…¨è§’åŠè§’ã‚’åŒºåˆ¥ã™ã‚‹</label>
                        </div>
                    </div>
                    
                    <!-- v10.01: ã‚¿ã‚°å…¥åŠ›æ¬„ï¼ˆå…¨ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—å…±é€šï¼‰ -->
                    <div class="input-group">
                        <label for="cardTags">ã‚¿ã‚°ï¼ˆåŠè§’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šï¼‰</label>
                        <input type="text" id="cardTags" placeholder="ä¾‹ï¼šé‡è¦ è©¦é¨“ç¯„å›² ç¬¬3ç« ">
                        <small style="color: #666;">éšå±¤ã‚¿ã‚°ã¯::ã§åŒºåˆ‡ã‚Šã¾ã™ï¼ˆä¾‹ï¼šæ•°å­¦::å¾®åˆ†::åŸºæœ¬ï¼‰</small>
                    </div>
                    
                    <button class="btn" onclick="addCard()">ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ </button>
                </div>
                
                <hr style="margin: 30px 0; border: none; border-top: 2px solid #eee;">
                
                <div class="card-preview">
                    <h3 style="margin-bottom: 15px;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                    <div id="cardControls" style="margin-bottom: 20px;"></div>
                    <div id="cardDisplay"></div>
                </div>
                
                <hr style="margin: 30px 0; border: none; border-top: 2px solid #eee;">
                
                <div class="card-list">
                    <h3 style="margin-bottom: 15px;">ã‚«ãƒ¼ãƒ‰ä¸€è¦§</h3>
                    <div style="margin-bottom: 20px;">
                        <button class="btn btn-success" onclick="exportToAnki()">Ankiç”¨CSVå‡ºåŠ›</button>
                        <div style="margin-top: 8px; font-size: 12px; color: #666;">
                            â€»é¸æŠã‚«ãƒ¼ãƒ‰ã¾ãŸã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ä¸­ã®ãƒ‡ãƒƒã‚­ã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆå•é¡Œãƒ»ç­”ãˆã®ã¿ï¼‰
                        </div>
                    </div>
                    <!-- v10.00: ä¸€æ‹¬æ“ä½œUI -->
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #667eea;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <input type="checkbox" id="selectAllCards" onchange="toggleSelectAllCards()" style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="selectAllCards" style="margin: 0; font-weight: bold; cursor: pointer;">ã™ã¹ã¦é¸æŠ</label>
                            <span id="selectedCardCount" style="color: #667eea; margin-left: 10px;">0æšé¸æŠä¸­</span>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="bulkMoveCards()" id="bulkMoveBtn" disabled>é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ç§»å‹•</button>
                            <button class="btn btn-danger" onclick="bulkDeleteCards()" id="bulkDeleteBtn" disabled>é¸æŠã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤</button>
                            <button class="btn btn-success" onclick="bulkExportCards()" id="bulkExportBtn" disabled>é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                        </div>
                        <div style="margin-top: 10px; font-size: 12px; color: #666;">
                            â€»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ: å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆJSONå½¢å¼ï¼‰
                        </div>
                    </div>
                    <div class="filter-group">
                        <input type="text" id="searchInput" placeholder="æ¤œç´¢ï¼ˆå•é¡Œãƒ»ç­”ãˆãƒ»ã‚¿ã‚°ï¼‰..." onkeyup="filterCards()">
                        <select id="deckFilter" onchange="filterCards()">
                            <option value="">ã™ã¹ã¦ã®ãƒ‡ãƒƒã‚­</option>
                        </select>
                    </div>
                    <!-- v10.01: è¿½åŠ ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ -->
                    <div class="filter-group" style="margin-top: 10px;">
                        <select id="cardTypeFilter" onchange="filterCards()">
                            <option value="">ã™ã¹ã¦ã®ã‚¿ã‚¤ãƒ—</option>
                            <option value="basic">åŸºæœ¬ã‚«ãƒ¼ãƒ‰</option>
                            <option value="cloze">ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰</option>
                            <option value="typing">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼</option>
                        </select>
                        <select id="cardStateFilter" onchange="filterCards()">
                            <option value="">ã™ã¹ã¦ã®å­¦ç¿’çŠ¶æ…‹</option>
                            <option value="new">æ–°è¦ï¼ˆæœªå­¦ç¿’ï¼‰</option>
                            <option value="learning">å­¦ç¿’ä¸­</option>
                            <option value="review">å¾©ç¿’ï¼ˆãƒã‚¹ã‚¿ãƒ¼æ¸ˆã¿ï¼‰</option>
                        </select>
                    </div>
                    <!-- v10.02: ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½ -->
                    <div class="filter-group" style="margin-top: 10px;">
                        <select id="sortBy" onchange="sortCards()">
                            <option value="manual">æ‰‹å‹•é †åº</option>
                            <option value="createdDate">ä½œæˆæ—¥é †</option>
                            <option value="lastStudied">æœ€çµ‚å­¦ç¿’æ—¥é †</option>
                            <option value="studyCount">å­¦ç¿’å›æ•°é †</option>
                            <option value="cardType">ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—é †</option>
                            <option value="tags">ã‚¿ã‚°é †</option>
                        </select>
                        <select id="sortOrder" onchange="sortCards()">
                            <option value="asc">æ˜‡é †</option>
                            <option value="desc">é™é †</option>
                        </select>
                    </div>
                    <!-- v12.01.6: è¡¨ç¤ºä»¶æ•°é¸æŠ -->
                    <div class="filter-group" style="margin-top: 10px;">
                        <label for="cardsPerPageSelect" style="margin-right: 10px;">è¡¨ç¤ºä»¶æ•°:</label>
                        <select id="cardsPerPageSelect" onchange="changeCardsPerPage()">
                            <option value="50">50ä»¶</option>
                            <option value="100">100ä»¶</option>
                            <option value="200">200ä»¶</option>
                            <option value="999999">å…¨ä»¶</option>
                        </select>
                    </div>
                    <div id="cardList"></div>
                </div>
            </div>
        </div>
        
        <!-- v8.02.4: è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div id="settings-section" class="section">
            <div class="card-creator">
                <h2 style="margin-bottom: 30px;">å­¦ç¿’è¨­å®š</h2>
                
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 30px; border-left: 4px solid #667eea;">
                    <p style="margin: 0; color: #666;">ã“ã®è¨­å®šã¯ã™ã¹ã¦ã®æ–°è¦ãƒ‡ãƒƒã‚­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«ãªã‚Šã¾ã™ã€‚<br>ãƒ‡ãƒƒã‚­ã”ã¨ã«å€‹åˆ¥è¨­å®šã‚‚å¯èƒ½ã§ã™ï¼ˆãƒ‡ãƒƒã‚­ç·¨é›†ã‹ã‚‰å¤‰æ›´ã§ãã¾ã™ï¼‰ã€‚</p>
                </div>
                
                <div class="input-group">
                    <label>å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆåˆ†ï¼‰</label>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;" id="learningStepsContainer"></div>
                    <button class="btn btn-secondary" onclick="addLearningStep()">+ ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿½åŠ </button>
                </div>
                
                <div class="input-group">
                    <label for="graduatingInterval">å’æ¥­é–“éš”ï¼ˆæ—¥ï¼‰</label>
                    <input type="number" id="graduatingInterval" min="1" value="1">
                    <small style="color: #666;">å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†å¾Œã€æœ€åˆã®å¾©ç¿’ã¾ã§ã®é–“éš”</small>
                </div>
                
                <div class="input-group">
                    <label for="easyInterval">ç°¡å˜é–“éš”ï¼ˆæ—¥ï¼‰</label>
                    <input type="number" id="easyInterval" min="1" value="4">
                    <small style="color: #666;">å­¦ç¿’ä¸­ã«ã€Œç°¡å˜ã€ã‚’æŠ¼ã—ãŸæ™‚ã®æ¬¡å›å¾©ç¿’ã¾ã§ã®é–“éš”</small>
                </div>
                
                <div class="input-group">
                    <label for="startingEase">åˆæœŸé›£æ˜“åº¦</label>
                    <input type="number" id="startingEase" min="1.3" max="5.0" step="0.1" value="2.5">
                    <small style="color: #666;">æ–°è¦ã‚«ãƒ¼ãƒ‰ã®åˆæœŸé›£æ˜“åº¦ä¿‚æ•°ï¼ˆæ¨å¥¨: 2.5ï¼‰</small>
                </div>
                
                <div class="input-group">
                    <label for="easyBonus">ç°¡å˜ãƒœãƒ¼ãƒŠã‚¹</label>
                    <input type="number" id="easyBonus" min="1.0" max="3.0" step="0.1" value="1.3">
                    <small style="color: #666;">ã€Œç°¡å˜ã€ã‚’æŠ¼ã—ãŸæ™‚ã®é–“éš”å€ç‡ï¼ˆæ¨å¥¨: 1.3ï¼‰</small>
                </div>
                
                <div class="input-group">
                    <label for="intervalModifier">é–“éš”èª¿æ•´ä¿‚æ•°</label>
                    <input type="number" id="intervalModifier" min="0.5" max="2.0" step="0.05" value="1.0">
                    <small style="color: #666;">å…¨ä½“çš„ãªå¾©ç¿’é–“éš”ã®èª¿æ•´ï¼ˆ1.0ãŒæ¨™æº–ã€å¤§ãã„ã»ã©é–“éš”ãŒé•·ããªã‚‹ï¼‰</small>
                </div>
                
                <div class="input-group">
                    <label for="maximumInterval">æœ€å¤§é–“éš”ï¼ˆæ—¥ï¼‰</label>
                    <input type="number" id="maximumInterval" min="1" max="36500" value="36500">
                    <small style="color: #666;">å¾©ç¿’é–“éš”ã®ä¸Šé™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 36500æ—¥ = 100å¹´ï¼‰</small>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 30px;">
                    <button class="btn" onclick="saveGlobalSettings()">è¨­å®šã‚’ä¿å­˜</button>
                    <button class="btn btn-secondary" onclick="resetToDefaultSettings()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
                </div>
                
                <!-- v12.03: è¡¨ç¤ºè¨­å®š -->
                <hr style="margin: 50px 0; border: none; border-top: 2px solid #e0e0e0;">
                
                <h2 style="margin-bottom: 30px;">è¡¨ç¤ºè¨­å®š</h2>
                
                <div class="input-group">
                    <label>ã‚«ãƒ©ãƒ¼ãƒ†ãƒ¼ãƒ</label>
                    <div style="display: flex; gap: 15px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="theme" value="light" id="themeLight" onchange="changeTheme('light')">
                            <span>â˜€ï¸ ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="theme" value="custom" id="themeCustom" onchange="changeTheme('custom')">
                            <span>ğŸ¨ ã‚«ã‚¹ã‚¿ãƒ </span>
                        </label>
                    </div>
                </div>
                
                <div class="input-group">
                    <label>ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º</label>
                    <div style="display: flex; gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="fontSize" value="small" id="fontSmall" onchange="changeFontSize('small')">
                            <span>å°</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="fontSize" value="medium" id="fontMedium" onchange="changeFontSize('medium')">
                            <span>ä¸­</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="fontSize" value="large" id="fontLarge" onchange="changeFontSize('large')">
                            <span>å¤§</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="fontSize" value="xlarge" id="fontXLarge" onchange="changeFontSize('xlarge')">
                            <span>ç‰¹å¤§</span>
                        </label>
                    </div>
                </div>

                
                <!-- v12.03.3: ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆ41é …ç›®å®Œå…¨ç‰ˆï¼‰ -->
                <div id="customColorSettings" style="display: none; margin-top: 30px; padding: 20px; background: var(--bg-section); border: 2px solid var(--border-color); border-radius: 8px;">
                    <h3 style="margin-bottom: 20px; color: var(--text-main);">è©³ç´°ã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆ41é …ç›®ï¼‰</h3>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 30px;">
                        <!-- 1. èƒŒæ™¯è‰²ï¼ˆ7é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">èƒŒæ™¯è‰²ï¼ˆ7é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ¡ã‚¤ãƒ³èƒŒæ™¯:</label>
                                    <input type="color" id="color_bg_main" onchange="updateColorVar('--bg-main', this.value)">
                                    <input type="text" id="text_bg_main" value="linear-gradient(135deg, #667eea 0%, #764ba2 100%)" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-main', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚»ã‚¯ã‚·ãƒ§ãƒ³èƒŒæ™¯:</label>
                                    <input type="color" id="color_bg_section" onchange="updateColorVar('--bg-section', this.value)">
                                    <input type="text" id="text_bg_section" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-section', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¢ã‚¤ãƒ†ãƒ èƒŒæ™¯:</label>
                                    <input type="color" id="color_bg_item" onchange="updateColorVar('--bg-item', this.value)">
                                    <input type="text" id="text_bg_item" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-item', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯:</label>
                                    <input type="color" id="color_bg_modal" onchange="updateColorVar('--bg-modal', this.value)">
                                    <input type="text" id="text_bg_modal" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-modal', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ˜ãƒƒãƒ€ãƒ¼é–‹å§‹:</label>
                                    <input type="color" id="color_bg_header_start" onchange="updateColorVar('--bg-header-start', this.value)">
                                    <input type="text" id="text_bg_header_start" value="#667eea" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-header-start', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ˜ãƒƒãƒ€ãƒ¼çµ‚äº†:</label>
                                    <input type="color" id="color_bg_header_end" onchange="updateColorVar('--bg-header-end', this.value)">
                                    <input type="text" id="text_bg_header_end" value="#764ba2" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-header-end', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">å…¥åŠ›èƒŒæ™¯:</label>
                                    <input type="color" id="color_bg_input" onchange="updateColorVar('--bg-input', this.value)">
                                    <input type="text" id="text_bg_input" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--bg-input', this.value)">
                                </div>
                            </div>
                        </div>
                        
                        <!-- 2. æ–‡å­—è‰²ï¼ˆ4é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">æ–‡å­—è‰²ï¼ˆ4é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ¡ã‚¤ãƒ³æ–‡å­—:</label>
                                    <input type="color" id="color_text_main" onchange="updateColorVar('--text-main', this.value)">
                                    <input type="text" id="text_text_main" value="#333333" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--text-main', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚µãƒ–æ–‡å­—:</label>
                                    <input type="color" id="color_text_sub" onchange="updateColorVar('--text-sub', this.value)">
                                    <input type="text" id="text_text_sub" value="#666666" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--text-sub', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒªãƒ³ã‚¯:</label>
                                    <input type="color" id="color_text_link" onchange="updateColorVar('--text-link', this.value)">
                                    <input type="text" id="text_text_link" value="#667eea" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--text-link', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼:</label>
                                    <input type="color" id="color_text_placeholder" onchange="updateColorVar('--text-placeholder', this.value)">
                                    <input type="text" id="text_text_placeholder" value="#999999" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--text-placeholder', this.value)">
                                </div>
                            </div>
                            
                            <h4 style="margin: 20px 0 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">ãƒœãƒ¼ãƒ€ãƒ¼ï¼ˆ2é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒœãƒ¼ãƒ€ãƒ¼:</label>
                                    <input type="color" id="color_border_color" onchange="updateColorVar('--border-color', this.value)">
                                    <input type="text" id="text_border_color" value="#dddddd" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--border-color', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">åŒºåˆ‡ã‚Šç·š:</label>
                                    <input type="color" id="color_divider_color" onchange="updateColorVar('--divider-color', this.value)">
                                    <input type="text" id="text_divider_color" value="#e0e0e0" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--divider-color', this.value)">
                                </div>
                            </div>
                        </div>
                        
                        <!-- 3. ãƒœã‚¿ãƒ³ï¼ˆ9é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">ãƒœã‚¿ãƒ³ï¼ˆ9é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ—ãƒ©ã‚¤ãƒãƒªèƒŒæ™¯:</label>
                                    <input type="color" id="color_btn_primary_bg" onchange="updateColorVar('--btn-primary-bg', this.value)">
                                    <input type="text" id="text_btn_primary_bg" value="#667eea" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-primary-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ—ãƒ©ã‚¤ãƒãƒªæ–‡å­—:</label>
                                    <input type="color" id="color_btn_primary_text" onchange="updateColorVar('--btn-primary-text', this.value)">
                                    <input type="text" id="text_btn_primary_text" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-primary-text', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚»ã‚«ãƒ³ãƒ€ãƒªèƒŒæ™¯:</label>
                                    <input type="color" id="color_btn_secondary_bg" onchange="updateColorVar('--btn-secondary-bg', this.value)">
                                    <input type="text" id="text_btn_secondary_bg" value="#95a5a6" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-secondary-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚»ã‚«ãƒ³ãƒ€ãƒªæ–‡å­—:</label>
                                    <input type="color" id="color_btn_secondary_text" onchange="updateColorVar('--btn-secondary-text', this.value)">
                                    <input type="text" id="text_btn_secondary_text" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-secondary-text', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">å‰Šé™¤èƒŒæ™¯:</label>
                                    <input type="color" id="color_btn_danger_bg" onchange="updateColorVar('--btn-danger-bg', this.value)">
                                    <input type="text" id="text_btn_danger_bg" value="#e74c3c" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-danger-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">å‰Šé™¤æ–‡å­—:</label>
                                    <input type="color" id="color_btn_danger_text" onchange="updateColorVar('--btn-danger-text', this.value)">
                                    <input type="text" id="text_btn_danger_text" value="#ffffff" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-danger-text', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ›ãƒãƒ¼èƒŒæ™¯:</label>
                                    <input type="color" id="color_btn_hover_bg" onchange="updateColorVar('--btn-hover-bg', this.value)">
                                    <input type="text" id="text_btn_hover_bg" value="#5568d3" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-hover-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ç„¡åŠ¹æ™‚èƒŒæ™¯:</label>
                                    <input type="color" id="color_btn_disabled_bg" onchange="updateColorVar('--btn-disabled-bg', this.value)">
                                    <input type="text" id="text_btn_disabled_bg" value="#cccccc" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-disabled-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ç„¡åŠ¹æ™‚æ–‡å­—:</label>
                                    <input type="color" id="color_btn_disabled_text" onchange="updateColorVar('--btn-disabled-text', this.value)">
                                    <input type="text" id="text_btn_disabled_text" value="#999999" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--btn-disabled-text', this.value)">
                                </div>
                            </div>
                        </div>
                        
                        <!-- 4. ã‚¿ãƒ–ï¼ˆ3é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">ã‚¿ãƒ–ï¼ˆ3é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">éã‚¢ã‚¯ãƒ†ã‚£ãƒ–èƒŒæ™¯:</label>
                                    <input type="text" id="text_tab_bg_inactive" value="transparent" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--tab-bg-inactive', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–èƒŒæ™¯:</label>
                                    <input type="text" id="text_tab_bg_active" value="rgba(255, 255, 255, 0.2)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--tab-bg-active', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¿ãƒ–æ–‡å­—:</label>
                                    <input type="text" id="text_tab_text" value="rgba(255, 255, 255, 0.8)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--tab-text', this.value)">
                                </div>
                            </div>
                            
                            <h4 style="margin: 20px 0 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">ã‚«ãƒ¼ãƒ‰å­¦ç¿’ï¼ˆ3é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚°ãƒ©ãƒ‡é–‹å§‹:</label>
                                    <input type="color" id="color_card_study_bg_start" onchange="updateColorVar('--card-study-bg-start', this.value)">
                                    <input type="text" id="text_card_study_bg_start" value="#f093fb" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--card-study-bg-start', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚°ãƒ©ãƒ‡çµ‚äº†:</label>
                                    <input type="color" id="color_card_study_bg_end" onchange="updateColorVar('--card-study-bg-end', this.value)">
                                    <input type="text" id="text_card_study_bg_end" value="#f5576c" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--card-study-bg-end', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">çµ±è¨ˆãƒ‘ãƒãƒ«èƒŒæ™¯:</label>
                                    <input type="color" id="color_card_study_stat_bg" onchange="updateColorVar('--card-study-stat-bg', this.value)">
                                    <input type="text" id="text_card_study_stat_bg" value="#f8f9fa" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--card-study-stat-bg', this.value)">
                                </div>
                            </div>
                        </div>
                        
                        <!-- 5. çŠ¶æ…‹è¡¨ç¤ºï¼ˆ4é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">çŠ¶æ…‹è¡¨ç¤ºï¼ˆ4é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">æˆåŠŸè‰²ï¼ˆç·‘ï¼‰:</label>
                                    <input type="color" id="color_success" onchange="updateColorVar('--color-success', this.value)">
                                    <input type="text" id="text_color_success" value="#27ae60" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--color-success', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¨ãƒ©ãƒ¼è‰²ï¼ˆèµ¤ï¼‰:</label>
                                    <input type="color" id="color_error" onchange="updateColorVar('--color-error', this.value)">
                                    <input type="text" id="text_color_error" value="#e74c3c" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--color-error', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">è­¦å‘Šè‰²ï¼ˆé»„ï¼‰:</label>
                                    <input type="color" id="color_warning" onchange="updateColorVar('--color-warning', this.value)">
                                    <input type="text" id="text_color_warning" value="#f39c12" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--color-warning', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">æƒ…å ±è‰²ï¼ˆé’ï¼‰:</label>
                                    <input type="color" id="color_info" onchange="updateColorVar('--color-info', this.value)">
                                    <input type="text" id="text_color_info" value="#3498db" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--color-info', this.value)">
                                </div>
                            </div>
                            
                            <h4 style="margin: 20px 0 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">ãã®ä»–UIï¼ˆ5é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚·ãƒ£ãƒ‰ã‚¦:</label>
                                    <input type="text" id="text_shadow_color" value="rgba(0, 0, 0, 0.1)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--shadow-color', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ãƒ›ãƒãƒ¼èƒŒæ™¯:</label>
                                    <input type="color" id="color_hover_bg" onchange="updateColorVar('--hover-bg', this.value)">
                                    <input type="text" id="text_hover_bg" value="#f8f9fa" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--hover-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">é¸æŠèƒŒæ™¯:</label>
                                    <input type="color" id="color_selected_bg" onchange="updateColorVar('--selected-bg', this.value)">
                                    <input type="text" id="text_selected_bg" value="#e3f2fd" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--selected-bg', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼:</label>
                                    <input type="color" id="color_scrollbar_color" onchange="updateColorVar('--scrollbar-color', this.value)">
                                    <input type="text" id="text_scrollbar_color" value="#cccccc" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--scrollbar-color', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ã‚¢ã‚¤ã‚³ãƒ³:</label>
                                    <input type="color" id="color_icon_color" onchange="updateColorVar('--icon-color', this.value)">
                                    <input type="text" id="text_icon_color" value="#666666" style="width: 100px; font-size: 12px;" onchange="updateColorFromText('--icon-color', this.value)">
                                </div>
                            </div>
                        </div>
                        
                        <!-- 6. PDFãƒãƒ¼ã‚«ãƒ¼ï¼ˆ4é …ç›®ï¼‰ -->
                        <div>
                            <h4 style="margin-bottom: 15px; color: var(--text-main); border-bottom: 2px solid var(--border-color); padding-bottom: 5px;">PDFãƒãƒ¼ã‚«ãƒ¼ï¼ˆ4é …ç›®ï¼‰</h4>
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">é»„è‰²:</label>
                                    <input type="text" id="text_marker_yellow" value="rgba(255, 255, 0, 0.4)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--marker-yellow', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">èµ¤è‰²:</label>
                                    <input type="text" id="text_marker_red" value="rgba(255, 0, 0, 0.3)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--marker-red', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">ç·‘è‰²:</label>
                                    <input type="text" id="text_marker_green" value="rgba(0, 255, 0, 0.3)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--marker-green', this.value)">
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <label style="min-width: 140px; font-size: 13px;">é’è‰²:</label>
                                    <input type="text" id="text_marker_blue" value="rgba(0, 150, 255, 0.3)" style="width: 200px; font-size: 12px;" onchange="updateColorFromText('--marker-blue', this.value)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 30px;">
                        <button class="btn" onclick="saveCustomColors()">ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ä¿å­˜</button>
                        <button class="btn btn-secondary" onclick="resetCustomColors()">ãƒªã‚»ãƒƒãƒˆ</button>
                    </div>
                </div>
                
                <!-- v14.00: ãƒ‡ãƒ¼ã‚¿ç®¡ç† -->
                <hr style="margin: 50px 0; border: none; border-top: 2px solid #e0e0e0;">
                
                <h2 style="margin-bottom: 30px;">ãƒ‡ãƒ¼ã‚¿ç®¡ç†</h2>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                    
                    <!-- v14.00.1: ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ–¹å¼é¸æŠ -->
                    <div style="margin-bottom: 20px; display: flex; flex-direction: column; align-items: flex-start;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 10px; white-space: nowrap;">
                            <input type="radio" name="exportType" value="complete" id="exportTypeComplete" checked onchange="toggleExportOptions()">
                            <span><strong>å®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆæ¨å¥¨ï¼‰</strong> - ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="radio" name="exportType" value="custom" id="exportTypeCustom" onchange="toggleExportOptions()">
                            <span><strong>ã‚«ã‚¹ã‚¿ãƒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</strong> - é …ç›®ã‚’é¸æŠã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</span>
                        </label>
                    </div>
                    
                    <!-- v14.00.1: ã‚«ã‚¹ã‚¿ãƒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé¸æŠé …ç›® -->
                    <div id="customExportOptions" style="display: none; margin-top: 20px; padding: 20px; background: white; border-radius: 8px; border: 1px solid #ddd;">
                        <div style="display: grid; grid-template-columns: auto auto; gap: 20px;">
                            <!-- ãƒ‡ãƒ¼ã‚¿é …ç›® -->
                            <div>
                                <h4 style="margin-bottom: 15px; color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 5px;">ãƒ‡ãƒ¼ã‚¿ï¼ˆ5é …ç›®ï¼‰</h4>
                                <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-start;">
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_decks" checked onchange="checkDependencies()">
                                        <span>ãƒ‡ãƒƒã‚­æ§‹é€ </span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_flashcards" checked onchange="checkDependencies()">
                                        <span>ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_studySessions" checked onchange="checkDependencies()">
                                        <span>å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ²</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_pdfMarkers" checked onchange="checkDependencies()">
                                        <span>PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_pdfMetadata" checked onchange="checkDependencies()">
                                        <span>PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å¯¾å¿œè¡¨</span>
                                    </label>
                                </div>
                            </div>
                            
                            <!-- è¨­å®šé …ç›® -->
                            <div>
                                <h4 style="margin-bottom: 15px; color: #667eea; border-bottom: 2px solid #667eea; padding-bottom: 5px;">è¨­å®šï¼ˆ5é …ç›®ï¼‰</h4>
                                <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-start;">
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_theme" checked onchange="checkDependencies()">
                                        <span>ãƒ†ãƒ¼ãƒè¨­å®š</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_fontSize" checked onchange="checkDependencies()">
                                        <span>ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_globalStudySettings" checked onchange="checkDependencies()">
                                        <span>ã‚°ãƒ­ãƒ¼ãƒãƒ«å­¦ç¿’è¨­å®š</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_deckStudySettings" checked onchange="checkDependencies()">
                                        <span>ãƒ‡ãƒƒã‚­åˆ¥å­¦ç¿’è¨­å®š</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                        <input type="checkbox" id="export_uiSettings" checked onchange="checkDependencies()">
                                        <span>UIçŠ¶æ…‹è¨­å®š</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ä¾å­˜é–¢ä¿‚è­¦å‘Šè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                        <div id="dependencyWarning" style="display: none; margin-top: 15px; padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                            <strong>âš ï¸ ä¾å­˜é–¢ä¿‚ã®è­¦å‘Š:</strong>
                            <ul id="dependencyWarningList" style="margin: 8px 0 0 20px; color: #856404;"></ul>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 15px;">
                        <button class="btn" onclick="executeExport()">ğŸ“¦ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ</button>
                        <span id="exportStatus" style="color: #27ae60; display: none;">âœ“ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†</span>
                    </div>
                </div>
                
                <div style="background: #d4edda; padding: 20px; border-radius: 8px; border-left: 4px solid #28a745;">
                    <p style="margin: 0; color: #155724;">
                        <strong>âœ“ ãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼†å¾©å…ƒ:</strong> ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã¯å®‰å…¨ãªå ´æ‰€ã«ä¿ç®¡ã—ã¦ãã ã•ã„ã€‚<br>
                        ä¸‹éƒ¨ã®ã€Œãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å¾©å…ƒã§ãã¾ã™ã€‚
                    </p>
                </div>
                
                <!-- v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š -->
                <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px; margin-top: 30px; border-left: 4px solid #2196f3;">
                    <h3 style="margin-bottom: 15px; color: #1565c0;">â° è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š</h3>
                    
                    <!-- è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ON/OFF -->
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-weight: bold;">
                            <input type="checkbox" id="autoBackupEnabled" onchange="toggleAutoBackup()" style="width: 20px; height: 20px; cursor: pointer;">
                            <span>è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æœ‰åŠ¹ã«ã™ã‚‹</span>
                        </label>
                    </div>
                    
                    <div id="autoBackupSettings" style="display: none;">
                        <!-- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é »åº¦è¨­å®š -->
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="margin-bottom: 10px; color: #1565c0;">ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—é »åº¦</h4>
                            <select id="backupFrequency" onchange="updateBackupSchedule()" style="width: 100%; padding: 10px; border: 1px solid #2196f3; border-radius: 5px;">
                                <option value="1">æ¯æ—¥</option>
                                <option value="3">3æ—¥ã”ã¨</option>
                                <option value="7">é€±1å›</option>
                                <option value="30">æœˆ1å›</option>
                                <option value="custom">ã‚«ã‚¹ã‚¿ãƒ ï¼ˆæ—¥æ•°æŒ‡å®šï¼‰</option>
                            </select>
                            
                            <div id="customFrequencyInput" style="display: none; margin-top: 10px;">
                                <label style="font-size: 14px; color: #666; display: block; margin-bottom: 5px;">æ—¥æ•°ã‚’æŒ‡å®šï¼ˆ1-365ï¼‰</label>
                                <input type="number" id="customFrequencyDays" min="1" max="365" value="1" onchange="updateBackupSchedule()" style="width: 100%; padding: 10px; border: 1px solid #2196f3; border-radius: 5px;">
                            </div>
                        </div>
                        
                        <!-- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜è¨­å®š -->
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="margin-bottom: 10px; color: #1565c0;">ä¿å­˜è¨­å®š</h4>
                            <div style="margin-bottom: 15px;">
                                <label style="font-size: 14px; color: #666; display: block; margin-bottom: 8px;">ä¿å­˜ã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°</label>
                                <select id="maxBackups" onchange="saveAutoBackupSettings()" style="width: 100%; padding: 10px; border: 1px solid #2196f3; border-radius: 5px;">
                                    <option value="3">æœ€æ–°3å€‹</option>
                                    <option value="5" selected>æœ€æ–°5å€‹ï¼ˆæ¨å¥¨ï¼‰</option>
                                    <option value="10">æœ€æ–°10å€‹</option>
                                    <option value="20">æœ€æ–°20å€‹</option>
                                    <option value="unlimited">ç„¡åˆ¶é™</option>
                                </select>
                            </div>
                            <div style="font-size: 12px; color: #666; background: #f8f9fa; padding: 10px; border-radius: 5px;">
                                ğŸ’¡ ãƒ’ãƒ³ãƒˆ: å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯è‡ªå‹•çš„ã«å‰Šé™¤ã•ã‚Œã¾ã™ï¼ˆç„¡åˆ¶é™ã‚’é™¤ãï¼‰
                            </div>
                        </div>
                        
                        <!-- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹è¡¨ç¤º -->
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="margin-bottom: 10px; color: #1565c0;">ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">æœ€çµ‚ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—</div>
                                    <div style="font-size: 16px; font-weight: bold; color: #333;" id="lastBackupTime">æœªå®Ÿè¡Œ</div>
                                </div>
                                <div>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">æ¬¡å›äºˆå®š</div>
                                    <div style="font-size: 16px; font-weight: bold; color: #333;" id="nextBackupTime">-</div>
                                </div>
                            </div>
                            <div style="margin-top: 15px;">
                                <div style="font-size: 13px; color: #666; margin-bottom: 5px;">ä¿å­˜æ¸ˆã¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°</div>
                                <div style="font-size: 16px; font-weight: bold; color: #2196f3;" id="savedBackupsCount">0å€‹</div>
                            </div>
                        </div>
                        
                        <!-- æ‰‹å‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒœã‚¿ãƒ³ -->
                        <button class="btn" onclick="createManualBackup()" style="width: 100%; background: #2196f3; border-color: #2196f3;">
                            ğŸ’¾ ä»Šã™ããƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
                        </button>
                    </div>
                </div>
                
                <!-- v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç† -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">ğŸ“‹ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <button class="btn btn-secondary" onclick="loadBackupList()" style="width: 100%;">
                            ğŸ”„ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã‚’èª­ã¿è¾¼ã‚€
                        </button>
                    </div>
                    
                    <div id="backupListContainer" style="display: none;">
                        <div style="background: white; padding: 15px; border-radius: 8px; max-height: 400px; overflow-y: auto;" id="backupList">
                            <!-- JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
                        </div>
                        
                        <div style="margin-top: 15px; display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="downloadSelectedBackups()" style="flex: 1;">
                                ğŸ“¥ é¸æŠã—ãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                            </button>
                            <button class="btn btn-danger" onclick="deleteSelectedBackups()" style="flex: 1;">
                                ğŸ—‘ï¸ é¸æŠã—ãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- v14.01: ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; margin-top: 30px;">
                    <h3 style="margin-bottom: 15px;">ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
                    
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label class="btn" style="cursor: pointer; display: inline-block; width: auto;">
                                ğŸ“¥ CSVã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                                <input type="file" id="csvImportInput" accept=".csv" style="display: none;" onchange="importCardsFromCsv(event)">
                            </label>
                            <div style="color: #666; font-size: 13px; margin-top: 8px; margin-left: 5px;">
                                <strong>åŸºæœ¬ã‚«ãƒ¼ãƒ‰:</strong> å•é¡Œ,ç­”ãˆ,ãƒ‡ãƒƒã‚­å,ã‚¿ã‚°<br>
                                <strong>ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰:</strong> {{c1::ç­”ãˆ}}å½¢å¼ã®ãƒ†ã‚­ã‚¹ãƒˆ,ãƒ‡ãƒƒã‚­å,ã‚¿ã‚°<br>
                                <strong>â€»</strong> æ”¹è¡Œå¯¾å¿œã€‚ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã¯åŸºæœ¬ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¾ã™
                            </div>
                        </div>
                        
                        <div>
                            <label class="btn" style="cursor: pointer; display: inline-block; width: auto;">
                                ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ (JSON)
                                <input type="file" id="jsonImportInput" accept=".json" style="display: none;" onchange="importFromBackup(event)">
                            </label>
                            <div style="color: #666; font-size: 13px; margin-top: 8px; margin-left: 5px;">
                                v14.00ã§ä½œæˆã—ãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾©å…ƒã—ã¾ã™
                            </div>
                        </div>
                        
                        <!-- v16.03.00: é¸æŠçš„å¾©å…ƒãƒœã‚¿ãƒ³ -->
                        <div style="margin-top: 20px;">
                            <label class="btn" style="cursor: pointer; display: inline-block; width: auto; background: #3498db; border-color: #3498db;">
                                ğŸ” é¸æŠçš„å¾©å…ƒ (JSON)
                                <input type="file" id="selectiveRestoreInput" accept=".json" style="display: none;" onchange="loadSelectiveRestoreFile(event)">
                            </label>
                            <div style="color: #666; font-size: 13px; margin-top: 8px; margin-left: 5px;">
                                ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã™ã‚‹é …ç›®ã‚’é¸æŠã§ãã¾ã™
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; text-align: left;">
                        <label style="display: inline-flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="skipDuplicates" checked>
                            <span>é‡è¤‡ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå•é¡Œã¨ç­”ãˆãŒå®Œå…¨ä¸€è‡´ï¼‰</span>
                        </label>
                    </div>
                    
                    <div style="margin-top: 15px; text-align: left;">
                        <label style="display: inline-flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="specifyDeckForImport">
                            <span>ãƒ‡ãƒƒã‚­ã‚’æŒ‡å®šã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆCSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ç„¡è¦–ï¼‰</span>
                        </label>
                        <div style="color: #666; font-size: 13px; margin-top: 5px; margin-left: 28px;">
                            â€»ãƒã‚§ãƒƒã‚¯ã—ãªã„å ´åˆã€CSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ä½¿ç”¨ï¼ˆç©ºã®å ´åˆã¯ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ‡ãƒƒã‚­ã«è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘ï¼‰
                        </div>
                    </div>
                </div>
                
                <!-- v14.02.5: ãƒ‡ãƒ¼ã‚¿å®Œå…¨å‰Šé™¤ -->
                <hr style="margin: 50px 0; border: none; border-top: 2px solid #e0e0e0;">
                
                <h2 style="margin-bottom: 30px; color: #e74c3c;">âš ï¸ ãƒ‡ãƒ¼ã‚¿å®Œå…¨å‰Šé™¤</h2>
                
                <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #f39c12;">
                    <p style="margin: 0; color: #856404; font-weight: bold;">
                        âš ï¸ è­¦å‘Šï¼šã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ï¼<br>
                        å¿…ãšäº‹å‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
                    </p>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 10px; border: 2px solid #e74c3c;">
                    <h3 style="margin-bottom: 15px; color: #e74c3c;">å‰Šé™¤å¯¾è±¡ã‚’é¸æŠ</h3>
                    
                    <div style="display: grid; gap: 15px; margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; border: 2px solid transparent;" onmouseover="this.style.borderColor='#e74c3c'" onmouseout="this.style.borderColor='transparent'">
                            <input type="checkbox" id="deleteCards" onchange="updateDeletePreview()" style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold;">ğŸ“‡ ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰</div>
                                <div style="font-size: 13px; color: #666;" id="deleteCardsCount">-</div>
                            </div>
                        </label>
                        
                        <label style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; border: 2px solid transparent;" onmouseover="this.style.borderColor='#e74c3c'" onmouseout="this.style.borderColor='transparent'">
                            <input type="checkbox" id="deleteDecks" onchange="updateDeletePreview()" style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold;">ğŸ“š ã™ã¹ã¦ã®ãƒ‡ãƒƒã‚­</div>
                                <div style="font-size: 13px; color: #666;" id="deleteDecksCount">-</div>
                            </div>
                        </label>
                        
                        <label style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; border: 2px solid transparent;" onmouseover="this.style.borderColor='#e74c3c'" onmouseout="this.style.borderColor='transparent'">
                            <input type="checkbox" id="deleteSessions" onchange="updateDeletePreview()" style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold;">ğŸ“Š ã™ã¹ã¦ã®å­¦ç¿’è¨˜éŒ²</div>
                                <div style="font-size: 13px; color: #666;" id="deleteSessionsCount">-</div>
                            </div>
                        </label>
                        
                        <label style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; border: 2px solid transparent;" onmouseover="this.style.borderColor='#e74c3c'" onmouseout="this.style.borderColor='transparent'">
                            <input type="checkbox" id="deleteMarkers" onchange="updateDeletePreview()" style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold;">ğŸ“„ PDFãƒãƒ¼ã‚«ãƒ¼</div>
                                <div style="font-size: 13px; color: #666;" id="deleteMarkersCount">-</div>
                            </div>
                        </label>
                        
                        <label style="display: flex; align-items: center; gap: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer; border: 2px solid transparent;" onmouseover="this.style.borderColor='#e74c3c'" onmouseout="this.style.borderColor='transparent'">
                            <input type="checkbox" id="deleteSettings" onchange="updateDeletePreview()" style="width: 20px; height: 20px; cursor: pointer;">
                            <div>
                                <div style="font-weight: bold;">âš™ï¸ è¨­å®šãƒ‡ãƒ¼ã‚¿</div>
                                <div style="font-size: 13px; color: #666;">ãƒ†ãƒ¼ãƒã€å­¦ç¿’è¨­å®šãªã©</div>
                            </div>
                        </label>
                    </div>
                    
                    <div style="background: #ffebee; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div style="font-weight: bold; color: #c62828; margin-bottom: 8px;">å‰Šé™¤ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</div>
                        <div id="deletePreviewText" style="color: #666;">é¸æŠã™ã‚‹ã¨å‰Šé™¤å¯¾è±¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
                    </div>
                    
                    <button class="btn btn-danger" onclick="executeCompleteDataDeletion()" style="width: 100%; font-size: 16px; padding: 15px;">
                        ğŸ—‘ï¸ é¸æŠã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨å‰Šé™¤
                    </button>
                </div>
            </div>
        </div>
        
        <div id="pdf-section" class="section">
            <div class="pdf-viewer">
                <!-- v7.02: PDFå­¦ç¿’ãƒ˜ãƒƒãƒ€ãƒ¼ã¨çµ±è¨ˆãƒ‘ãƒãƒ« -->
                <div class="pdf-header">
                    <h2>ğŸ“– PDFå­¦ç¿’</h2>
                    <button class="btn btn-mode-off" onclick="toggleStudyMode()" id="studyModeBtn" style="display: none;">å­¦ç¿’OFF</button>
                    <!-- v15.01.10: å…¨ç”»é¢è¡¨ç¤ºãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼ˆãƒ©ãƒ™ãƒ«çŸ­ç¸®ï¼‰ -->
                    <label style="margin-left: 15px; display: inline-block; cursor: pointer; user-select: none; background: rgba(0, 0, 0, 0.7); padding: 8px 14px; border-radius: 4px; visibility: hidden;" id="fullscreenLabel">
                        <input type="checkbox" id="fullscreenCheckbox" onchange="saveFullscreenSetting()" style="cursor: pointer; margin-right: 8px; vertical-align: middle; width: 16px; height: 16px;">
                        <span style="color: white; font-size: 14px; font-weight: 500; vertical-align: middle; white-space: nowrap;">å…¨ç”»é¢è¡¨ç¤º</span>
                    </label>
                    <!-- v7.02: å­¦ç¿’çµ±è¨ˆãƒ‘ãƒãƒ«ï¼ˆ2è¡Œæ§‹æˆï¼‰ -->
                    <div class="study-stats inactive" id="studyStats" style="display: none;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 8px;">
                            <span class="stat-item">â±ï¸ ä»Šå›: <span id="studyTime">00:00:00</span></span>
                            <span class="stat-separator">|</span>
                            <span class="stat-item">ç·: <span id="totalStudyTime">00:00:00</span></span>
                            <span class="stat-separator">|</span>
                            <span class="stat-item">å‘¨å›: <span id="lapCount">1</span>å›ç›®</span>
                            <button class="btn btn-secondary" onclick="resetLapFull()" id="resetLapFullBtn" style="padding: 4px 12px; font-size: 13px;">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
                            <button class="btn btn-secondary" onclick="resetLapReview()" id="resetLapReviewBtn" style="padding: 4px 12px; font-size: 13px;">å¾©ç¿’ãƒªã‚»ãƒƒãƒˆ</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span class="stat-item">âœ… <span id="correctCount">0</span></span>
                            <span class="stat-item">âŒ <span id="incorrectCount">0</span></span>
                            <span class="stat-item">ğŸ”² <span id="unstudiedCount">0</span></span>
                            <span class="stat-item">ğŸ“Š <span id="accuracyRate">N/A</span></span>
                            <span class="stat-item" style="color: #0066ff; font-weight: bold;">âš ï¸ è‹¦æ‰‹: <span id="weakMarkerCount">0</span></span>
                        </div>
                    </div>
                </div>
                
                <div id="pdfUploadArea" class="pdf-upload-area" onclick="handlePDFUploadClick()">
                    <div class="pdf-upload-icon">ğŸ“„</div>
                    <h3>PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</h3>
                    <p style="margin-top: 10px; color: #666;">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã€ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</p>
                    <input type="file" id="pdfFileInput" accept="application/pdf" onchange="loadPDF(event)" style="display: none;">
                </div>
                
                <div id="pdfViewerContainer" style="display: none;">
                    <div class="pdf-filename" id="pdfFilename"></div>
                    
                    <div class="pdf-controls-row">
                        <span class="row-label">ãƒãƒ¼ã‚«ãƒ¼ï¼š</span>
                        <button class="color-btn yellow active" id="markerYellow" onclick="selectMarkerColor('yellow')">é»„</button>
                        <button class="color-btn red" id="markerRed" onclick="selectMarkerColor('red')">èµ¤</button>
                        <button class="color-btn green" id="markerGreen" onclick="selectMarkerColor('green')">ç·‘</button>
                        <button class="color-btn blue" id="markerBlue" onclick="selectMarkerColor('blue')">é’</button>
                        <button class="btn btn-mode-off" onclick="toggleMarkerMode()" id="markerModeBtn">ãƒãƒ¼ã‚«ãƒ¼OFF</button>
                        <label style="display: inline-flex; align-items: center; gap: 4px; margin-left: 8px; white-space: nowrap;">
                            <input type="checkbox" id="fixHeightCheckbox" onchange="toggleFixHeightMode()" style="width: 16px; height: 16px; cursor: pointer;">
                            <span style="font-size: 14px;">é«˜ã•å›ºå®š</span>
                        </label>
                        <button class="btn btn-danger" id="clearPageMarkersBtn" onclick="clearPageMarkers()" style="font-size: 12px; padding: 8px 12px;">ãƒšãƒ¼ã‚¸å†…å…¨å‰Šé™¤</button>
                        <button class="btn btn-danger" id="clearAllMarkersBtn" onclick="clearAllMarkers()" style="font-size: 12px; padding: 8px 12px;">PDFå†…å…¨å‰Šé™¤</button>
                        ï½œ <button class="btn" onclick="openMarkerSearch()" style="font-size: 12px; padding: 8px 12px; background: #3498db; color: white;">ğŸ” ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢</button>
                    </div>

                    <div class="pdf-controls-row">
                        <span class="row-label">æ“ä½œï¼š</span>
                        <button class="btn btn-mode-off" onclick="toggleEditMode()" id="editModeBtn">ğŸ“ ä¿®æ­£OFF</button>
                        <button class="btn btn-mode-off" onclick="toggleDeleteMode()" id="deleteModeBtn">ğŸ—‘ï¸ å‰Šé™¤OFF</button>
                        <label class="instant-delete-label">
                            <input type="checkbox" id="instantDeleteCheckbox" onchange="saveInstantDeleteSetting()">
                            <span>å³å‰Šé™¤</span>
                        </label>
                    </div>

                    <div class="pdf-controls-row">
                        <span class="row-label">ã‚·ãƒ¼ãƒˆï¼š</span>
                        <button class="sheet-btn yellow" id="redsheetYellow" onclick="toggleRedSheetColor('yellow')">é»„</button>
                        <button class="sheet-btn red" id="redsheetRed" onclick="toggleRedSheetColor('red')">èµ¤</button>
                        <button class="sheet-btn green" id="redsheetGreen" onclick="toggleRedSheetColor('green')">ç·‘</button>
                        <button class="sheet-btn blue" id="redsheetBlue" onclick="toggleRedSheetColor('blue')">é’</button>
                        <button class="sheet-btn all" id="redsheetAll" onclick="toggleRedSheetColor('all')">å…¨ã¦</button>
                    </div>
                    
                    <div class="pdf-canvas-container">
                        <div class="canvas-wrapper" id="canvasWrapper">
                            <canvas id="pdfCanvas"></canvas>
                            <div id="textLayer" class="textLayer"></div>
                            <canvas id="markerCanvas"></canvas>
                            <canvas id="previewCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10; display: none;"></canvas>
                        </div>
                        <!-- v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰è­¦å‘Š -->
                        <div id="previewModeWarning" style="display: none; position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(231, 76, 60, 0.95); color: white; padding: 12px 20px; border-radius: 8px; font-weight: bold; z-index: 1000; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
                            âš ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼šç‚¹ç·šã¯æ—§PDFã®ãƒãƒ¼ã‚«ãƒ¼ä½ç½®ã§ã™
                            <button onclick="exitPreviewMode()" style="margin-left: 15px; background: white; color: #e74c3c; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-weight: bold;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼çµ‚äº†</button>
                        </div>
                    </div>
                    
                    <div class="pdf-controls">
                        <button class="btn" onclick="previousPage()">â† å‰ã®ãƒšãƒ¼ã‚¸</button>
                        <span class="pdf-info" id="pageInfo" onclick="showPageJumpInput()" style="cursor: pointer; user-select: none;">1 / 1</span>
                        <button class="btn" onclick="nextPage()">æ¬¡ã®ãƒšãƒ¼ã‚¸ â†’</button>
                        
                        <div class="zoom-controls">
                            <button class="btn btn-secondary" onclick="zoomOut()">ç¸®å° -</button>
                            <span class="pdf-info" id="zoomInfo">100%</span>
                            <button class="btn btn-secondary" onclick="zoomIn()">æ‹¡å¤§ +</button>
                        </div>
                        
                        <button class="btn btn-danger" onclick="closePDF()">PDFã‚’é–‰ã˜ã‚‹</button>
                    </div>
                </div>
                
                <!-- v15.01.0: å…¨ç”»é¢è¡¨ç¤ºç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ -->
                <!-- v15.01.2: å…¨ç”»é¢è¡¨ç¤ºç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆz-index: 2001ï¼‰ -->
                <div id="fullscreenControls" style="display: none; position: fixed; top: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.85); color: white; padding: 10px 20px; z-index: 2001; box-shadow: 0 2px 10px rgba(0,0,0,0.5);">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: nowrap;">
                        <button class="btn" onclick="toggleStudyMode()" id="fullscreenStudyModeBtn" style="background: #e74c3c; color: white; padding: 8px 16px;">å­¦ç¿’OFF</button>
                        <span style="color: #888;">|</span>
                        <button class="sheet-btn yellow" id="fullscreenSheetYellow" onclick="toggleRedSheetColor('yellow')" style="padding: 8px 16px;">é»„</button>
                        <button class="sheet-btn red" id="fullscreenSheetRed" onclick="toggleRedSheetColor('red')" style="padding: 8px 16px;">èµ¤</button>
                        <button class="sheet-btn green" id="fullscreenSheetGreen" onclick="toggleRedSheetColor('green')" style="padding: 8px 16px;">ç·‘</button>
                        <button class="sheet-btn blue" id="fullscreenSheetBlue" onclick="toggleRedSheetColor('blue')" style="padding: 8px 16px;">é’</button>
                        <span style="color: #888;">|</span>
                        <button class="btn btn-secondary" onclick="previousPage()" style="padding: 8px 16px;">â—€</button>
                        <span style="font-size: 14px; min-width: 80px; text-align: center; cursor: pointer; user-select: none;" id="fullscreenPageInfo" onclick="showPageJumpInput()">1 / 1</span>
                        <button class="btn btn-secondary" onclick="nextPage()" style="padding: 8px 16px;">â–¶</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div> <!-- v15.01.15: mainAppçµ‚äº† -->

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // v15.01.16: FirebaseåˆæœŸåŒ–ï¼ˆæœ€åˆã«å®Ÿè¡Œï¼‰
        const firebaseConfig = {
            apiKey: "AIzaSyDMbvMO-_zSxPaOdrO_uJRAKdnfTHL-sNQ",
            authDomain: "myanki-app.firebaseapp.com",
            projectId: "myanki-app",
            storageBucket: "myanki-app.firebasestorage.app",
            messagingSenderId: "363048144804",
            appId: "1:363048144804:web:090e5c406d55bc5261fb31"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        
        // v15.01.16: Firebase Authenticationå‡¦ç†
        let currentUser = null;
        
        // ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®ç›£è¦–
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'block';
            } else {
                currentUser = null;
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('mainApp').style.display = 'none';
            }
        });
        
        // ãƒ¡ãƒ¼ãƒ«/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³
        function loginWithEmail() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');
            
            if (!email || !password) {
                errorDiv.textContent = 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                errorDiv.style.display = 'block';
                return;
            }
            
            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    errorDiv.style.display = 'none';
                })
                .catch((error) => {
                    console.error('ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
                    if (error.code === 'auth/wrong-password' || error.code === 'auth/user-not-found') {
                        errorDiv.textContent = 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã¾ã™';
                    } else if (error.code === 'auth/invalid-email') {
                        errorDiv.textContent = 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“';
                    } else {
                        errorDiv.textContent = 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message;
                    }
                    errorDiv.style.display = 'block';
                });
        }
        
        // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
        function logout() {
            if (confirm('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                auth.signOut().then(() => {
                    // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆæˆåŠŸ
                }).catch((error) => {
                    console.error('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                });
            }
        }
        
        // Enterã‚­ãƒ¼ã§ãƒ­ã‚°ã‚¤ãƒ³
        document.addEventListener('DOMContentLoaded', () => {
            const loginPassword = document.getElementById('loginPassword');
            if (loginPassword) {
                loginPassword.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        loginWithEmail();
                    }
                });
            }
        });
        
        // v12.03: ãƒ†ãƒ¼ãƒã¨ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºç®¡ç†
        let currentTheme = localStorage.getItem('theme') || 'light';
        let currentFontSize = localStorage.getItem('fontSize') || 'medium';
        
        
        // v12.03: ãƒ†ãƒ¼ãƒé©ç”¨
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            currentTheme = theme;
            localStorage.setItem('theme', theme);
            
            // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚’æ›´æ–°
            const lightRadio = document.getElementById('themeLight');
            const darkRadio = document.getElementById('themeDark');
            if (lightRadio && darkRadio) {
                lightRadio.checked = (theme === 'light');
                darkRadio.checked = (theme === 'dark');
            }
        }
        
        // v12.03.3: ãƒ†ãƒ¼ãƒå¤‰æ›´ï¼ˆãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã¨ã‚«ã‚¹ã‚¿ãƒ ã®ã¿ï¼‰
        function changeTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('theme', theme);
            
            // ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼è¨­å®šã®è¡¨ç¤º/éè¡¨ç¤º
            const customColorSettings = document.getElementById('customColorSettings');
            if (customColorSettings) {
                customColorSettings.style.display = (theme === 'custom') ? 'block' : 'none';
            }
            
            // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚’æ›´æ–°
            const lightRadio = document.getElementById('themeLight');
            const customRadio = document.getElementById('themeCustom');
            if (lightRadio && customRadio) {
                lightRadio.checked = (theme === 'light');
                customRadio.checked = (theme === 'custom');
            }
            
            // ã‚«ã‚¹ã‚¿ãƒ ãƒ†ãƒ¼ãƒã®å ´åˆã€ä¿å­˜ã•ã‚Œã¦ã„ã‚‹è‰²ã‚’èª­ã¿è¾¼ã‚€
            if (theme === 'custom') {
                loadCustomColors();
            }
        }

        // v12.03.4: æ˜ã‚‹ã•ã«å¿œã˜ã¦ç™½ã‹é»’ã‚’è¿”ã™
        function getContrastColor(hexOrRgba) {
            let r, g, b;
            
            // #ffffffå½¢å¼
            if (hexOrRgba.startsWith('#')) {
                const hex = hexOrRgba.replace('#', '');
                r = parseInt(hex.substr(0, 2), 16);
                g = parseInt(hex.substr(2, 2), 16);
                b = parseInt(hex.substr(4, 2), 16);
            }
            // rgbaå½¢å¼
            else if (hexOrRgba.startsWith('rgba') || hexOrRgba.startsWith('rgb')) {
                const matches = hexOrRgba.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    r = parseInt(matches[0]);
                    g = parseInt(matches[1]);
                    b = parseInt(matches[2]);
                } else {
                    return '#000000'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                }
            }
            // transparent
            else if (hexOrRgba === 'transparent') {
                return '#000000';
            }
            else {
                return '#000000'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            }
            
            // æ˜ã‚‹ã•ã‚’è¨ˆç®—ï¼ˆ0-255ï¼‰
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            // æ˜ã‚‹ã•ãŒ128ä»¥ä¸Šãªã‚‰é»’ã€ãã‚Œä»¥ä¸‹ãªã‚‰ç™½
            return brightness > 128 ? '#000000' : '#ffffff';
        }

        // v12.03.2: CSSå¤‰æ•°ã‚’æ›´æ–°
        // v12.03.4: èƒŒæ™¯è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¿½åŠ 
        function updateColorVar(varName, value) {
            document.documentElement.style.setProperty(varName, value);
            
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚‚æ›´æ–°
            const textId = 'text_' + varName.replace('--', '').replace(/-/g, '_');
            const textInput = document.getElementById(textId);
            if (textInput) {
                textInput.value = value;
                // èƒŒæ™¯è‰²ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                textInput.style.backgroundColor = value;
                // æ–‡å­—è‰²ã‚’è‡ªå‹•èª¿æ•´
                textInput.style.color = getContrastColor(value);
            }
        }
        
        // v12.03.2: ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚«ãƒ©ãƒ¼ã‚’æ›´æ–°
        // v12.03.4: èƒŒæ™¯è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¿½åŠ 
        function updateColorFromText(varName, value) {
            document.documentElement.style.setProperty(varName, value);
            
            // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›æ¬„ã®èƒŒæ™¯è‰²ã‚’æ›´æ–°
            const textId = 'text_' + varName.replace('--', '').replace(/-/g, '_');
            const textInput = document.getElementById(textId);
            if (textInput) {
                textInput.style.backgroundColor = value;
                textInput.style.color = getContrastColor(value);
            }
            
            // ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼ã‚‚æ›´æ–°ï¼ˆ#å½¢å¼ã®å ´åˆã®ã¿ï¼‰
            if (value.startsWith('#')) {
                const colorId = 'color_' + varName.replace('--', '').replace(/-/g, '_');
                const colorInput = document.getElementById(colorId);
                if (colorInput) {
                    colorInput.value = value;
                }
            }
        }
        
        // v12.03.3: ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ä¿å­˜ï¼ˆ41é …ç›®ï¼‰
        function saveCustomColors() {
            const customColors = {};
            
            // ã™ã¹ã¦ã®CSSå¤‰æ•°ã‚’å–å¾—ï¼ˆ41é …ç›®ï¼‰
            const varNames = [
                '--bg-main', '--bg-section', '--bg-item', '--bg-modal',
                '--bg-header-start', '--bg-header-end', '--bg-input',
                '--text-main', '--text-sub', '--text-link', '--text-placeholder',
                '--border-color', '--divider-color',
                '--btn-primary-bg', '--btn-primary-text',
                '--btn-secondary-bg', '--btn-secondary-text',
                '--btn-danger-bg', '--btn-danger-text',
                '--btn-hover-bg', '--btn-disabled-bg', '--btn-disabled-text',
                '--tab-bg-inactive', '--tab-bg-active', '--tab-text',
                '--card-study-bg-start', '--card-study-bg-end', '--card-study-stat-bg',
                '--color-success', '--color-error', '--color-warning', '--color-info',
                '--shadow-color', '--hover-bg', '--selected-bg',
                '--scrollbar-color', '--icon-color',
                '--marker-yellow', '--marker-red', '--marker-green', '--marker-blue'
            ];
            
            varNames.forEach(varName => {
                const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
                if (value) {
                    customColors[varName] = value;
                }
            });
            
            localStorage.setItem('customColors', JSON.stringify(customColors));
            alert('ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        // v12.03.2: ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’èª­ã¿è¾¼ã¿
        // v12.03.4: èƒŒæ™¯è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¿½åŠ 
        function loadCustomColors() {
            const savedColors = localStorage.getItem('customColors');
            if (!savedColors) {
                // ä¿å­˜ãŒãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åˆæœŸåŒ–
                initializeDefaultColors();
                return;
            }
            
            try {
                const customColors = JSON.parse(savedColors);
                Object.keys(customColors).forEach(varName => {
                    document.documentElement.style.setProperty(varName, customColors[varName]);
                    
                    // UIã«ã‚‚åæ˜ 
                    const colorId = 'color_' + varName.replace('--', '').replace(/-/g, '_');
                    const textId = 'text_' + varName.replace('--', '').replace(/-/g, '_');
                    
                    const colorInput = document.getElementById(colorId);
                    const textInput = document.getElementById(textId);
                    
                    if (colorInput && customColors[varName].startsWith('#')) {
                        colorInput.value = customColors[varName];
                    }
                    if (textInput) {
                        textInput.value = customColors[varName];
                        // èƒŒæ™¯è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                        textInput.style.backgroundColor = customColors[varName];
                        textInput.style.color = getContrastColor(customColors[varName]);
                    }
                });
            } catch (error) {
                console.error('ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // v12.03.4: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè‰²ã§åˆæœŸåŒ–
        function initializeDefaultColors() {
            const defaultColors = {
                '--bg-main': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                '--bg-section': '#ffffff',
                '--bg-item': '#ffffff',
                '--bg-modal': '#ffffff',
                '--bg-header-start': '#667eea',
                '--bg-header-end': '#764ba2',
                '--bg-input': '#ffffff',
                '--text-main': '#333333',
                '--text-sub': '#666666',
                '--text-link': '#667eea',
                '--text-placeholder': '#999999',
                '--border-color': '#dddddd',
                '--divider-color': '#e0e0e0',
                '--btn-primary-bg': '#667eea',
                '--btn-primary-text': '#ffffff',
                '--btn-secondary-bg': '#95a5a6',
                '--btn-secondary-text': '#ffffff',
                '--btn-danger-bg': '#e74c3c',
                '--btn-danger-text': '#ffffff',
                '--btn-hover-bg': '#5568d3',
                '--btn-disabled-bg': '#cccccc',
                '--btn-disabled-text': '#999999',
                '--tab-bg-inactive': 'transparent',
                '--tab-bg-active': 'rgba(255, 255, 255, 0.2)',
                '--tab-text': 'rgba(255, 255, 255, 0.8)',
                '--card-study-bg-start': '#f093fb',
                '--card-study-bg-end': '#f5576c',
                '--card-study-stat-bg': '#f8f9fa',
                '--color-success': '#27ae60',
                '--color-error': '#e74c3c',
                '--color-warning': '#f39c12',
                '--color-info': '#3498db',
                '--shadow-color': 'rgba(0, 0, 0, 0.1)',
                '--hover-bg': '#f8f9fa',
                '--selected-bg': '#e3f2fd',
                '--scrollbar-color': '#cccccc',
                '--icon-color': '#666666',
                '--marker-yellow': 'rgba(255, 255, 0, 0.4)',
                '--marker-red': 'rgba(255, 0, 0, 0.3)',
                '--marker-green': 'rgba(0, 255, 0, 0.3)',
                '--marker-blue': 'rgba(0, 150, 255, 0.3)'
            };
            
            Object.keys(defaultColors).forEach(varName => {
                const textId = 'text_' + varName.replace('--', '').replace(/-/g, '_');
                const textInput = document.getElementById(textId);
                
                if (textInput) {
                    textInput.style.backgroundColor = defaultColors[varName];
                    textInput.style.color = getContrastColor(defaultColors[varName]);
                }
            });
        }
        
        // v12.03.2: ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        // v12.03.4: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æ˜ç¤ºçš„ã«é©ç”¨
        function resetCustomColors() {
            if (!confirm('ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) return;
            
            localStorage.removeItem('customColors');
            
            // ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            const defaultColors = {
                '--bg-main': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                '--bg-section': '#ffffff',
                '--bg-item': '#ffffff',
                '--bg-modal': '#ffffff',
                '--bg-header-start': '#667eea',
                '--bg-header-end': '#764ba2',
                '--bg-input': '#ffffff',
                '--text-main': '#333333',
                '--text-sub': '#666666',
                '--text-link': '#667eea',
                '--text-placeholder': '#999999',
                '--border-color': '#dddddd',
                '--divider-color': '#e0e0e0',
                '--btn-primary-bg': '#667eea',
                '--btn-primary-text': '#ffffff',
                '--btn-secondary-bg': '#95a5a6',
                '--btn-secondary-text': '#ffffff',
                '--btn-danger-bg': '#e74c3c',
                '--btn-danger-text': '#ffffff',
                '--btn-hover-bg': '#5568d3',
                '--btn-disabled-bg': '#cccccc',
                '--btn-disabled-text': '#999999',
                '--tab-bg-inactive': 'transparent',
                '--tab-bg-active': 'rgba(255, 255, 255, 0.2)',
                '--tab-text': 'rgba(255, 255, 255, 0.8)',
                '--card-study-bg-start': '#f093fb',
                '--card-study-bg-end': '#f5576c',
                '--card-study-stat-bg': '#f8f9fa',
                '--color-success': '#27ae60',
                '--color-error': '#e74c3c',
                '--color-warning': '#f39c12',
                '--color-info': '#3498db',
                '--shadow-color': 'rgba(0, 0, 0, 0.1)',
                '--hover-bg': '#f8f9fa',
                '--selected-bg': '#e3f2fd',
                '--scrollbar-color': '#cccccc',
                '--icon-color': '#666666',
                '--marker-yellow': 'rgba(255, 255, 0, 0.4)',
                '--marker-red': 'rgba(255, 0, 0, 0.3)',
                '--marker-green': 'rgba(0, 255, 0, 0.3)',
                '--marker-blue': 'rgba(0, 150, 255, 0.3)'
            };
            
            // CSSå¤‰æ•°ã‚’é©ç”¨
            Object.keys(defaultColors).forEach(varName => {
                document.documentElement.style.setProperty(varName, defaultColors[varName]);
                
                // UIã«ã‚‚åæ˜ 
                const colorId = 'color_' + varName.replace('--', '').replace(/-/g, '_');
                const textId = 'text_' + varName.replace('--', '').replace(/-/g, '_');
                
                const colorInput = document.getElementById(colorId);
                const textInput = document.getElementById(textId);
                
                if (colorInput && defaultColors[varName].startsWith('#')) {
                    colorInput.value = defaultColors[varName];
                }
                if (textInput) {
                    textInput.value = defaultColors[varName];
                    // èƒŒæ™¯è‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                    textInput.style.backgroundColor = defaultColors[varName];
                    textInput.style.color = getContrastColor(defaultColors[varName]);
                }
            });
            
            alert('ã‚«ã‚¹ã‚¿ãƒ ã‚«ãƒ©ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
        }

        // v14.00.1: ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ‡æ›¿
        function toggleExportOptions() {
            const exportTypeComplete = document.getElementById('exportTypeComplete');
            const customExportOptions = document.getElementById('customExportOptions');
            
            if (exportTypeComplete && exportTypeComplete.checked) {
                customExportOptions.style.display = 'none';
            } else {
                customExportOptions.style.display = 'block';
                checkDependencies();
            }
        }
        
        // v14.00.1: ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯
        function checkDependencies() {
            const decks = document.getElementById('export_decks').checked;
            const flashcards = document.getElementById('export_flashcards').checked;
            const studySessions = document.getElementById('export_studySessions').checked;
            const pdfMarkers = document.getElementById('export_pdfMarkers').checked;
            const pdfMetadata = document.getElementById('export_pdfMetadata').checked;
            const deckStudySettings = document.getElementById('export_deckStudySettings').checked;
            
            const warnings = [];
            
            // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã¯ãƒ‡ãƒƒã‚­æ§‹é€ ã«ä¾å­˜
            if (flashcards && !decks) {
                warnings.push('ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’é¸æŠã—ã¦ã„ã¾ã™ãŒã€ãƒ‡ãƒƒã‚­æ§‹é€ ã‚‚å«ã‚ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼ˆã‚«ãƒ¼ãƒ‰ã¯ãƒ‡ãƒƒã‚­ã«æ‰€å±ã—ã¾ã™ï¼‰');
            }
            
            // å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ²ã¯ãƒ‡ãƒƒã‚­æ§‹é€ ã«ä¾å­˜
            if (studySessions && !decks) {
                warnings.push('å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ²ã‚’é¸æŠã—ã¦ã„ã¾ã™ãŒã€ãƒ‡ãƒƒã‚­æ§‹é€ ã‚‚å«ã‚ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯ãƒ‡ãƒƒã‚­ã«ç´ä»˜ãã¾ã™ï¼‰');
            }
            
            // ãƒ‡ãƒƒã‚­åˆ¥å­¦ç¿’è¨­å®šã¯ãƒ‡ãƒƒã‚­æ§‹é€ ã«ä¾å­˜
            if (deckStudySettings && !decks) {
                warnings.push('ãƒ‡ãƒƒã‚­åˆ¥å­¦ç¿’è¨­å®šã‚’é¸æŠã—ã¦ã„ã¾ã™ãŒã€ãƒ‡ãƒƒã‚­æ§‹é€ ã‚‚å«ã‚ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼ˆè¨­å®šã¯ãƒ‡ãƒƒã‚­ã”ã¨ã«ä¿å­˜ã•ã‚Œã¾ã™ï¼‰');
            }
            
            // PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã¨é€£å‹•
            if (pdfMetadata && !pdfMarkers) {
                warnings.push('PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å¯¾å¿œè¡¨ã‚’é¸æŠã—ã¦ã„ã¾ã™ãŒã€PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚‚å«ã‚ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ãƒãƒ¼ã‚«ãƒ¼ã¯é€£å‹•ã—ã¾ã™ï¼‰');
            }
            
            const warningDiv = document.getElementById('dependencyWarning');
            const warningList = document.getElementById('dependencyWarningList');
            
            if (warnings.length > 0) {
                warningList.innerHTML = warnings.map(w => `<li>${w}</li>`).join('');
                warningDiv.style.display = 'block';
            } else {
                warningDiv.style.display = 'none';
            }
        }
        
        // v14.00.1: ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œï¼ˆå®Œå…¨ or ã‚«ã‚¹ã‚¿ãƒ ï¼‰
        async function executeExport() {
            const exportTypeComplete = document.getElementById('exportTypeComplete');
            
            if (exportTypeComplete && exportTypeComplete.checked) {
                // å®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
                await exportCompleteBackup();
            } else {
                // ã‚«ã‚¹ã‚¿ãƒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                await exportCustomBackup();
            }
        }
        
        // v14.00: å®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportCompleteBackup() {
            try {
                // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.textContent = 'â³ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...';
                    statusEl.style.color = '#f39c12';
                    statusEl.style.display = 'inline';
                }
                
                // 1. Firestoreã‹ã‚‰ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const decksSnapshot = await db.collection('decks').orderBy('order').get();
                const flashcardsSnapshot = await db.collection('flashcards').get();
                const studySessionsSnapshot = await db.collection('studySessions').get();
                const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’é…åˆ—ã«å¤‰æ›
                const decks = [];
                decksSnapshot.forEach(doc => {
                    decks.push({ id: doc.id, ...doc.data() });
                });
                
                const flashcards = [];
                flashcardsSnapshot.forEach(doc => {
                    flashcards.push({ id: doc.id, ...doc.data() });
                });
                
                const studySessions = [];
                studySessionsSnapshot.forEach(doc => {
                    studySessions.push({ id: doc.id, ...doc.data() });
                });
                
                const pdfMarkers = [];
                const pdfMetadata = [];
                pdfMarkersSnapshot.forEach(doc => {
                    const data = doc.data();
                    pdfMarkers.push({ 
                        pdfHash: doc.id, 
                        ...data 
                    });
                    // PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å¯¾å¿œè¡¨
                    if (data.fileName) {
                        pdfMetadata.push({
                            pdfHash: doc.id,
                            fileName: data.fileName,
                            totalPages: data.totalPages || 0,
                            fileSize: data.fileSize || 0
                        });
                    }
                });
                
                // 2. localStorageã‹ã‚‰è¨­å®šã‚’å–å¾—
                const settings = {
                    theme: localStorage.getItem('theme') || 'light',
                    fontSize: localStorage.getItem('fontSize') || 'medium',
                    customColors: localStorage.getItem('customColors') || null,
                    deckStudySettings: localStorage.getItem('deckStudySettings') || null,
                    globalStudySettings: localStorage.getItem('globalStudySettings') || null,
                    collapsedDecks: localStorage.getItem('collapsedDecks') || '{}',
                    cardsPerPage: localStorage.getItem('cardsPerPage') || '50',
                    lastSelectedDeckId: localStorage.getItem('lastSelectedDeckId') || null,
                    instantDeleteMode: localStorage.getItem('instantDeleteMode') || 'false'
                };
                
                // 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                const backup = {
                    version: '1.0',
                    userId: null,  // å°†æ¥ã®è¤‡æ•°ãƒ¦ãƒ¼ã‚¶ãƒ¼å¯¾å¿œç”¨
                    exportDate: new Date().toISOString(),
                    appVersion: 'v14.02.8.5',
                    data: {
                        decks: decks,
                        flashcards: flashcards,
                        studySessions: studySessions,
                        pdfMarkers: pdfMarkers,
                        pdfMetadata: pdfMetadata
                    },
                    settings: settings,
                    stats: {
                        deckCount: decks.length,
                        cardCount: flashcards.length,
                        sessionCount: studySessions.length,
                        pdfCount: pdfMarkers.length
                    }
                };
                
                // 4. JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const jsonStr = JSON.stringify(backup, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«å: MyAnkiApp_Backup_YYYYMMDD_HHMMSS.json
                const now = new Date();
                const dateStr = now.getFullYear() + 
                    String(now.getMonth() + 1).padStart(2, '0') + 
                    String(now.getDate()).padStart(2, '0') + '_' +
                    String(now.getHours()).padStart(2, '0') + 
                    String(now.getMinutes()).padStart(2, '0') + 
                    String(now.getSeconds()).padStart(2, '0');
                const filename = `MyAnkiApp_Backup_${dateStr}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if (statusEl) {
                    statusEl.textContent = 'âœ“ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†';
                    statusEl.style.color = '#27ae60';
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                }
                
            } catch (error) {
                console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.textContent = 'âœ— ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—';
                    statusEl.style.color = '#e74c3c';
                }
                alert('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }
        
        // v14.00.1: ã‚«ã‚¹ã‚¿ãƒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportCustomBackup() {
            try {
                // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.textContent = 'â³ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...';
                    statusEl.style.color = '#f39c12';
                    statusEl.style.display = 'inline';
                }
                
                // é¸æŠé …ç›®ã‚’å–å¾—
                const exportOptions = {
                    decks: document.getElementById('export_decks').checked,
                    flashcards: document.getElementById('export_flashcards').checked,
                    studySessions: document.getElementById('export_studySessions').checked,
                    pdfMarkers: document.getElementById('export_pdfMarkers').checked,
                    pdfMetadata: document.getElementById('export_pdfMetadata').checked,
                    theme: document.getElementById('export_theme').checked,
                    fontSize: document.getElementById('export_fontSize').checked,
                    globalStudySettings: document.getElementById('export_globalStudySettings').checked,
                    deckStudySettings: document.getElementById('export_deckStudySettings').checked,
                    uiSettings: document.getElementById('export_uiSettings').checked
                };
                
                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                const backup = {
                    version: '1.0',
                    userId: null,
                    exportDate: new Date().toISOString(),
                    appVersion: 'v14.02.8.5',
                    exportType: 'custom',
                    exportOptions: exportOptions,
                    data: {},
                    settings: {}
                };
                
                // ãƒ‡ãƒ¼ã‚¿é …ç›®ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                if (exportOptions.decks) {
                    const decksSnapshot = await db.collection('decks').orderBy('order').get();
                    const decks = [];
                    decksSnapshot.forEach(doc => {
                        decks.push({ id: doc.id, ...doc.data() });
                    });
                    backup.data.decks = decks;
                }
                
                if (exportOptions.flashcards) {
                    const flashcardsSnapshot = await db.collection('flashcards').get();
                    const flashcards = [];
                    flashcardsSnapshot.forEach(doc => {
                        flashcards.push({ id: doc.id, ...doc.data() });
                    });
                    backup.data.flashcards = flashcards;
                }
                
                if (exportOptions.studySessions) {
                    const studySessionsSnapshot = await db.collection('studySessions').get();
                    const studySessions = [];
                    studySessionsSnapshot.forEach(doc => {
                        studySessions.push({ id: doc.id, ...doc.data() });
                    });
                    backup.data.studySessions = studySessions;
                }
                
                if (exportOptions.pdfMarkers) {
                    const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                    const pdfMarkers = [];
                    pdfMarkersSnapshot.forEach(doc => {
                        pdfMarkers.push({ pdfHash: doc.id, ...doc.data() });
                    });
                    backup.data.pdfMarkers = pdfMarkers;
                }
                
                if (exportOptions.pdfMetadata) {
                    const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                    const pdfMetadata = [];
                    pdfMarkersSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.fileName) {
                            pdfMetadata.push({
                                pdfHash: doc.id,
                                fileName: data.fileName,
                                totalPages: data.totalPages || 0,
                                fileSize: data.fileSize || 0
                            });
                        }
                    });
                    backup.data.pdfMetadata = pdfMetadata;
                }
                
                // è¨­å®šé …ç›®ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                if (exportOptions.theme) {
                    backup.settings.theme = localStorage.getItem('theme') || 'light';
                    backup.settings.customColors = localStorage.getItem('customColors') || null;
                }
                
                if (exportOptions.fontSize) {
                    backup.settings.fontSize = localStorage.getItem('fontSize') || 'medium';
                }
                
                if (exportOptions.globalStudySettings) {
                    backup.settings.globalStudySettings = localStorage.getItem('globalStudySettings') || null;
                }
                
                if (exportOptions.deckStudySettings) {
                    backup.settings.deckStudySettings = localStorage.getItem('deckStudySettings') || null;
                }
                
                if (exportOptions.uiSettings) {
                    backup.settings.collapsedDecks = localStorage.getItem('collapsedDecks') || '{}';
                    backup.settings.cardsPerPage = localStorage.getItem('cardsPerPage') || '50';
                    backup.settings.lastSelectedDeckId = localStorage.getItem('lastSelectedDeckId') || null;
                    backup.settings.instantDeleteMode = localStorage.getItem('instantDeleteMode') || 'false';
                }
                
                // çµ±è¨ˆæƒ…å ±ã‚’è¿½åŠ 
                backup.stats = {
                    deckCount: backup.data.decks ? backup.data.decks.length : 0,
                    cardCount: backup.data.flashcards ? backup.data.flashcards.length : 0,
                    sessionCount: backup.data.studySessions ? backup.data.studySessions.length : 0,
                    pdfCount: backup.data.pdfMarkers ? backup.data.pdfMarkers.length : 0
                };
                
                // JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const jsonStr = JSON.stringify(backup, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«å: MyAnkiApp_Custom_YYYYMMDD_HHMMSS.json
                const now = new Date();
                const dateStr = now.getFullYear() + 
                    String(now.getMonth() + 1).padStart(2, '0') + 
                    String(now.getDate()).padStart(2, '0') + '_' +
                    String(now.getHours()).padStart(2, '0') + 
                    String(now.getMinutes()).padStart(2, '0') + 
                    String(now.getSeconds()).padStart(2, '0');
                const filename = `MyAnkiApp_Custom_${dateStr}.json`;
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if (statusEl) {
                    statusEl.textContent = 'âœ“ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†';
                    statusEl.style.color = '#27ae60';
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                }
                
            } catch (error) {
                console.error('ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                const statusEl = document.getElementById('exportStatus');
                if (statusEl) {
                    statusEl.textContent = 'âœ— ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—';
                    statusEl.style.color = '#e74c3c';
                }
                alert('ã‚«ã‚¹ã‚¿ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }
        
        // ========== v14.01: ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ ==========
        
        // v14.01.7: RFC 4180æº–æ‹ ã®CSVãƒ‘ãƒ¼ã‚µãƒ¼
        function parseCSV(text) {
            const lines = [];
            let currentField = '';
            let currentLine = [];
            let inQuotes = false;
            
            // BOMã‚’å‰Šé™¤
            if (text.charCodeAt(0) === 0xFEFF) {
                text = text.substring(1);
            }
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];
                
                if (inQuotes) {
                    if (char === '"') {
                        if (nextChar === '"') {
                            // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ
                            currentField += '"';
                            i++; // æ¬¡ã®æ–‡å­—ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        } else {
                            // ã‚¯ã‚©ãƒ¼ãƒˆçµ‚äº†
                            inQuotes = false;
                        }
                    } else {
                        currentField += char;
                    }
                } else {
                    if (char === '"') {
                        // ã‚¯ã‚©ãƒ¼ãƒˆé–‹å§‹
                        inQuotes = true;
                    } else if (char === ',') {
                        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åŒºåˆ‡ã‚Š
                        currentLine.push(currentField.trim());
                        currentField = '';
                    } else if (char === '\n' || char === '\r') {
                        // è¡ŒåŒºåˆ‡ã‚Š
                        if (char === '\r' && nextChar === '\n') {
                            i++; // CRLFã®å ´åˆã¯LFã‚‚ã‚¹ã‚­ãƒƒãƒ—
                        }
                        if (currentField || currentLine.length > 0) {
                            currentLine.push(currentField.trim());
                            if (currentLine.some(field => field)) {
                                lines.push(currentLine);
                            }
                            currentLine = [];
                            currentField = '';
                        }
                    } else {
                        currentField += char;
                    }
                }
            }
            
            // æœ€å¾Œã®è¡Œã‚’è¿½åŠ 
            if (currentField || currentLine.length > 0) {
                currentLine.push(currentField.trim());
                if (currentLine.some(field => field)) {
                    lines.push(currentLine);
                }
            }
            
            return lines;
        }
        
        // CSVã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        // v14.02.8.9: ãƒ‡ãƒƒã‚­æŒ‡å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³è¿½åŠ ã€è‡ªå‹•ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ‡ãƒƒã‚­æŒ¯ã‚Šåˆ†ã‘
        async function importCardsFromCsv(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const lines = parseCSV(text);
                
                if (lines.length === 0) {
                    alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™ã€‚');
                    return;
                }
                
                // CSVãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                csvDataForImport = lines;
                
                // ãƒ‡ãƒƒã‚­ã‚’æŒ‡å®šã—ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
                const specifyDeck = document.getElementById('specifyDeckForImport').checked;
                if (specifyDeck) {
                    openCsvDeckSelectorModal();
                } else {
                    // é€šå¸¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼ˆCSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ä½¿ç”¨ã€ç©ºãªã‚‰ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ‡ãƒƒã‚­ï¼‰
                    await executeImportWithDeck(null);
                }
                
            } catch (error) {
                console.error('CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
            event.target.value = '';
        }
        
        // v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Ÿè¡Œï¼ˆãƒ‡ãƒƒã‚­IDã‚’æŒ‡å®šã€ã¾ãŸã¯CSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ä½¿ç”¨ï¼‰
        async function executeImportWithDeck(forceDeckId) {
            if (!csvDataForImport || csvDataForImport.length === 0) return;
            
            try {
                const skipDuplicates = document.getElementById('skipDuplicates').checked;
                let importedCount = 0;
                let skippedCount = 0;
                let errorCount = 0;
                
                // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
                let existingCards = [];
                if (skipDuplicates) {
                    const snapshot = await db.collection('flashcards').get();
                    snapshot.forEach(doc => {
                        existingCards.push(doc.data());
                    });
                }
                
                for (const fields of csvDataForImport) {
                    try {
                        if (fields.length < 2) {
                            errorCount++;
                            continue;
                        }
                        
                        const firstField = fields[0];
                        
                        // v14.01.8: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰åˆ¤å®šï¼ˆ{{c1::}}ãªã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å«ã‚€ï¼‰
                        const isCloze = /\{\{c\d+::[^}]+\}\}/.test(firstField);
                        
                        if (isCloze) {
                            // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ï¼šclozeText,ãƒ‡ãƒƒã‚­å,ã‚¿ã‚°
                            const clozeText = firstField;
                            const csvDeckName = fields.length > 1 ? fields[1] : '';
                            const tags = fields.length > 2 ? fields[2] : '';
                            
                            if (!clozeText) {
                                errorCount++;
                                continue;
                            }
                            
                            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                            if (skipDuplicates) {
                                const isDuplicate = existingCards.some(card => 
                                    card.type === 'cloze' && (card.clozeText === clozeText || card.text === clozeText)
                                );
                                if (isDuplicate) {
                                    skippedCount++;
                                    continue;
                                }
                            }
                            
                            // ãƒ‡ãƒƒã‚­IDã‚’æ±ºå®š
                            let deckId = '';
                            if (forceDeckId !== null) {
                                // ãƒ‡ãƒƒã‚­ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
                                deckId = forceDeckId;
                            } else if (csvDeckName) {
                                // CSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ä½¿ç”¨
                                const decksSnapshot = await db.collection('decks').where('name', '==', csvDeckName).limit(1).get();
                                if (!decksSnapshot.empty) {
                                    deckId = decksSnapshot.docs[0].id;
                                } else {
                                    const newDeckRef = await db.collection('decks').add({
                                        name: csvDeckName,
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                        order: Date.now()
                                    });
                                    deckId = newDeckRef.id;
                                }
                            } else {
                                // ãƒ‡ãƒƒã‚­åãŒç©ºã®å ´åˆã¯ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ‡ãƒƒã‚­ã‚’ä½¿ç”¨
                                const importDeckSnapshot = await db.collection('decks').where('name', '==', 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ').limit(1).get();
                                if (!importDeckSnapshot.empty) {
                                    deckId = importDeckSnapshot.docs[0].id;
                                } else {
                                    const newDeckRef = await db.collection('decks').add({
                                        name: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ',
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                        order: Date.now()
                                    });
                                    deckId = newDeckRef.id;
                                }
                            }
                            
                            // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                            await db.collection('flashcards').add({
                                type: 'cloze',
                                clozeText: clozeText,
                                text: clozeText, // äº’æ›æ€§ã®ãŸã‚
                                deckId: deckId,
                                tags: tags ? tags.split(/\s+/) : [],
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                state: 'new',
                                easeFactor: 2.5,
                                interval: 0,
                                lapseCount: 0
                            });
                            
                            importedCount++;
                            
                        } else {
                            // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ï¼šå•é¡Œ,ç­”ãˆ,ãƒ‡ãƒƒã‚­å,ã‚¿ã‚°
                            const question = fields[0];
                            const answer = fields[1];
                            const csvDeckName = fields.length > 2 ? fields[2] : '';
                            const tags = fields.length > 3 ? fields[3] : '';
                            
                            if (!question || !answer) {
                                errorCount++;
                                continue;
                            }
                            
                            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆv14.01.10: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã¯é™¤å¤–ï¼‰
                            if (skipDuplicates) {
                                const isDuplicate = existingCards.some(card => 
                                    card.type !== 'typing' && 
                                    card.question === question && 
                                    card.answer === answer
                                );
                                if (isDuplicate) {
                                    skippedCount++;
                                    continue;
                                }
                            }
                            
                            // ãƒ‡ãƒƒã‚­IDã‚’æ±ºå®š
                            let deckId = '';
                            if (forceDeckId !== null) {
                                // ãƒ‡ãƒƒã‚­ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
                                deckId = forceDeckId;
                            } else if (csvDeckName) {
                                // CSVå†…ã®ãƒ‡ãƒƒã‚­åã‚’ä½¿ç”¨
                                const decksSnapshot = await db.collection('decks').where('name', '==', csvDeckName).limit(1).get();
                                if (!decksSnapshot.empty) {
                                    deckId = decksSnapshot.docs[0].id;
                                } else {
                                    // æ–°ã—ã„ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ
                                    const newDeckRef = await db.collection('decks').add({
                                        name: csvDeckName,
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                        order: Date.now()
                                    });
                                    deckId = newDeckRef.id;
                                }
                            } else {
                                // ãƒ‡ãƒƒã‚­åãŒç©ºã®å ´åˆã¯ã€Œã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ‡ãƒƒã‚­ã‚’ä½¿ç”¨
                                const importDeckSnapshot = await db.collection('decks').where('name', '==', 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ').limit(1).get();
                                if (!importDeckSnapshot.empty) {
                                    deckId = importDeckSnapshot.docs[0].id;
                                } else {
                                    const newDeckRef = await db.collection('decks').add({
                                        name: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ',
                                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                        order: Date.now()
                                    });
                                    deckId = newDeckRef.id;
                                }
                            }
                            
                            // ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                            await db.collection('flashcards').add({
                                type: 'basic',
                                question: question,
                                answer: answer,
                                deckId: deckId,
                                tags: tags ? tags.split(/\s+/) : [],
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                state: 'new',
                                easeFactor: 2.5,
                                interval: 0,
                                lapseCount: 0
                            });
                            
                            importedCount++;
                        }
                        
                    } catch (err) {
                        console.error('ã‚«ãƒ¼ãƒ‰è¿½åŠ ã‚¨ãƒ©ãƒ¼:', err);
                        errorCount++;
                    }
                }
                
                // çµæœã‚’è¡¨ç¤º
                let message = `ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†\n\n`;
                message += `âœ“ ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ: ${importedCount}æš\n`;
                if (skippedCount > 0) {
                    message += `âŠ˜ é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—: ${skippedCount}æš\n`;
                }
                if (errorCount > 0) {
                    message += `âœ— ã‚¨ãƒ©ãƒ¼: ${errorCount}è¡Œ\n`;
                }
                
                alert(message);
                
                // CSVãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                csvDataForImport = null;
                
                // ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                if (importedCount > 0) {
                    // ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚’åæ˜ 
                    location.reload();
                }
                
            } catch (error) {
                console.error('CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }
        
        // JSONãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
        async function importFromBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!confirm('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã™ã‚‹ã¨ã€ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚\né‡è¤‡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚\n\nç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ')) {
                event.target.value = '';
                return;
            }
            
            try {
                const text = await file.text();
                const backup = JSON.parse(text);
                
                // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
                if (!backup.version) {
                    throw new Error('ç„¡åŠ¹ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚');
                }
                
                const skipDuplicates = document.getElementById('skipDuplicates').checked;
                let stats = {
                    decks: { imported: 0, skipped: 0, errors: 0 },
                    flashcards: { imported: 0, skipped: 0, errors: 0 },
                    studySessions: { imported: 0, skipped: 0, errors: 0 },
                    pdfMarkers: { imported: 0, skipped: 0, errors: 0 }
                };
                
                // ãƒ‡ãƒƒã‚­ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (backup.data.decks && backup.data.decks.length > 0) {
                    for (const deck of backup.data.decks) {
                        try {
                            if (skipDuplicates) {
                                const existing = await db.collection('decks').where('name', '==', deck.name).limit(1).get();
                                if (!existing.empty) {
                                    stats.decks.skipped++;
                                    continue;
                                }
                            }
                            
                            const deckData = { ...deck };
                            delete deckData.id;
                            // Firestoreã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®äº’æ›æ€§å•é¡Œã‚’å›é¿
                            if (deckData.createdAt && typeof deckData.createdAt === 'object' && !deckData.createdAt.toDate) {
                                // toDateãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„å ´åˆã¯ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å‰Šé™¤
                                delete deckData.createdAt;
                                deckData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                            } else if (!deckData.createdAt) {
                                // createdAtãŒãªã„å ´åˆã¯æ–°è¦ã«è¨­å®š
                                deckData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                            }
                            await db.collection('decks').doc(deck.id).set(deckData);
                            stats.decks.imported++;
                        } catch (err) {
                            console.error('ãƒ‡ãƒƒã‚­ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', err);
                            stats.decks.errors++;
                        }
                    }
                }
                
                // ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (backup.data.flashcards && backup.data.flashcards.length > 0) {
                    for (const card of backup.data.flashcards) {
                        try {
                            // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸé‡è¤‡ãƒã‚§ãƒƒã‚¯
                            if (skipDuplicates) {
                                let isDuplicate = false;
                                
                                if (card.type === 'basic' && card.question && card.answer) {
                                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰
                                    const existing = await db.collection('flashcards')
                                        .where('type', '==', 'basic')
                                        .where('question', '==', card.question)
                                        .where('answer', '==', card.answer)
                                        .limit(1).get();
                                    isDuplicate = !existing.empty;
                                } else if (card.type === 'cloze' && card.clozeText) {
                                    // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰
                                    const existing = await db.collection('flashcards')
                                        .where('type', '==', 'cloze')
                                        .where('clozeText', '==', card.clozeText)
                                        .limit(1).get();
                                    isDuplicate = !existing.empty;
                                } else if (card.type === 'typing' && card.typingQuestion && card.typingAnswer) {
                                    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰
                                    const existing = await db.collection('flashcards')
                                        .where('type', '==', 'typing')
                                        .where('typingQuestion', '==', card.typingQuestion)
                                        .where('typingAnswer', '==', card.typingAnswer)
                                        .limit(1).get();
                                    isDuplicate = !existing.empty;
                                }
                                
                                if (isDuplicate) {
                                    stats.flashcards.skipped++;
                                    continue;
                                }
                            }
                            
                            const cardData = { ...card };
                            delete cardData.id;
                            // Firestoreã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®äº’æ›æ€§å•é¡Œã‚’å›é¿
                            if (cardData.createdAt && typeof cardData.createdAt === 'object' && !cardData.createdAt.toDate) {
                                // toDateãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„å ´åˆã¯ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å‰Šé™¤
                                delete cardData.createdAt;
                                cardData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                            } else if (!cardData.createdAt) {
                                // createdAtãŒãªã„å ´åˆã¯æ–°è¦ã«è¨­å®š
                                cardData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                            }
                            await db.collection('flashcards').doc(card.id).set(cardData);
                            stats.flashcards.imported++;
                        } catch (err) {
                            console.error('ã‚«ãƒ¼ãƒ‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', err);
                            stats.flashcards.errors++;
                        }
                    }
                }
                
                // å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (backup.data.studySessions && backup.data.studySessions.length > 0) {
                    for (const session of backup.data.studySessions) {
                        try {
                            const sessionData = { ...session };
                            delete sessionData.id;
                            // Firestoreã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®äº’æ›æ€§å•é¡Œã‚’å›é¿
                            if (sessionData.startTime && typeof sessionData.startTime === 'object' && !sessionData.startTime.toDate) {
                                delete sessionData.startTime;
                            }
                            if (sessionData.endTime && typeof sessionData.endTime === 'object' && !sessionData.endTime.toDate) {
                                delete sessionData.endTime;
                            }
                            await db.collection('studySessions').doc(session.id).set(sessionData);
                            stats.studySessions.imported++;
                        } catch (err) {
                            console.error('ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', err);
                            stats.studySessions.errors++;
                        }
                    }
                }
                
                // PDFãƒãƒ¼ã‚«ãƒ¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (backup.data.pdfMarkers && backup.data.pdfMarkers.length > 0) {
                    for (const pdfMarker of backup.data.pdfMarkers) {
                        try {
                            if (skipDuplicates) {
                                const existing = await db.collection('pdfMarkers').doc(pdfMarker.pdfHash).get();
                                if (existing.exists) {
                                    stats.pdfMarkers.skipped++;
                                    continue;
                                }
                            }
                            
                            const markerData = { ...pdfMarker };
                            delete markerData.pdfHash;
                            // Firestoreã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®äº’æ›æ€§å•é¡Œã‚’å›é¿
                            if (markerData.lastStudied && typeof markerData.lastStudied === 'object' && !markerData.lastStudied.toDate) {
                                delete markerData.lastStudied;
                            }
                            // markersé…åˆ—å†…ã®å„ãƒãƒ¼ã‚«ãƒ¼ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚‚å‡¦ç†
                            if (markerData.markers && Array.isArray(markerData.markers)) {
                                markerData.markers = markerData.markers.map(marker => {
                                    const m = { ...marker };
                                    if (m.createdAt && typeof m.createdAt === 'object' && !m.createdAt.toDate) {
                                        delete m.createdAt;
                                    }
                                    return m;
                                });
                            }
                            await db.collection('pdfMarkers').doc(pdfMarker.pdfHash).set(markerData);
                            stats.pdfMarkers.imported++;
                        } catch (err) {
                            console.error('PDFãƒãƒ¼ã‚«ãƒ¼ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', err);
                            stats.pdfMarkers.errors++;
                        }
                    }
                }
                
                // è¨­å®šã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                if (backup.settings) {
                    if (backup.settings.theme) localStorage.setItem('theme', backup.settings.theme);
                    if (backup.settings.customColors) localStorage.setItem('customColors', backup.settings.customColors);
                    if (backup.settings.fontSize) localStorage.setItem('fontSize', backup.settings.fontSize);
                    if (backup.settings.globalStudySettings) localStorage.setItem('globalStudySettings', backup.settings.globalStudySettings);
                    if (backup.settings.deckStudySettings) localStorage.setItem('deckStudySettings', backup.settings.deckStudySettings);
                    if (backup.settings.collapsedDecks) localStorage.setItem('collapsedDecks', backup.settings.collapsedDecks);
                    if (backup.settings.cardsPerPage) localStorage.setItem('cardsPerPage', backup.settings.cardsPerPage);
                    if (backup.settings.lastSelectedDeckId) localStorage.setItem('lastSelectedDeckId', backup.settings.lastSelectedDeckId);
                    if (backup.settings.instantDeleteMode) localStorage.setItem('instantDeleteMode', backup.settings.instantDeleteMode);
                }
                
                // çµæœã‚’è¡¨ç¤º
                let message = 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã—ã¾ã—ãŸ\n\n';
                message += `ã€ãƒ‡ãƒƒã‚­ã€‘\nâœ“ ${stats.decks.imported}ä»¶ âŠ˜ ${stats.decks.skipped}ä»¶ âœ— ${stats.decks.errors}ä»¶\n\n`;
                message += `ã€ã‚«ãƒ¼ãƒ‰ã€‘\nâœ“ ${stats.flashcards.imported}ä»¶ âŠ˜ ${stats.flashcards.skipped}ä»¶ âœ— ${stats.flashcards.errors}ä»¶\n\n`;
                message += `ã€å­¦ç¿’è¨˜éŒ²ã€‘\nâœ“ ${stats.studySessions.imported}ä»¶ âŠ˜ ${stats.studySessions.skipped}ä»¶ âœ— ${stats.studySessions.errors}ä»¶\n\n`;
                message += `ã€PDFãƒãƒ¼ã‚«ãƒ¼ã€‘\nâœ“ ${stats.pdfMarkers.imported}ä»¶ âŠ˜ ${stats.pdfMarkers.skipped}ä»¶ âœ— ${stats.pdfMarkers.errors}ä»¶`;
                
                alert(message);
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’å†èª­ã¿è¾¼ã¿ï¼ˆãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰ï¼‰
                location.reload();
                
            } catch (error) {
                console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
            event.target.value = '';
        }
        
        // v12.03: ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºé©ç”¨
        function applyFontSize(size) {
            document.body.classList.remove('font-small', 'font-medium', 'font-large', 'font-xlarge');
            document.body.classList.add('font-' + size);
            currentFontSize = size;
            localStorage.setItem('fontSize', size);
            
            // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã‚’æ›´æ–°
            const smallRadio = document.getElementById('fontSmall');
            const mediumRadio = document.getElementById('fontMedium');
            const largeRadio = document.getElementById('fontLarge');
            const xlargeRadio = document.getElementById('fontXLarge');
            if (smallRadio && mediumRadio && largeRadio && xlargeRadio) {
                smallRadio.checked = (size === 'small');
                mediumRadio.checked = (size === 'medium');
                largeRadio.checked = (size === 'large');
                xlargeRadio.checked = (size === 'xlarge');
            }
        }
        
        // v12.03: ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºå¤‰æ›´
        function changeFontSize(size) {
            applyFontSize(size);
        }
        

        // v12.03.3: åˆæœŸåŒ–æ™‚ã«è¨­å®šã‚’é©ç”¨
        document.addEventListener('DOMContentLoaded', function() {
            applyFontSize(currentFontSize);
            changeTheme(currentTheme);
        });
        
        let cards = [];
        let currentIndex = 0;
        let showingQuestion = true;
        let editingCardId = null;
        let currentCardIsReversed = false;
        
        // v6.00.1: ãƒ‡ãƒƒã‚­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çŠ¶æ…‹ã‚’ä¿æŒ
        let currentDeckFilter = '';
        
        // v5.01: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ç®¡ç†
        let currentCardType = 'basic'; // 'basic' or 'cloze'
        let clozeCounter = 1; // ç©´åŸ‹ã‚ç•ªå·ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
        let currentClozeAnswers = {}; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ç©´åŸ‹ã‚ã®ç­”ãˆè¡¨ç¤ºçŠ¶æ…‹
        
        let decks = [];
        let currentEditingDeckId = null;
        const MAX_DECK_DEPTH = 3;
        
        // v8.01.1: ãƒ‡ãƒƒã‚­ã”ã¨ã®å­¦ç¿’è¨­å®šã‚’ä¿å­˜
        let deckStudySettings = {};
        
        // v8.01.1: ãƒ‡ãƒƒã‚­è¨­å®šã‚’localStorageã‹ã‚‰èª­ã¿è¾¼ã¿
        function loadDeckSettings() {
            const saved = localStorage.getItem('deckStudySettings');
            if (saved) {
                try {
                    deckStudySettings = JSON.parse(saved);
                } catch (e) {
                    console.error('è¨­å®šèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
                    deckStudySettings = {};
                }
            }
        }
        
        // v8.01.1: ãƒ‡ãƒƒã‚­è¨­å®šã‚’localStorageã«ä¿å­˜
        function saveDeckSettings() {
            localStorage.setItem('deckStudySettings', JSON.stringify(deckStudySettings));
        }
        
        // v8.01.1: ãƒ‡ãƒƒã‚­è¨­å®šã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚ã‚Šï¼‰
        function getDeckSetting(deckId, key, defaultValue) {
            if (!deckStudySettings[deckId]) {
                deckStudySettings[deckId] = {};
            }
            return deckStudySettings[deckId][key] !== undefined 
                ? deckStudySettings[deckId][key] 
                : defaultValue;
        }
        
        // v8.01.1: ãƒ‡ãƒƒã‚­è¨­å®šã‚’ä¿å­˜
        function setDeckSetting(deckId, key, value) {
            if (!deckStudySettings[deckId]) {
                deckStudySettings[deckId] = {};
            }
            deckStudySettings[deckId][key] = value;
            saveDeckSettings();
        }
        
        // v6.01.1: ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†çŠ¶æ…‹ã‚’ç®¡ç†
        let decksLoaded = false;
        let cardsLoaded = false;
        
        // v8.00: å­¦ç¿’æ©Ÿèƒ½ç”¨å¤‰æ•°
        let studySession = {
            deckId: null,
            cards: [],
            waitingCards: [], // v8.01: å¾…æ©Ÿä¸­ã®ã‚«ãƒ¼ãƒ‰ï¼ˆLearning/Relearningï¼‰
            currentCardIndex: 0,
            showingAnswer: false,
            stats: {
                new: 0,
                learning: 0,
                review: 0,
                relearning: 0
            },
            settings: { // v8.01: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã”ã¨ã®è¨­å®š
                newCardsPerDay: 20,
                reviewCardsPerDay: 200,
                studyMode: 'mixed', // 'new', 'review', 'mixed'
                includeSubdecks: true,
                newCardOrder: 'added', // v8.01.1: 'added' or 'random'
                reviewCardOrder: 'due', // v8.01.1: 'due' or 'random'
                mixNewAndReview: false // v8.01.2: æ–°è¦ã¨å¾©ç¿’ã‚’æ··ãœã‚‹
            },
            // v8.02.3: å­¦ç¿’å±¥æ­´è¨˜éŒ²
            sessionStart: null, // å­¦ç¿’é–‹å§‹æ™‚åˆ»
            sessionRatings: { // è©•ä¾¡ã‚«ã‚¦ãƒ³ãƒˆ
                again: 0,
                hard: 0,
                good: 0,
                easy: 0
            },
            // v8.02.2: Ankiå¼æ™‚é–“è¨ˆæ¸¬
            currentCardStartTime: null, // ç¾åœ¨ã®ã‚«ãƒ¼ãƒ‰ã®è¡¨ç¤ºé–‹å§‹æ™‚åˆ»
            totalStudyDuration: 0, // ç´¯ç©å­¦ç¿’æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
            maxCardDuration: 60000 // 1æšã‚ãŸã‚Šã®ä¸Šé™æ™‚é–“ï¼ˆ60ç§’ = 60000ãƒŸãƒªç§’ï¼‰
        };
        
        // v8.00: Ankiæ”¹è‰¯ç‰ˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
        const defaultStudySettings = {
            learningSteps: [1, 10], // åˆ†å˜ä½
            graduatingInterval: 1, // æ—¥
            easyInterval: 4, // æ—¥
            startingEase: 2.5,
            easyBonus: 1.3,
            intervalModifier: 1.0,
            maximumInterval: 36500, // 100å¹´
            newCardsPerDay: 20,
            reviewCardsPerDay: 200
        };
        
        // v8.02.4: ã‚°ãƒ­ãƒ¼ãƒãƒ«å­¦ç¿’è¨­å®š
        let globalStudySettings = {...defaultStudySettings};
        
        // v8.02.4: ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã®åˆæœŸåŒ–
        function initGlobalSettings() {
            const saved = localStorage.getItem('globalStudySettings');
            if (saved) {
                try {
                    globalStudySettings = JSON.parse(saved);
                } catch (e) {
                    console.error('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', e);
                    globalStudySettings = {...defaultStudySettings};
                }
            }
        }
        
        // v8.02.4: ãƒ‡ãƒƒã‚­ã®å­¦ç¿’è¨­å®šã‚’å–å¾—
        function getStudySettings(deckId) {
            const deck = decks.find(d => d.id === deckId);
            if (deck && deck.useCustomSettings && deck.settings) {
                return deck.settings;
            }
            return globalStudySettings;
        }

        
        // v8.02.3: Firestoreæ›¸ãè¾¼ã¿å›æ•°ç®¡ç†
        const FIRESTORE_DAILY_LIMIT = 20000;
        let firestoreWriteStopped = false; // 100%åˆ°é”ãƒ•ãƒ©ã‚°
        
        function getTodayKey() {
            return 'firestoreWrites_' + new Date().toISOString().split('T')[0];
        }
        
        function getWriteCount() {
            return parseInt(localStorage.getItem(getTodayKey()) || '0');
        }
        
        function incrementWriteCounter() {
            if (firestoreWriteStopped) {
                console.warn('Firestoreæ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ä¿å­˜ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚');
                return false;
            }
            
            const key = getTodayKey();
            let count = getWriteCount();
            count++;
            localStorage.setItem(key, count);
            
            console.log(`Firestoreæ›¸ãè¾¼ã¿: ${count}/${FIRESTORE_DAILY_LIMIT} (${(count/FIRESTORE_DAILY_LIMIT*100).toFixed(1)}%)`);
            
            // è­¦å‘Šãƒã‚§ãƒƒã‚¯
            if (count >= FIRESTORE_DAILY_LIMIT) {
                // 100%åˆ°é”
                firestoreWriteStopped = true;
                alert('ğŸš¨ Firestoreæ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¾ã—ãŸ\n\nã“ã‚Œä»¥ä¸Šå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚\næ˜æ—¥0æ™‚ï¼ˆUTCï¼‰ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚\n\nå­¦ç¿’ã¯ç¶šã‘ã‚‰ã‚Œã¾ã™ãŒã€ãƒ‡ãƒ¼ã‚¿ã¯ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚');
                showWriteLimitWarning(count);
            } else if (count >= FIRESTORE_DAILY_LIMIT * 0.95) {
                // 95%åˆ°é”
                showWriteLimitWarning(count);
            } else if (count >= FIRESTORE_DAILY_LIMIT * 0.8) {
                // 80%åˆ°é”
                showWriteLimitWarning(count);
            }
            
            return true;
        }
        
        function showWriteLimitWarning(count) {
            const warning = document.getElementById('writeLimitWarning');
            if (!warning) return;
            
            const percentage = (count / FIRESTORE_DAILY_LIMIT * 100).toFixed(1);
            const remaining = FIRESTORE_DAILY_LIMIT - count;
            
            warning.style.display = 'block';
            
            if (count >= FIRESTORE_DAILY_LIMIT) {
                // 100%
                warning.className = 'write-limit-warning error';
                warning.innerHTML = `ğŸš¨ æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¾ã—ãŸï¼š${count.toLocaleString()}/${FIRESTORE_DAILY_LIMIT.toLocaleString()} (${percentage}%)<br>ã“ã‚Œä»¥ä¸Šãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚`;
            } else if (count >= FIRESTORE_DAILY_LIMIT * 0.95) {
                // 95%
                warning.className = 'write-limit-warning warning-95';
                warning.innerHTML = `ğŸš¨ æ›¸ãè¾¼ã¿ä¸Šé™é–“è¿‘ï¼š${count.toLocaleString()}/${FIRESTORE_DAILY_LIMIT.toLocaleString()} (${percentage}%) - æ®‹ã‚Š${remaining}å›`;
            } else if (count >= FIRESTORE_DAILY_LIMIT * 0.8) {
                // 80%
                warning.className = 'write-limit-warning warning-80';
                warning.innerHTML = `âš ï¸ æ›¸ãè¾¼ã¿å›æ•°ï¼š${count.toLocaleString()}/${FIRESTORE_DAILY_LIMIT.toLocaleString()} (${percentage}%) - æ®‹ã‚Š${remaining}å›`;
            } else {
                warning.style.display = 'none';
            }
        }
        
        // v8.02.3: Firestoreä½¿ç”¨çŠ¶æ³ã‚’æ›´æ–°
        function updateFirestoreUsage() {
            const count = getWriteCount();
            const percentage = (count / FIRESTORE_DAILY_LIMIT * 100).toFixed(1);
            
            const writesEl = document.getElementById('firestoreWrites');
            const usageEl = document.getElementById('firestoreUsage');
            
            if (writesEl) writesEl.textContent = count.toLocaleString() + 'å›';
            if (usageEl) usageEl.textContent = percentage + '%';
        }
        
        // v14.02.1.2: ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ã‚’è¡¨ç¤º
        function showToast(message, duration = 10000, type = 'success') {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            
            const toast = document.createElement('div');
            const colors = {
                success: { bg: '#27ae60', icon: 'âœ…' },
                error: { bg: '#e74c3c', icon: 'âŒ' },
                info: { bg: '#3498db', icon: 'â„¹ï¸' },
                warning: { bg: '#f39c12', icon: 'âš ï¸' }
            };
            
            const style = colors[type] || colors.info;
            
            toast.style.cssText = `
                background: ${style.bg};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                margin-top: 10px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 10px;
                min-width: 250px;
                max-width: 400px;
                font-size: 14px;
                animation: slideIn 0.3s ease-out;
                cursor: pointer;
            `;
            
            toast.innerHTML = `
                <span style="font-size: 20px;">${style.icon}</span>
                <span style="flex: 1;">${message}</span>
            `;
            
            // ã‚¯ãƒªãƒƒã‚¯ã§å³åº§ã«é–‰ã˜ã‚‹
            toast.onclick = () => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            };
            
            container.appendChild(toast);
            
            // æŒ‡å®šæ™‚é–“å¾Œã«è‡ªå‹•ã§æ¶ˆãˆã‚‹
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.animation = 'slideOut 0.3s ease-out';
                    setTimeout(() => toast.remove(), 300);
                }
            }, duration);
        }
        
        // v14.02.1: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’è¨ˆç®—
        // v14.02.1.2: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¿½åŠ 
        async function calculateStorageUsage() {
            // v14.02.1.2: è¦ç´ ã‚’é–¢æ•°ã‚¹ã‚³ãƒ¼ãƒ—ã§å–å¾—
            const totalSizeEl = document.getElementById('totalStorageSize');
            
            try {
                // è¨ˆç®—ä¸­è¡¨ç¤º
                if (totalSizeEl) totalSizeEl.textContent = 'è¨ˆç®—ä¸­...';
                
                const collections = {
                    flashcards: { name: 'ã‚«ãƒ¼ãƒ‰', icon: 'ğŸ“‡', color: '#667eea' },
                    decks: { name: 'ãƒ‡ãƒƒã‚­', icon: 'ğŸ“š', color: '#3498db' },
                    studySessions: { name: 'å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³', icon: 'ğŸ“Š', color: '#27ae60' },
                    pdfMarkers: { name: 'PDFãƒãƒ¼ã‚«ãƒ¼', icon: 'ğŸ“„', color: '#f39c12' }
                };
                
                let totalSize = 0;
                let totalDocs = 0;
                const collectionStats = [];
                
                // å„ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                for (const [collectionName, info] of Object.entries(collections)) {
                    try {
                        const snapshot = await db.collection(collectionName).get();
                        const docCount = snapshot.size;
                        
                        // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã‚’æ¨å®š
                        let collectionSize = 0;
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            const jsonStr = JSON.stringify(data);
                            const baseSize = new Blob([jsonStr]).size;
                            
                            // Firestoreã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºæ¨å®š
                            // - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå: ç´„16ãƒã‚¤ãƒˆ
                            // - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰: ç´„32ãƒã‚¤ãƒˆ
                            // - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã®ç´„20-30%
                            const overhead = 48; // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆID + ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å
                            const indexSize = baseSize * 0.25; // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ¨å®š
                            const estimatedSize = baseSize + overhead + indexSize;
                            
                            collectionSize += estimatedSize;
                        });
                        
                        totalSize += collectionSize;
                        totalDocs += docCount;
                        
                        collectionStats.push({
                            name: info.name,
                            icon: info.icon,
                            color: info.color,
                            count: docCount,
                            size: collectionSize
                        });
                    } catch (err) {
                        console.warn(`${collectionName}ã®å–å¾—ã‚¨ãƒ©ãƒ¼:`, err);
                    }
                }
                
                // ç·ãƒ‡ãƒ¼ã‚¿é‡ã‚’æ›´æ–°ï¼ˆtotalSizeElã¯ä¸Šéƒ¨ã§å®£è¨€æ¸ˆã¿ï¼‰
                const totalDocsEl = document.getElementById('totalDocuments');
                const progressEl = document.getElementById('storageProgress');
                
                if (totalSizeEl) {
                    const sizeMB = (totalSize / 1024 / 1024).toFixed(2);
                    totalSizeEl.textContent = sizeMB + ' MB';
                }
                
                if (totalDocsEl) {
                    totalDocsEl.textContent = totalDocs.toLocaleString() + 'ä»¶';
                }
                
                // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ï¼ˆ1GB = 1024MB ã‚’100%ã¨ã™ã‚‹ï¼‰
                if (progressEl) {
                    const percentage = Math.min((totalSize / 1024 / 1024 / 1024) * 100, 100);
                    progressEl.style.width = percentage + '%';
                    
                    // 80%ä»¥ä¸Šã§è‰²ã‚’å¤‰æ›´
                    if (percentage >= 80) {
                        progressEl.style.background = 'linear-gradient(90deg, #e74c3c, #c0392b)';
                    } else if (percentage >= 50) {
                        progressEl.style.background = 'linear-gradient(90deg, #f39c12, #e67e22)';
                    } else {
                        progressEl.style.background = 'linear-gradient(90deg, #667eea, #764ba2)';
                    }
                }
                
                // ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³åˆ¥å†…è¨³ã‚’è¡¨ç¤º
                const breakdownEl = document.getElementById('storageBreakdown');
                if (breakdownEl) {
                    breakdownEl.innerHTML = collectionStats
                        .sort((a, b) => b.size - a.size)
                        .map(stat => {
                            const sizeMB = (stat.size / 1024 / 1024).toFixed(2);
                            const sizeKB = (stat.size / 1024).toFixed(1);
                            const displaySize = stat.size > 1024 * 1024 ? sizeMB + ' MB' : sizeKB + ' KB';
                            const percentage = totalSize > 0 ? ((stat.size / totalSize) * 100).toFixed(1) : 0;
                            
                            return `
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid ${stat.color};">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <div style="font-weight: bold; color: #333;">
                                            ${stat.icon} ${stat.name}
                                        </div>
                                        <div style="font-size: 18px; font-weight: bold; color: ${stat.color};">
                                            ${displaySize}
                                        </div>
                                    </div>
                                    <div style="font-size: 13px; color: #666;">
                                        ${stat.count.toLocaleString()}ä»¶ (${percentage}%)
                                    </div>
                                </div>
                            `;
                        })
                        .join('');
                }
                
                // v14.02.1.2: è¨ˆç®—å®Œäº†ã®ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥
                showToast(`ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—ã—ã¾ã—ãŸ\nç·ãƒ‡ãƒ¼ã‚¿é‡: ${(totalSize / 1024 / 1024).toFixed(2)} MB / ${totalDocs}ä»¶`, 10000, 'success');
                
                // v14.02.8.5: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã‚’è¿”ã™
                const usedMB = totalSize / 1024 / 1024;
                const totalMB = 1024; // Firestoreç„¡æ–™æ : 1GB
                const usagePercentage = (usedMB / totalMB) * 100;
                
                return {
                    usedMB: usedMB,
                    totalMB: totalMB,
                    usagePercentage: usagePercentage,
                    totalDocs: totalDocs,
                    collectionStats: collectionStats
                };
                
            } catch (error) {
                console.error('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                // totalSizeElã¯tryç¯€ã§å®£è¨€æ¸ˆã¿
                if (totalSizeEl) totalSizeEl.textContent = 'ã‚¨ãƒ©ãƒ¼';
                
                // v14.02.8.5: ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚nullã§ã¯ãªãåŸºæœ¬æƒ…å ±ã‚’è¿”ã™
                return null;
            }
        }
        
        // v14.02.2: ã‚«ã‚¹ã‚¿ãƒ æ—¥ä»˜å…¥åŠ›ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleCustomDateInput() {
            const select = document.getElementById('deleteSessionPeriod');
            const customInput = document.getElementById('customDateInput');
            
            if (select && customInput) {
                customInput.style.display = select.value === 'custom' ? 'block' : 'none';
            }
        }
        
        // selectã®onchangeã§ã‚«ã‚¹ã‚¿ãƒ æ—¥ä»˜ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
        document.addEventListener('DOMContentLoaded', function() {
            const select = document.getElementById('deleteSessionPeriod');
            if (select) {
                select.addEventListener('change', toggleCustomDateInput);
            }
        });
        
        // v14.02.2: å‰Šé™¤å¯¾è±¡ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
        async function previewSessionDeletion() {
            const periodSelect = document.getElementById('deleteSessionPeriod');
            const customDateInput = document.getElementById('customDeleteDate');
            const countEl = document.getElementById('deletePreviewCount');
            const sizeEl = document.getElementById('deletePreviewSize');
            const detailsEl = document.getElementById('deletePreviewDetails');
            
            if (!periodSelect || !countEl || !sizeEl) return;
            
            // ã‚«ã‚¹ã‚¿ãƒ æ—¥ä»˜ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            toggleCustomDateInput();
            
            countEl.textContent = 'è¨ˆç®—ä¸­...';
            sizeEl.textContent = '-';
            if (detailsEl) detailsEl.textContent = '-';
            
            try {
                let cutoffDate;
                const now = Date.now();
                
                if (periodSelect.value === 'custom') {
                    if (!customDateInput || !customDateInput.value) {
                        countEl.textContent = 'æ—¥ä»˜ã‚’é¸æŠ';
                        return;
                    }
                    cutoffDate = new Date(customDateInput.value).getTime();
                } else {
                    const days = parseInt(periodSelect.value);
                    cutoffDate = now - (days * 24 * 60 * 60 * 1000);
                }
                
                // v14.02.4.1: å…¨ä»¶å–å¾—ã—ã¦JavaScriptã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸è¦ï¼‰
                const allSnapshot = await db.collection('studySessions').get();
                
                const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
                
                const completedOldDocs = [];
                const oldTimerDocs = [];
                
                allSnapshot.forEach(doc => {
                    const data = doc.data();
                    
                    // å®Œäº†ã—ãŸå¤ã„å­¦ç¿’è¨˜éŒ²
                    if (data.isComplete === true && data.startTime && data.startTime < cutoffDate) {
                        completedOldDocs.push(doc);
                    }
                    // å¤ã„ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ï¼ˆ7æ—¥ä»¥ä¸Šæ›´æ–°ãªã—ï¼‰
                    else if (data.isComplete === false && data.updatedAt) {
                        const updatedAtMs = safeToMillis(data.updatedAt);
                        if (updatedAtMs < sevenDaysAgo) {
                            oldTimerDocs.push(doc);
                        }
                    }
                });
                
                const completedCount = completedOldDocs.length;
                const oldTimerCount = oldTimerDocs.length;
                
                // åˆè¨ˆ
                const totalCount = completedCount + oldTimerCount;
                
                // ã‚µã‚¤ã‚ºã‚’æ¨å®š
                let totalSize = 0;
                
                completedOldDocs.forEach(doc => {
                    const data = doc.data();
                    const jsonStr = JSON.stringify(data);
                    const baseSize = new Blob([jsonStr]).size;
                    const overhead = 48;
                    const indexSize = baseSize * 0.25;
                    totalSize += baseSize + overhead + indexSize;
                });
                
                oldTimerDocs.forEach(doc => {
                    const data = doc.data();
                    const jsonStr = JSON.stringify(data);
                    const baseSize = new Blob([jsonStr]).size;
                    const overhead = 48;
                    const indexSize = baseSize * 0.25;
                    totalSize += baseSize + overhead + indexSize;
                });
                
                countEl.textContent = totalCount.toLocaleString() + 'ä»¶';
                
                const sizeMB = (totalSize / 1024 / 1024).toFixed(2);
                const sizeKB = (totalSize / 1024).toFixed(1);
                const displaySize = totalSize > 1024 * 1024 ? sizeMB + ' MB' : sizeKB + ' KB';
                sizeEl.textContent = displaySize + ' å‰Šæ¸›';
                
                // è©³ç´°è¡¨ç¤º
                if (detailsEl) {
                    detailsEl.innerHTML = `
                        å®Œäº†ã—ãŸå­¦ç¿’è¨˜éŒ²: ${completedCount.toLocaleString()}ä»¶<br>
                        å¤ã„ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹: ${oldTimerCount.toLocaleString()}ä»¶
                    `;
                }
                
                if (totalCount === 0) {
                    countEl.style.color = '#27ae60';
                    sizeEl.style.color = '#27ae60';
                } else {
                    countEl.style.color = '#e74c3c';
                    sizeEl.style.color = '#666';
                }
                
            } catch (error) {
                console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                countEl.textContent = 'ã‚¨ãƒ©ãƒ¼';
                sizeEl.textContent = '-';
                if (detailsEl) detailsEl.textContent = '-';
            }
        }
        
        // v14.02.4: å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å‰Šé™¤ï¼ˆå®Œäº†è¨˜éŒ²+å¤ã„ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ï¼‰
        async function deleteOldSessions() {
            const periodSelect = document.getElementById('deleteSessionPeriod');
            const customDateInput = document.getElementById('customDeleteDate');
            const countEl = document.getElementById('deletePreviewCount');
            
            if (!periodSelect || !countEl) return;
            
            const previewCount = countEl.textContent;
            
            if (previewCount === '0ä»¶' || previewCount === 'è¨ˆç®—ä¸­...' || previewCount === 'ã‚¨ãƒ©ãƒ¼') {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
            const periodText = periodSelect.value === 'custom' 
                ? customDateInput.value + 'ã‚ˆã‚Šå‰'
                : periodSelect.options[periodSelect.selectedIndex].text;
            
            if (!confirm(`${periodText}ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nå‰Šé™¤å¯¾è±¡: ${previewCount}\nï¼ˆå®Œäº†ã—ãŸå­¦ç¿’è¨˜éŒ² + å¤ã„ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ï¼‰\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                let cutoffDate;
                const now = Date.now();
                
                if (periodSelect.value === 'custom') {
                    if (!customDateInput || !customDateInput.value) {
                        showToast('æ—¥ä»˜ã‚’é¸æŠã—ã¦ãã ã•ã„', 3000, 'warning');
                        return;
                    }
                    cutoffDate = new Date(customDateInput.value).getTime();
                } else {
                    const days = parseInt(periodSelect.value);
                    cutoffDate = now - (days * 24 * 60 * 60 * 1000);
                }
                
                // v14.02.4.1: å…¨ä»¶å–å¾—ã—ã¦JavaScriptã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸è¦ï¼‰
                const allSnapshot = await db.collection('studySessions').get();
                
                const sevenDaysAgo = now - (7 * 24 * 60 * 60 * 1000);
                
                const completedOldDocs = [];
                const oldTimerDocs = [];
                
                allSnapshot.forEach(doc => {
                    const data = doc.data();
                    
                    // å®Œäº†ã—ãŸå¤ã„å­¦ç¿’è¨˜éŒ²
                    if (data.isComplete === true && data.startTime && data.startTime < cutoffDate) {
                        completedOldDocs.push(doc);
                    }
                    // å¤ã„ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹ï¼ˆ7æ—¥ä»¥ä¸Šæ›´æ–°ãªã—ï¼‰
                    else if (data.isComplete === false && data.updatedAt) {
                        const updatedAtMs = safeToMillis(data.updatedAt);
                        if (updatedAtMs < sevenDaysAgo) {
                            oldTimerDocs.push(doc);
                        }
                    }
                });
                
                const totalCount = completedOldDocs.length + oldTimerDocs.length;
                
                if (totalCount === 0) {
                    showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                    return;
                }
                
                // ãƒãƒƒãƒå‰Šé™¤
                const batchSize = 500; // Firestoreã®ãƒãƒƒãƒåˆ¶é™
                let deletedCount = 0;
                
                showToast(`å‰Šé™¤ä¸­... 0/${totalCount}ä»¶`, 1000, 'info');
                
                const allDocs = [...completedOldDocs, ...oldTimerDocs];
                const batches = [];
                let batch = db.batch();
                let operationCount = 0;
                
                allDocs.forEach((doc) => {
                    batch.delete(doc.ref);
                    operationCount++;
                    
                    if (operationCount === batchSize) {
                        batches.push(batch);
                        batch = db.batch();
                        operationCount = 0;
                    }
                });
                
                if (operationCount > 0) {
                    batches.push(batch);
                }
                
                // ãƒãƒƒãƒã‚’é †æ¬¡å®Ÿè¡Œ
                for (let i = 0; i < batches.length; i++) {
                    await batches[i].commit();
                    deletedCount += Math.min(batchSize, totalCount - deletedCount);
                    showToast(`å‰Šé™¤ä¸­... ${deletedCount}/${totalCount}ä»¶`, 1000, 'info');
                }
                
                showToast(`âœ… ${deletedCount}ä»¶ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\nï¼ˆå®Œäº†è¨˜éŒ²: ${completedOldDocs.length}ä»¶ / ã‚¿ã‚¤ãƒãƒ¼çŠ¶æ…‹: ${oldTimerDocs.length}ä»¶ï¼‰`, 10000, 'success');
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
                await previewSessionDeletion();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.3: ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆé–‹ç™ºè€…ç”¨ï¼‰
        async function createTestSessions() {
            if (!confirm('100ä»¶ã®å¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ï¼ˆ90æ—¥å‰ï¼‰ã‚’ä½œæˆã—ã¾ã™ã€‚\n\nã“ã‚Œã¯ãƒ†ã‚¹ãƒˆç”¨ã®æ©Ÿèƒ½ã§ã™ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            try {
                const testDate = Date.now() - (90 * 24 * 60 * 60 * 1000); // 90æ—¥å‰
                const batch = db.batch();
                let createdCount = 0;
                
                showToast('ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆä¸­...', 1000, 'info');
                
                // 100ä»¶ã®ãƒ†ã‚¹ãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’ä½œæˆ
                for (let i = 0; i < 100; i++) {
                    const sessionRef = db.collection('studySessions').doc();
                    const sessionData = {
                        startTime: testDate + (i * 60000), // 1åˆ†ãšã¤ãšã‚‰ã™
                        endTime: testDate + (i * 60000) + 600000, // 10åˆ†é–“
                        duration: 600000,
                        cardsStudied: Math.floor(Math.random() * 20) + 10,
                        ratings: {
                            again: Math.floor(Math.random() * 3),
                            hard: Math.floor(Math.random() * 5),
                            good: Math.floor(Math.random() * 10) + 5,
                            easy: Math.floor(Math.random() * 5)
                        },
                        deckId: 'test-deck',
                        createdAt: testDate
                    };
                    
                    batch.set(sessionRef, sessionData);
                    createdCount++;
                    
                    // Firestoreã®ãƒãƒƒãƒåˆ¶é™ã¯500ãªã®ã§å•é¡Œãªã—
                }
                
                await batch.commit();
                
                showToast(`âœ… ${createdCount}ä»¶ã®ãƒ†ã‚¹ãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’ä½œæˆã—ã¾ã—ãŸ`, 10000, 'success');
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
                await previewSessionDeletion();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
            } catch (error) {
                console.error('ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.6: ãƒ‡ãƒ¼ã‚¿å®¹é‡ã®æœ€é©åŒ– - ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒ³
        let orphanCardsData = [];
        let orphanMarkersData = [];
        let duplicateCardsData = [];
        let unusedTagsData = [];
        
        async function scanForOptimization() {
            try {
                showToast('ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒ³ä¸­...', 1000, 'info');
                
                // åˆæœŸåŒ–
                orphanCardsData = [];
                orphanMarkersData = [];
                duplicateCardsData = [];
                unusedTagsData = [];
                
                // ã™ã¹ã¦ã®ãƒ‡ãƒƒã‚­ã‚’å–å¾—
                const decksSnapshot = await db.collection('decks').get();
                const deckIds = new Set(decksSnapshot.docs.map(doc => doc.id));
                
                // ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
                const cardsSnapshot = await db.collection('flashcards').get();
                const allCards = cardsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // 1. å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã®æ¤œå‡ºï¼ˆãƒ‡ãƒƒã‚­ãŒå­˜åœ¨ã—ãªã„ã‚«ãƒ¼ãƒ‰ï¼‰
                allCards.forEach(card => {
                    if (!deckIds.has(card.deckId)) {
                        orphanCardsData.push(card);
                    }
                });
                
                // 2. PDFãƒãƒ¼ã‚«ãƒ¼ã®å­¤ç«‹æ¤œå‡ºã¯è¤‡é›‘ãªã®ã§çœç•¥ï¼ˆPDFæœ¬ä½“ãŒãªã„ãƒãƒ¼ã‚«ãƒ¼ï¼‰
                // å®Ÿéš›ã«ã¯PDFMetadataã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨ç…§åˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                const pdfMetadataSnapshot = await db.collection('pdfMetadata').get();
                const pdfHashes = new Set(pdfMetadataSnapshot.docs.map(doc => doc.id));
                
                const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                pdfMarkersSnapshot.docs.forEach(doc => {
                    const markerData = doc.data();
                    if (!pdfHashes.has(doc.id)) {
                        orphanMarkersData.push({ id: doc.id, ...markerData });
                    }
                });
                
                // 3. é‡è¤‡ã‚«ãƒ¼ãƒ‰ã®æ¤œå‡ºï¼ˆå•é¡Œã¨ç­”ãˆãŒå®Œå…¨ä¸€è‡´ï¼‰
                const cardMap = new Map();
                allCards.forEach(card => {
                    if (card.type === 'basic') {
                        const key = `${card.question.trim()}|||${card.answer.trim()}`;
                        if (!cardMap.has(key)) {
                            cardMap.set(key, []);
                        }
                        cardMap.get(key).push(card);
                    } else if (card.type === 'cloze') {
                        const key = `cloze|||${card.text.trim()}`;
                        if (!cardMap.has(key)) {
                            cardMap.set(key, []);
                        }
                        cardMap.get(key).push(card);
                    } else if (card.type === 'typing') {
                        const key = `typing|||${card.question.trim()}|||${card.answer.trim()}`;
                        if (!cardMap.has(key)) {
                            cardMap.set(key, []);
                        }
                        cardMap.get(key).push(card);
                    }
                });
                
                cardMap.forEach((cards, key) => {
                    if (cards.length > 1) {
                        duplicateCardsData.push(cards);
                    }
                });
                
                // 4. æœªä½¿ç”¨ã‚¿ã‚°ã®æ¤œå‡º
                const allTags = new Set();
                allCards.forEach(card => {
                    if (card.tags && Array.isArray(card.tags)) {
                        card.tags.forEach(tag => allTags.add(tag));
                    }
                });
                
                // ã‚¿ã‚°ãŒå®Ÿéš›ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const usedTags = new Set();
                allCards.forEach(card => {
                    if (card.tags && Array.isArray(card.tags)) {
                        card.tags.forEach(tag => usedTags.add(tag));
                    }
                });
                
                allTags.forEach(tag => {
                    if (!usedTags.has(tag)) {
                        unusedTagsData.push(tag);
                    }
                });
                
                // çµæœã‚’è¡¨ç¤º
                displayOptimizationResults();
                
                showToast('âœ… ãƒ‡ãƒ¼ã‚¿ã‚¹ã‚­ãƒ£ãƒ³ãŒå®Œäº†ã—ã¾ã—ãŸ', 10000, 'success');
                
            } catch (error) {
                console.error('ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ã‚¹ã‚­ãƒ£ãƒ³ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.6: æœ€é©åŒ–çµæœã‚’è¡¨ç¤º
        function displayOptimizationResults() {
            const resultsDiv = document.getElementById('optimizationResults');
            resultsDiv.style.display = 'block';
            
            // å­¤ç«‹ã‚«ãƒ¼ãƒ‰
            const orphanCardsSection = document.getElementById('orphanCardsSection');
            if (orphanCardsData.length > 0) {
                orphanCardsSection.style.display = 'block';
                document.getElementById('orphanCardsCount').textContent = `${orphanCardsData.length}ä»¶`;
                
                const listDiv = document.getElementById('orphanCardsList');
                listDiv.innerHTML = `
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr style="background: #f0f0f0; border-bottom: 2px solid #ddd;">
                                <th style="padding: 8px; text-align: left; width: 40%;">å•é¡Œ</th>
                                <th style="padding: 8px; text-align: left; width: 30%;">ç­”ãˆ</th>
                                <th style="padding: 8px; text-align: center; width: 15%;">ã‚¿ã‚¤ãƒ—</th>
                                <th style="padding: 8px; text-align: center; width: 15%;">æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${orphanCardsData.map((card, index) => {
                                const question = card.type === 'basic' ? card.question : 
                                               card.type === 'cloze' ? card.text : 
                                               card.question;
                                const answer = card.type === 'basic' ? card.answer : 
                                             card.type === 'typing' ? card.answer : 
                                             '(ç©´åŸ‹ã‚)';
                                const typeLabel = card.type === 'basic' ? 'åŸºæœ¬' : 
                                                card.type === 'cloze' ? 'ç©´åŸ‹ã‚' : 
                                                'ã‚¿ã‚¤ãƒ”ãƒ³ã‚°';
                                
                                return `<tr style="border-bottom: 1px solid #f0f0f0;" 
                                           onmouseover="this.style.background='#f8f9fa'" 
                                           onmouseout="this.style.background='white'">
                                    <td style="padding: 8px;" title="${question}">
                                        ${question.substring(0, 40)}${question.length > 40 ? '...' : ''}
                                    </td>
                                    <td style="padding: 8px;" title="${answer}">
                                        ${answer.substring(0, 30)}${answer.length > 30 ? '...' : ''}
                                    </td>
                                    <td style="padding: 8px; text-align: center;">
                                        <span style="background: #e3f2fd; padding: 3px 8px; border-radius: 3px; font-size: 11px;">
                                            ${typeLabel}
                                        </span>
                                    </td>
                                    <td style="padding: 8px; text-align: center;">
                                        <button onclick="moveOrphanCardToDeck(${index})" 
                                                style="background: #3498db; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-right: 3px;"
                                                title="ãƒ‡ãƒƒã‚­ã«ç§»å‹•">
                                            ğŸ“
                                        </button>
                                        <button onclick="editOrphanCard(${index})" 
                                                style="background: #f39c12; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-right: 3px;"
                                                title="ç·¨é›†">
                                            âœï¸
                                        </button>
                                        <button onclick="deleteOrphanCard(${index})" 
                                                style="background: #e74c3c; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;"
                                                title="å‰Šé™¤">
                                            ğŸ—‘ï¸
                                        </button>
                                    </td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            } else {
                orphanCardsSection.style.display = 'none';
            }
            
            // å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼
            const orphanMarkersSection = document.getElementById('orphanMarkersSection');
            if (orphanMarkersData.length > 0) {
                orphanMarkersSection.style.display = 'block';
                document.getElementById('orphanMarkersCount').textContent = `${orphanMarkersData.length}ä»¶`;
                
                const listDiv = document.getElementById('orphanMarkersList');
                listDiv.innerHTML = orphanMarkersData.slice(0, 10).map(marker => {
                    const markerCount = marker.markers ? Object.keys(marker.markers).length : 0;
                    return `<div style="padding: 5px; border-bottom: 1px solid #f0f0f0;">
                        PDF Hash: ${marker.id.substring(0, 16)}... (ãƒãƒ¼ã‚«ãƒ¼æ•°: ${markerCount})
                    </div>`;
                }).join('');
                
                if (orphanMarkersData.length > 10) {
                    listDiv.innerHTML += `<div style="padding: 5px; color: #999; font-size: 12px;">ä»– ${orphanMarkersData.length - 10}ä»¶...</div>`;
                }
            } else {
                orphanMarkersSection.style.display = 'none';
            }
            
            // é‡è¤‡ã‚«ãƒ¼ãƒ‰
            const duplicateCardsSection = document.getElementById('duplicateCardsSection');
            if (duplicateCardsData.length > 0) {
                duplicateCardsSection.style.display = 'block';
                document.getElementById('duplicateCardsCount').textContent = `${duplicateCardsData.length}ã‚°ãƒ«ãƒ¼ãƒ—`;
                
                const listDiv = document.getElementById('duplicateCardsList');
                const totalDuplicates = duplicateCardsData.reduce((sum, group) => sum + group.length - 1, 0);
                listDiv.innerHTML = `<div style="padding: 10px;">
                    ${duplicateCardsData.length}ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆåˆè¨ˆ${totalDuplicates}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚<br>
                    è©³ç´°ãƒœã‚¿ãƒ³ã‹ã‚‰ç¢ºèªãƒ»å‰Šé™¤ã§ãã¾ã™ã€‚
                </div>`;
            } else {
                duplicateCardsSection.style.display = 'none';
            }
            
            // æœªä½¿ç”¨ã‚¿ã‚°
            const unusedTagsSection = document.getElementById('unusedTagsSection');
            if (unusedTagsData.length > 0) {
                unusedTagsSection.style.display = 'block';
                document.getElementById('unusedTagsCount').textContent = `${unusedTagsData.length}ä»¶`;
                
                const listDiv = document.getElementById('unusedTagsList');
                listDiv.innerHTML = unusedTagsData.slice(0, 20).map(tag => {
                    return `<span style="display: inline-block; background: #f0f0f0; padding: 3px 8px; margin: 3px; border-radius: 3px; font-size: 12px;">${tag}</span>`;
                }).join('');
                
                if (unusedTagsData.length > 20) {
                    listDiv.innerHTML += `<div style="padding: 5px; color: #999; font-size: 12px;">ä»– ${unusedTagsData.length - 20}ä»¶...</div>`;
                }
            } else {
                unusedTagsSection.style.display = 'none';
            }
            
            // ã™ã¹ã¦æ­£å¸¸ãªå ´åˆ
            const optimizationComplete = document.getElementById('optimizationComplete');
            if (orphanCardsData.length === 0 && orphanMarkersData.length === 0 && 
                duplicateCardsData.length === 0 && unusedTagsData.length === 0) {
                optimizationComplete.style.display = 'block';
            } else {
                optimizationComplete.style.display = 'none';
            }
        }
        
        // v14.02.6.1: å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒƒã‚­ã«ç§»å‹•
        async function moveOrphanCardToDeck(index) {
            const card = orphanCardsData[index];
            if (!card) {
                showToast('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                return;
            }
            
            // ãƒ‡ãƒƒã‚­é¸æŠç”¨ã®ç°¡æ˜“ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
            const decksSnapshot = await db.collection('decks').orderBy('name').get();
            const decks = decksSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            if (decks.length === 0) {
                showToast('ç§»å‹•å…ˆã®ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«ãƒ‡ãƒƒã‚­ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚', 5000, 'error');
                return;
            }
            
            const modalHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; width: 90%;" onclick="event.stopPropagation()">
                        <h3 style="margin-bottom: 20px;">ç§»å‹•å…ˆãƒ‡ãƒƒã‚­ã‚’é¸æŠ</h3>
                        <div style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
                            ${decks.map(deck => `
                                <div style="padding: 12px; margin-bottom: 8px; border: 2px solid #ddd; border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                                     onclick="moveCardToDeckConfirm('${card.id}', '${deck.id}', '${deck.name.replace(/'/g, "\\'")}', this.closest('div[style*=\\'position: fixed\\']'))"
                                     onmouseover="this.style.background='#f0f0f0'; this.style.borderColor='#667eea'"
                                     onmouseout="this.style.background='white'; this.style.borderColor='#ddd'">
                                    <div style="font-weight: bold;">${deck.name}</div>
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                        ã‚«ãƒ¼ãƒ‰æ•°: ${deck.cardCount || 0}æš
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <button class="btn btn-secondary" onclick="this.closest('div[style*=\\'position: fixed\\']').remove()" style="width: 100%;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        // v14.02.6.1: ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‡ãƒƒã‚­ã«ç§»å‹•ç¢ºèª
        async function moveCardToDeckConfirm(cardId, deckId, deckName, modalElement) {
            try {
                await db.collection('flashcards').doc(cardId).update({
                    deckId: deckId
                });
                
                showToast(`âœ… ã‚«ãƒ¼ãƒ‰ã‚’ã€Œ${deckName}ã€ã«ç§»å‹•ã—ã¾ã—ãŸ`, 5000, 'success');
                
                modalElement.remove();
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
            } catch (error) {
                console.error('ç§»å‹•ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ç§»å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.2: å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†ï¼ˆä¿®æ­£ç‰ˆï¼‰
        async function editOrphanCard(index) {
            const card = orphanCardsData[index];
            if (!card) {
                showToast('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                return;
            }
            
            try {
                // ã‚«ãƒ¼ãƒ‰ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«å€¤ã‚’è¨­å®š
                document.getElementById('editDeckId').value = card.deckId || '';
                
                // ã‚¿ã‚°ã‚’èª­ã¿è¾¼ã‚€
                const tags = card.tags || [];
                document.getElementById('editCardTags').value = tags.join(' ');
                
                // å…¨å…¥åŠ›ã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤º
                document.getElementById('editBasicInputs').style.display = 'none';
                document.getElementById('editClozeInputs').style.display = 'none';
                document.getElementById('editTypingInputs').style.display = 'none';
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦è¡¨ç¤º
                if (card.type === 'typing') {
                    document.getElementById('editCardType').value = 'typing';
                    document.getElementById('editTypingInputs').style.display = 'block';
                    document.getElementById('editTypingQuestion').value = card.question;
                    const answer = card.answer || (card.answers && card.answers[0]) || '';
                    document.getElementById('editTypingAnswer').value = answer;
                    document.getElementById('editTypingCaseSensitive').checked = card.caseSensitive || false;
                } else if (card.type === 'cloze') {
                    document.getElementById('editCardType').value = 'cloze';
                    document.getElementById('editClozeInputs').style.display = 'block';
                    document.getElementById('editClozeText').value = card.text;
                    updateEditClozePreview();
                } else {
                    document.getElementById('editCardType').value = 'basic';
                    document.getElementById('editBasicInputs').style.display = 'block';
                    document.getElementById('editQuestion').value = card.question;
                    document.getElementById('editAnswer').value = card.answer;
                    // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®æœ‰ç„¡ã§åˆ¤å®š
                    document.getElementById('editEnableReverse').checked = !!card.reverseCardId;
                }
                
                // ç·¨é›†ä¸­ã®ã‚«ãƒ¼ãƒ‰IDã‚’è¨­å®š
                editingCardId = card.id;
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                document.getElementById('cardEditModal').style.display = 'block';
                
            } catch (error) {
                console.error('ç·¨é›†ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ã‚«ãƒ¼ãƒ‰ç·¨é›†ã®æº–å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.1: å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å€‹åˆ¥å‰Šé™¤
        async function deleteOrphanCard(index) {
            const card = orphanCardsData[index];
            if (!card) {
                showToast('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                return;
            }
            
            const question = card.type === 'basic' ? card.question : 
                           card.type === 'cloze' ? card.text : 
                           card.question;
            
            if (!confirm(`ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nå•é¡Œ: ${question.substring(0, 50)}${question.length > 50 ? '...' : ''}\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                await db.collection('flashcards').doc(card.id).delete();
                
                showToast('âœ… ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 3000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.1: ã™ã¹ã¦ã®å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ï¼ˆå…ƒã®deleteOrphanCardsï¼‰
        async function deleteAllOrphanCards() {
            if (orphanCardsData.length === 0) {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            if (!confirm(`${orphanCardsData.length}ä»¶ã®å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                showToast('å‰Šé™¤ä¸­...', 1000, 'info');
                
                const batchSize = 500;
                const batches = [];
                let batch = db.batch();
                let operationCount = 0;
                let deletedCount = 0;
                
                orphanCardsData.forEach(card => {
                    const cardRef = db.collection('flashcards').doc(card.id);
                    batch.delete(cardRef);
                    operationCount++;
                    
                    if (operationCount >= batchSize) {
                        batches.push(batch);
                        batch = db.batch();
                        operationCount = 0;
                    }
                });
                
                if (operationCount > 0) {
                    batches.push(batch);
                }
                
                // ãƒãƒƒãƒã‚’é †æ¬¡å®Ÿè¡Œ
                for (let i = 0; i < batches.length; i++) {
                    await batches[i].commit();
                    deletedCount += Math.min(batchSize, orphanCardsData.length - deletedCount);
                    showToast(`å‰Šé™¤ä¸­... ${deletedCount}/${orphanCardsData.length}ä»¶`, 1000, 'info');
                }
                
                showToast(`âœ… ${deletedCount}ä»¶ã®å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 10000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.6: å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤
        async function deleteOrphanMarkers() {
            if (orphanMarkersData.length === 0) {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            if (!confirm(`${orphanMarkersData.length}ä»¶ã®å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                showToast('å‰Šé™¤ä¸­...', 1000, 'info');
                
                const batchSize = 500;
                const batches = [];
                let batch = db.batch();
                let operationCount = 0;
                let deletedCount = 0;
                
                orphanMarkersData.forEach(marker => {
                    const markerRef = db.collection('pdfMarkers').doc(marker.id);
                    batch.delete(markerRef);
                    operationCount++;
                    
                    if (operationCount >= batchSize) {
                        batches.push(batch);
                        batch = db.batch();
                        operationCount = 0;
                    }
                });
                
                if (operationCount > 0) {
                    batches.push(batch);
                }
                
                // ãƒãƒƒãƒã‚’é †æ¬¡å®Ÿè¡Œ
                for (let i = 0; i < batches.length; i++) {
                    await batches[i].commit();
                    deletedCount += Math.min(batchSize, orphanMarkersData.length - deletedCount);
                    showToast(`å‰Šé™¤ä¸­... ${deletedCount}/${orphanMarkersData.length}ä»¶`, 1000, 'info');
                }
                
                showToast(`âœ… ${deletedCount}ä»¶ã®å­¤ç«‹PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 10000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.6.1: é‡è¤‡ã‚«ãƒ¼ãƒ‰ã®è©³ç´°ã‚’è¡¨ç¤ºï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã§ï¼‰- æ”¹å–„ç‰ˆ
        async function showDuplicateCardsDetail() {
            if (duplicateCardsData.length === 0) {
                showToast('é‡è¤‡ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            // ãƒ‡ãƒƒã‚­æƒ…å ±ã‚’å–å¾—
            const decksSnapshot = await db.collection('decks').get();
            const decksMap = {};
            decksSnapshot.docs.forEach(doc => {
                decksMap[doc.id] = doc.data().name;
            });
            
            let html = '<div style="max-height: 500px; overflow-y: auto;">';
            
            duplicateCardsData.forEach((group, groupIndex) => {
                const firstCard = group[0];
                const question = firstCard.type === 'basic' ? firstCard.question : 
                               firstCard.type === 'cloze' ? firstCard.text : 
                               firstCard.question;
                const answer = firstCard.type === 'basic' ? firstCard.answer : 
                             firstCard.type === 'typing' ? firstCard.answer : '';
                
                // æœ€ã‚‚å­¦ç¿’ãŒé€²ã‚“ã§ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’åˆ¤å®šï¼ˆeaseã¨intervalã§ï¼‰
                let bestCardIndex = 0;
                let bestScore = 0;
                group.forEach((card, index) => {
                    const score = (card.ease || 2500) * (card.interval || 1);
                    if (score > bestScore) {
                        bestScore = score;
                        bestCardIndex = index;
                    }
                });
                
                html += `<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-weight: bold; color: #667eea; margin-bottom: 10px; font-size: 16px;">
                        ã‚°ãƒ«ãƒ¼ãƒ— ${groupIndex + 1}ï¼ˆ${group.length}æšã®é‡è¤‡ï¼‰
                    </div>
                    
                    <!-- å•é¡Œãƒ»ç­”ãˆã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
                    <div style="background: white; padding: 12px; border-radius: 5px; margin-bottom: 15px; border-left: 4px solid #667eea;">
                        <div style="font-size: 13px; color: #666; margin-bottom: 5px; font-weight: bold;">å•é¡Œ:</div>
                        <div style="font-size: 14px; margin-bottom: 10px;">${question}</div>
                        ${answer ? `<div style="font-size: 13px; color: #666; margin-bottom: 5px; font-weight: bold;">ç­”ãˆ:</div>
                        <div style="font-size: 14px;">${answer}</div>` : ''}
                    </div>
                    
                    <!-- å„ã‚«ãƒ¼ãƒ‰ã®è©³ç´° -->
                    <div style="margin-bottom: 15px;">
                        <div style="font-weight: bold; color: #333; margin-bottom: 10px; font-size: 14px;">å„ã‚«ãƒ¼ãƒ‰ã®è©³ç´°:</div>
                        ${group.map((card, cardIndex) => {
                            const deckName = decksMap[card.deckId] || 'ä¸æ˜ãªãƒ‡ãƒƒã‚­';
                            const ease = card.ease || 2500;
                            const interval = card.interval || 1;
                            const lapses = card.lapses || 0;
                            const reviews = card.reviews || 0;
                            const isBest = cardIndex === bestCardIndex;
                            
                            return `<div style="background: ${isBest ? '#e8f5e9' : 'white'}; padding: 12px; border-radius: 5px; margin-bottom: 8px; border: 2px solid ${isBest ? '#4caf50' : '#ddd'}; position: relative;">
                                ${isBest ? '<div style="position: absolute; top: 8px; right: 8px; background: #4caf50; color: white; padding: 3px 8px; border-radius: 3px; font-size: 11px; font-weight: bold;">æ¨å¥¨</div>' : ''}
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                                    <div>
                                        <div style="font-size: 12px; color: #666;">ãƒ‡ãƒƒã‚­</div>
                                        <div style="font-size: 13px; font-weight: bold; color: #333;">${deckName}</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 12px; color: #666;">å¾©ç¿’å›æ•°</div>
                                        <div style="font-size: 13px; font-weight: bold; color: #333;">${reviews}å›</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 12px; color: #666;">é›£æ˜“åº¦ä¿‚æ•°</div>
                                        <div style="font-size: 13px; font-weight: bold; color: #333;">${(ease / 1000).toFixed(2)}</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 12px; color: #666;">å¾©ç¿’é–“éš”</div>
                                        <div style="font-size: 13px; font-weight: bold; color: #333;">${interval}æ—¥</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 12px; color: #666;">å¿˜å´å›æ•°</div>
                                        <div style="font-size: 13px; font-weight: bold; color: #333;">${lapses}å›</div>
                                    </div>
                                    <div>
                                        <div style="font-size: 12px; color: #666;">ID</div>
                                        <div style="font-size: 11px; color: #999;">${card.id.substring(0, 12)}...</div>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    <button onclick="keepThisCard(${groupIndex}, ${cardIndex})" 
                                            style="flex: 1; background: #4caf50; color: white; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;">
                                        âœ“ ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’æ®‹ã™
                                    </button>
                                    <button onclick="editDuplicateCard(${groupIndex}, ${cardIndex})" 
                                            style="background: #f39c12; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;"
                                            title="ç·¨é›†">
                                        âœï¸
                                    </button>
                                    <button onclick="deleteSingleDuplicateCard(${groupIndex}, ${cardIndex})" 
                                            style="background: #e74c3c; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;"
                                            title="å‰Šé™¤">
                                        ğŸ—‘ï¸
                                    </button>
                                </div>
                            </div>`;
                        }).join('')}
                    </div>
                    
                    <div style="font-size: 12px; color: #666; background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                        ğŸ’¡ ãƒ’ãƒ³ãƒˆ: ã€Œæ¨å¥¨ã€ãƒãƒ¼ã‚¯ã¯å­¦ç¿’ãŒæœ€ã‚‚é€²ã‚“ã§ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã§ã™ã€‚
                    </div>
                    
                    <button class="btn btn-danger" onclick="deleteDuplicateGroup(${groupIndex})" style="width: 100%;">
                        ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®é‡è¤‡ã‚’å‰Šé™¤ï¼ˆæ¨å¥¨ã‚«ãƒ¼ãƒ‰ä»¥å¤–ã®${group.length - 1}æšã‚’å‰Šé™¤ï¼‰
                    </button>
                </div>`;
            });
            
            html += '</div>';
            html += `<button class="btn" onclick="deleteAllDuplicates()" style="margin-top: 20px; width: 100%; background: #e74c3c; border-color: #e74c3c;">
                ã™ã¹ã¦ã®é‡è¤‡ã‚’å‰Šé™¤ï¼ˆåˆè¨ˆ${duplicateCardsData.reduce((sum, group) => sum + group.length - 1, 0)}æšï¼‰
            </button>`;
            
            // ç°¡æ˜“ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
            const modalHtml = `
                <div id="duplicateCardsModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 900px; width: 90%; max-height: 90%; overflow-y: auto;" onclick="event.stopPropagation()">
                        <h2 style="margin-bottom: 20px;">é‡è¤‡ã‚«ãƒ¼ãƒ‰ã®è©³ç´°</h2>
                        ${html}
                        <button class="btn btn-secondary" onclick="this.closest('div[style*=\\'position: fixed\\']').remove()" style="margin-top: 20px; width: 100%;">é–‰ã˜ã‚‹</button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        // v14.02.6.1: ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’æ®‹ã™ï¼ˆä»–ã‚’å‰Šé™¤ï¼‰
        async function keepThisCard(groupIndex, cardIndex) {
            const group = duplicateCardsData[groupIndex];
            if (!group || group.length <= 1) {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            const keepCard = group[cardIndex];
            const cardsToDelete = group.filter((_, index) => index !== cardIndex);
            
            if (!confirm(`é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ä»¥å¤–ã®${cardsToDelete.length}æšã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                showToast('å‰Šé™¤ä¸­...', 1000, 'info');
                
                const batch = db.batch();
                cardsToDelete.forEach(card => {
                    const cardRef = db.collection('flashcards').doc(card.id);
                    batch.delete(cardRef);
                });
                
                await batch.commit();
                
                showToast(`âœ… ${cardsToDelete.length}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 5000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                document.getElementById('duplicateCardsModal')?.remove();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.3: é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«é‡ãªã‚Šå•é¡Œã‚’ä¿®æ­£ï¼‰
        async function editDuplicateCard(groupIndex, cardIndex) {
            const group = duplicateCardsData[groupIndex];
            const card = group[cardIndex];
            if (!card) {
                showToast('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                return;
            }
            
            try {
                // é‡è¤‡ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤º
                const duplicateModal = document.getElementById('duplicateCardsModal');
                if (duplicateModal) {
                    duplicateModal.style.display = 'none';
                }
                
                // ã‚«ãƒ¼ãƒ‰ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«å€¤ã‚’è¨­å®š
                document.getElementById('editDeckId').value = card.deckId || '';
                
                // ã‚¿ã‚°ã‚’èª­ã¿è¾¼ã‚€
                const tags = card.tags || [];
                document.getElementById('editCardTags').value = tags.join(' ');
                
                // å…¨å…¥åŠ›ã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤º
                document.getElementById('editBasicInputs').style.display = 'none';
                document.getElementById('editClozeInputs').style.display = 'none';
                document.getElementById('editTypingInputs').style.display = 'none';
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦è¡¨ç¤º
                if (card.type === 'typing') {
                    document.getElementById('editCardType').value = 'typing';
                    document.getElementById('editTypingInputs').style.display = 'block';
                    document.getElementById('editTypingQuestion').value = card.question;
                    const answer = card.answer || (card.answers && card.answers[0]) || '';
                    document.getElementById('editTypingAnswer').value = answer;
                    document.getElementById('editTypingCaseSensitive').checked = card.caseSensitive || false;
                } else if (card.type === 'cloze') {
                    document.getElementById('editCardType').value = 'cloze';
                    document.getElementById('editClozeInputs').style.display = 'block';
                    document.getElementById('editClozeText').value = card.text;
                    updateEditClozePreview();
                } else {
                    document.getElementById('editCardType').value = 'basic';
                    document.getElementById('editBasicInputs').style.display = 'block';
                    document.getElementById('editQuestion').value = card.question;
                    document.getElementById('editAnswer').value = card.answer;
                    // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®æœ‰ç„¡ã§åˆ¤å®š
                    document.getElementById('editEnableReverse').checked = !!card.reverseCardId;
                }
                
                // ç·¨é›†ä¸­ã®ã‚«ãƒ¼ãƒ‰IDã‚’è¨­å®š
                editingCardId = card.id;
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                document.getElementById('cardEditModal').style.display = 'block';
                
                // ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‰ã˜ã‚‰ã‚ŒãŸã¨ãã«é‡è¤‡ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å†è¡¨ç¤º
                // closeCardEditModalã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã¯é¿ã‘ã€ä¿å­˜å¾Œã«å†ã‚¹ã‚­ãƒ£ãƒ³ã§å¯¾å¿œ
                
            } catch (error) {
                console.error('ç·¨é›†ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ã‚«ãƒ¼ãƒ‰ç·¨é›†ã®æº–å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.1: é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å€‹åˆ¥å‰Šé™¤
        async function deleteSingleDuplicateCard(groupIndex, cardIndex) {
            const group = duplicateCardsData[groupIndex];
            const card = group[cardIndex];
            if (!card) {
                showToast('ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                return;
            }
            
            if (group.length <= 2) {
                showToast('âš ï¸ ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¯2æšã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚1æšå‰Šé™¤ã™ã‚‹ã¨é‡è¤‡ã§ã¯ãªããªã‚Šã¾ã™ã€‚', 5000, 'warning');
            }
            
            if (!confirm('ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            try {
                await db.collection('flashcards').doc(card.id).delete();
                
                showToast('âœ… ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 3000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                document.getElementById('duplicateCardsModal')?.remove();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.6.1: ç‰¹å®šã‚°ãƒ«ãƒ¼ãƒ—ã®é‡è¤‡ã‚’å‰Šé™¤ï¼ˆæ¨å¥¨ã‚«ãƒ¼ãƒ‰ã‚’æ®‹ã™ï¼‰
        async function deleteDuplicateGroup(groupIndex) {
            const group = duplicateCardsData[groupIndex];
            if (!group || group.length <= 1) {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            // æœ€ã‚‚å­¦ç¿’ãŒé€²ã‚“ã§ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’åˆ¤å®šï¼ˆeaseã¨intervalã§ï¼‰
            let bestCardIndex = 0;
            let bestScore = 0;
            group.forEach((card, index) => {
                const score = (card.ease || 2500) * (card.interval || 1);
                if (score > bestScore) {
                    bestScore = score;
                    bestCardIndex = index;
                }
            });
            
            const keepCard = group[bestCardIndex];
            const cardsToDelete = group.filter((_, index) => index !== bestCardIndex);
            
            if (!confirm(`${cardsToDelete.length}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\næœ€ã‚‚å­¦ç¿’ãŒé€²ã‚“ã§ã„ã‚‹1æšï¼ˆease: ${((keepCard.ease || 2500) / 1000).toFixed(2)}, interval: ${keepCard.interval || 1}æ—¥ï¼‰ã‚’æ®‹ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                const batch = db.batch();
                cardsToDelete.forEach(card => {
                    const cardRef = db.collection('flashcards').doc(card.id);
                    batch.delete(cardRef);
                });
                
                await batch.commit();
                
                showToast(`âœ… ${cardsToDelete.length}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 10000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                document.getElementById('duplicateCardsModal')?.remove();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.6.1: ã™ã¹ã¦ã®é‡è¤‡ã‚’å‰Šé™¤ï¼ˆå„ã‚°ãƒ«ãƒ¼ãƒ—ã§æ¨å¥¨ã‚«ãƒ¼ãƒ‰ã‚’æ®‹ã™ï¼‰
        async function deleteAllDuplicates() {
            if (duplicateCardsData.length === 0) {
                showToast('å‰Šé™¤å¯¾è±¡ãŒã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            const totalToDelete = duplicateCardsData.reduce((sum, group) => sum + group.length - 1, 0);
            
            if (!confirm(`${totalToDelete}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nå„ã‚°ãƒ«ãƒ¼ãƒ—ã§æœ€ã‚‚å­¦ç¿’ãŒé€²ã‚“ã§ã„ã‚‹1æšã ã‘ãŒæ®‹ã‚Šã¾ã™ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                showToast('å‰Šé™¤ä¸­...', 1000, 'info');
                
                const batchSize = 500;
                const batches = [];
                let batch = db.batch();
                let operationCount = 0;
                let deletedCount = 0;
                
                duplicateCardsData.forEach(group => {
                    // æœ€ã‚‚å­¦ç¿’ãŒé€²ã‚“ã§ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’åˆ¤å®šï¼ˆeaseã¨intervalã§ï¼‰
                    let bestCardIndex = 0;
                    let bestScore = 0;
                    group.forEach((card, index) => {
                        const score = (card.ease || 2500) * (card.interval || 1);
                        if (score > bestScore) {
                            bestScore = score;
                            bestCardIndex = index;
                        }
                    });
                    
                    // æ¨å¥¨ã‚«ãƒ¼ãƒ‰ä»¥å¤–ã‚’å‰Šé™¤
                    const cardsToDelete = group.filter((_, index) => index !== bestCardIndex);
                    cardsToDelete.forEach(card => {
                        const cardRef = db.collection('flashcards').doc(card.id);
                        batch.delete(cardRef);
                        operationCount++;
                        
                        if (operationCount >= batchSize) {
                            batches.push(batch);
                            batch = db.batch();
                            operationCount = 0;
                        }
                    });
                });
                
                if (operationCount > 0) {
                    batches.push(batch);
                }
                
                // ãƒãƒƒãƒã‚’é †æ¬¡å®Ÿè¡Œ
                for (let i = 0; i < batches.length; i++) {
                    await batches[i].commit();
                    deletedCount += Math.min(batchSize, totalToDelete - deletedCount);
                    showToast(`å‰Šé™¤ä¸­... ${deletedCount}/${totalToDelete}ä»¶`, 1000, 'info');
                }
                
                showToast(`âœ… ${deletedCount}æšã®é‡è¤‡ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 10000, 'success');
                
                // å†ã‚¹ã‚­ãƒ£ãƒ³
                await scanForOptimization();
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å†è¨ˆç®—
                await calculateStorageUsage();
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                document.getElementById('duplicateCardsModal')?.remove();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š
        let autoBackupSettings = {
            enabled: false,
            frequency: 1, // æ—¥æ•°
            maxBackups: 5,
            lastBackupTime: null,
            nextBackupTime: null
        };
        
        // v14.02.7: IndexedDBåˆæœŸåŒ–
        let backupDB = null;
        
        async function initBackupDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MyAnkiAppBackups', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    backupDB = request.result;
                    resolve(backupDB);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('backups')) {
                        const objectStore = db.createObjectStore('backups', { keyPath: 'id', autoIncrement: true });
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        objectStore.createIndex('type', 'type', { unique: false });
                    }
                };
            });
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã‚’èª­ã¿è¾¼ã‚€
        async function loadAutoBackupSettings() {
            const settings = localStorage.getItem('autoBackupSettings');
            if (settings) {
                // v16.00.00: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨ãƒãƒ¼ã‚¸ã—ã¦èª­ã¿è¾¼ã¿
                const savedSettings = JSON.parse(settings);
                autoBackupSettings = {
                    enabled: false,
                    frequency: 1,
                    maxBackups: 5,
                    lastBackupTime: null,
                    nextBackupTime: null,
                    ...savedSettings // ä¿å­˜ã•ã‚ŒãŸå€¤ã§ä¸Šæ›¸ã
                };
                
                // UIæ›´æ–°
                document.getElementById('autoBackupEnabled').checked = autoBackupSettings.enabled;
                document.getElementById('backupFrequency').value = autoBackupSettings.frequency;
                document.getElementById('maxBackups').value = autoBackupSettings.maxBackups;
                
                if (autoBackupSettings.enabled) {
                    document.getElementById('autoBackupSettings').style.display = 'block';
                }
                
                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹ã‚’æ›´æ–°
                updateBackupStatus();
                
                // è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
                if (autoBackupSettings.enabled) {
                    checkAndExecuteAutoBackup();
                }
            }
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šã‚’ä¿å­˜
        function saveAutoBackupSettings() {
            // v16.00.00: ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ã‚’èª­ã¿å–ã£ã¦ä¿å­˜
            const maxBackupsSelect = document.getElementById('maxBackups');
            const backupFrequencySelect = document.getElementById('backupFrequency');
            
            if (maxBackupsSelect) {
                const value = maxBackupsSelect.value;
                autoBackupSettings.maxBackups = value === 'unlimited' ? 'unlimited' : parseInt(value);
            }
            
            if (backupFrequencySelect && backupFrequencySelect.value !== 'custom') {
                autoBackupSettings.frequency = parseInt(backupFrequencySelect.value);
            }
            
            localStorage.setItem('autoBackupSettings', JSON.stringify(autoBackupSettings));
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ON/OFFåˆ‡ã‚Šæ›¿ãˆ
        function toggleAutoBackup() {
            const enabled = document.getElementById('autoBackupEnabled').checked;
            autoBackupSettings.enabled = enabled;
            
            if (enabled) {
                document.getElementById('autoBackupSettings').style.display = 'block';
                updateBackupSchedule();
                showToast('âœ… è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ', 5000, 'success');
            } else {
                document.getElementById('autoBackupSettings').style.display = 'none';
                showToast('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ', 3000, 'info');
            }
            
            saveAutoBackupSettings();
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›´æ–°
        function updateBackupSchedule() {
            const frequency = document.getElementById('backupFrequency').value;
            
            if (frequency === 'custom') {
                document.getElementById('customFrequencyInput').style.display = 'block';
                autoBackupSettings.frequency = parseInt(document.getElementById('customFrequencyDays').value) || 1;
            } else {
                document.getElementById('customFrequencyInput').style.display = 'none';
                autoBackupSettings.frequency = parseInt(frequency);
            }
            
            // æ¬¡å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ™‚åˆ»ã‚’è¨ˆç®—
            if (autoBackupSettings.lastBackupTime) {
                const nextTime = new Date(autoBackupSettings.lastBackupTime);
                nextTime.setDate(nextTime.getDate() + autoBackupSettings.frequency);
                autoBackupSettings.nextBackupTime = nextTime.getTime();
            } else {
                // åˆå›ã¯ä»Šã™ã
                autoBackupSettings.nextBackupTime = Date.now();
            }
            
            saveAutoBackupSettings();
            updateBackupStatus();
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹ã‚’è¡¨ç¤ºæ›´æ–°
        async function updateBackupStatus() {
            // æœ€çµ‚ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ™‚åˆ»
            if (autoBackupSettings.lastBackupTime) {
                const lastTime = new Date(autoBackupSettings.lastBackupTime);
                document.getElementById('lastBackupTime').textContent = 
                    `${lastTime.getFullYear()}/${(lastTime.getMonth() + 1).toString().padStart(2, '0')}/${lastTime.getDate().toString().padStart(2, '0')} ` +
                    `${lastTime.getHours().toString().padStart(2, '0')}:${lastTime.getMinutes().toString().padStart(2, '0')}`;
            } else {
                document.getElementById('lastBackupTime').textContent = 'æœªå®Ÿè¡Œ';
            }
            
            // æ¬¡å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—äºˆå®š
            if (autoBackupSettings.nextBackupTime) {
                const nextTime = new Date(autoBackupSettings.nextBackupTime);
                const now = Date.now();
                
                if (nextTime.getTime() <= now) {
                    document.getElementById('nextBackupTime').textContent = 'å®Ÿè¡Œäºˆå®š';
                    document.getElementById('nextBackupTime').style.color = '#f39c12';
                } else {
                    document.getElementById('nextBackupTime').textContent = 
                        `${nextTime.getFullYear()}/${(nextTime.getMonth() + 1).toString().padStart(2, '0')}/${nextTime.getDate().toString().padStart(2, '0')} ` +
                        `${nextTime.getHours().toString().padStart(2, '0')}:${nextTime.getMinutes().toString().padStart(2, '0')}`;
                    document.getElementById('nextBackupTime').style.color = '#333';
                }
            } else {
                document.getElementById('nextBackupTime').textContent = '-';
            }
            
            // ä¿å­˜æ¸ˆã¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°
            try {
                if (!backupDB) await initBackupDB();
                const count = await getBackupCount();
                document.getElementById('savedBackupsCount').textContent = `${count}å€‹`;
            } catch (error) {
                console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°ã‚’å–å¾—
        function getBackupCount() {
            return new Promise((resolve, reject) => {
                const transaction = backupDB.transaction(['backups'], 'readonly');
                const objectStore = transaction.objectStore('backups');
                const countRequest = objectStore.count();
                
                countRequest.onsuccess = () => resolve(countRequest.result);
                countRequest.onerror = () => reject(countRequest.error);
            });
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å®Ÿè¡Œ
        async function checkAndExecuteAutoBackup() {
            if (!autoBackupSettings.enabled) return;
            
            const now = Date.now();
            
            // æ¬¡å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ™‚åˆ»ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã€ã¾ãŸã¯æ™‚åˆ»ã‚’éãã¦ã„ã‚‹å ´åˆ
            if (!autoBackupSettings.nextBackupTime || autoBackupSettings.nextBackupTime <= now) {
                await createAutoBackup();
            }
        }
        
        // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        async function createAutoBackup() {
            try {
                showToast('ğŸ”„ è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆä¸­...', 2000, 'info');
                
                const backupData = await collectBackupData();
                
                // IndexedDBã«ä¿å­˜
                await saveBackupToIndexedDB(backupData, 'auto');
                
                // è¨­å®šã‚’æ›´æ–°
                autoBackupSettings.lastBackupTime = Date.now();
                const nextTime = new Date(autoBackupSettings.lastBackupTime);
                nextTime.setDate(nextTime.getDate() + autoBackupSettings.frequency);
                autoBackupSettings.nextBackupTime = nextTime.getTime();
                saveAutoBackupSettings();
                
                // å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
                await cleanupOldBackups();
                
                // UIæ›´æ–°
                await updateBackupStatus();
                
                showToast('âœ… è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ', 5000, 'success');
                
            } catch (error) {
                console.error('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.7: æ‰‹å‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        async function createManualBackup() {
            try {
                showToast('ğŸ”„ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆä¸­...', 2000, 'info');
                
                const backupData = await collectBackupData();
                
                // IndexedDBã«ä¿å­˜
                await saveBackupToIndexedDB(backupData, 'manual');
                
                // UIæ›´æ–°
                await updateBackupStatus();
                
                showToast('âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ', 5000, 'success');
                
            } catch (error) {
                console.error('æ‰‹å‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
        async function collectBackupData() {
            // 1. Firestoreã‹ã‚‰ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const decksSnapshot = await db.collection('decks').orderBy('order').get();
            const flashcardsSnapshot = await db.collection('flashcards').get();
            const studySessionsSnapshot = await db.collection('studySessions').get();
            const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’é…åˆ—ã«å¤‰æ›
            const decks = [];
            decksSnapshot.forEach(doc => {
                decks.push({ id: doc.id, ...doc.data() });
            });
            
            const flashcards = [];
            flashcardsSnapshot.forEach(doc => {
                flashcards.push({ id: doc.id, ...doc.data() });
            });
            
            const studySessions = [];
            studySessionsSnapshot.forEach(doc => {
                studySessions.push({ id: doc.id, ...doc.data() });
            });
            
            const pdfMarkers = [];
            const pdfMetadata = [];
            pdfMarkersSnapshot.forEach(doc => {
                const data = doc.data();
                pdfMarkers.push({ 
                    pdfHash: doc.id, 
                    ...data 
                });
                // PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å¯¾å¿œè¡¨
                if (data.fileName) {
                    pdfMetadata.push({
                        pdfHash: doc.id,
                        fileName: data.fileName,
                        totalPages: data.totalPages || 0,
                        fileSize: data.fileSize || 0
                    });
                }
            });
            
            // 2. localStorageã‹ã‚‰è¨­å®šã‚’å–å¾—
            const settings = {
                theme: localStorage.getItem('theme') || 'light',
                fontSize: localStorage.getItem('fontSize') || 'medium',
                customColors: localStorage.getItem('customColors') || null,
                deckStudySettings: localStorage.getItem('deckStudySettings') || null,
                globalStudySettings: localStorage.getItem('globalStudySettings') || null,
                collapsedDecks: localStorage.getItem('collapsedDecks') || '{}',
                cardsPerPage: localStorage.getItem('cardsPerPage') || '50',
                lastSelectedDeckId: localStorage.getItem('lastSelectedDeckId') || null,
                instantDeleteMode: localStorage.getItem('instantDeleteMode') || 'false'
            };
            
            // 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
            return {
                version: '1.0',
                userId: null,
                exportDate: new Date().toISOString(),
                appVersion: 'v14.02.8.5',
                data: {
                    decks: decks,
                    flashcards: flashcards,
                    studySessions: studySessions,
                    pdfMarkers: pdfMarkers,
                    pdfMetadata: pdfMetadata
                },
                settings: settings,
                stats: {
                    deckCount: decks.length,
                    cardCount: flashcards.length,
                    sessionCount: studySessions.length,
                    pdfCount: pdfMarkers.length
                }
            };
        }
        
        // v14.02.7: IndexedDBã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¿å­˜
        function saveBackupToIndexedDB(backupData, type) {
            return new Promise((resolve, reject) => {
                const transaction = backupDB.transaction(['backups'], 'readwrite');
                const objectStore = transaction.objectStore('backups');
                
                const backup = {
                    timestamp: Date.now(),
                    type: type, // 'auto' ã¾ãŸã¯ 'manual'
                    data: backupData,
                    size: JSON.stringify(backupData).length
                };
                
                const request = objectStore.add(backup);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        // v14.02.7: å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
        async function cleanupOldBackups() {
            if (autoBackupSettings.maxBackups === 'unlimited') return;
            
            const maxBackups = parseInt(autoBackupSettings.maxBackups);
            
            try {
                const backups = await getAllBackups();
                
                // è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ã¿ã‚’å¯¾è±¡
                const autoBackups = backups.filter(b => b.type === 'auto');
                
                if (autoBackups.length > maxBackups) {
                    // å¤ã„é †ã«ã‚½ãƒ¼ãƒˆ
                    autoBackups.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // å‰Šé™¤å¯¾è±¡
                    const toDelete = autoBackups.slice(0, autoBackups.length - maxBackups);
                    
                    for (const backup of toDelete) {
                        await deleteBackupFromIndexedDB(backup.id);
                    }
                }
            } catch (error) {
                console.error('å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // v14.02.7: ã™ã¹ã¦ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–å¾—
        function getAllBackups() {
            return new Promise((resolve, reject) => {
                const transaction = backupDB.transaction(['backups'], 'readonly');
                const objectStore = transaction.objectStore('backups');
                const request = objectStore.openCursor();
                
                const backups = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        backups.push({
                            id: cursor.key,
                            ...cursor.value
                        });
                        cursor.continue();
                    } else {
                        // æ–°ã—ã„é †ã«ã‚½ãƒ¼ãƒˆ
                        backups.sort((a, b) => b.timestamp - a.timestamp);
                        resolve(backups);
                    }
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’IndexedDBã‹ã‚‰å‰Šé™¤
        function deleteBackupFromIndexedDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = backupDB.transaction(['backups'], 'readwrite');
                const objectStore = transaction.objectStore('backups');
                const request = objectStore.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã‚’èª­ã¿è¾¼ã‚“ã§è¡¨ç¤º
        async function loadBackupList() {
            try {
                showToast('ğŸ”„ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã‚’èª­ã¿è¾¼ã¿ä¸­...', 1000, 'info');
                
                if (!backupDB) await initBackupDB();
                
                const backups = await getAllBackups();
                
                const listContainer = document.getElementById('backupListContainer');
                const listDiv = document.getElementById('backupList');
                
                if (backups.length === 0) {
                    listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #999;">ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ã‚ã‚Šã¾ã›ã‚“</div>';
                } else {
                    listDiv.innerHTML = backups.map(backup => {
                        const date = new Date(backup.timestamp);
                        const dateStr = `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')} ` +
                                      `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
                        const sizeKB = (backup.size / 1024).toFixed(2);
                        const typeBadge = backup.type === 'auto' ? 
                            '<span style="background: #2196f3; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px;">è‡ªå‹•</span>' :
                            '<span style="background: #4caf50; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px;">æ‰‹å‹•</span>';
                        
                        const stats = backup.data?.stats || {};
                        const statsStr = `ã‚«ãƒ¼ãƒ‰: ${stats.cardCount || 0}æš / ãƒ‡ãƒƒã‚­: ${stats.deckCount || 0}å€‹`;
                        
                        return `<div style="border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 10px; position: relative;">
                            <label style="display: flex; align-items: flex-start; gap: 15px; cursor: pointer;">
                                <input type="checkbox" class="backup-checkbox" data-backup-id="${backup.id}" style="margin-top: 5px; width: 18px; height: 18px; cursor: pointer;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                        <div style="font-weight: bold; font-size: 14px;">${dateStr}</div>
                                        ${typeBadge}
                                    </div>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">${statsStr}</div>
                                    <div style="font-size: 12px; color: #999;">ã‚µã‚¤ã‚º: ${sizeKB} KB</div>
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    <button onclick="event.stopPropagation(); downloadSingleBackup(${backup.id})" 
                                            style="background: #3498db; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;"
                                            title="ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">
                                        ğŸ“¥
                                    </button>
                                    <button onclick="event.stopPropagation(); restoreFromBackup(${backup.id})" 
                                            style="background: #4caf50; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;"
                                            title="å¾©å…ƒ">
                                        â™»ï¸
                                    </button>
                                    <button onclick="event.stopPropagation(); deleteSingleBackup(${backup.id})" 
                                            style="background: #e74c3c; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;"
                                            title="å‰Šé™¤">
                                        ğŸ—‘ï¸
                                    </button>
                                </div>
                            </label>
                        </div>`;
                    }).join('');
                }
                
                listContainer.style.display = 'block';
                showToast('âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ', 3000, 'success');
                
            } catch (error) {
                console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.7: å˜ä¸€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        async function downloadSingleBackup(backupId) {
            try {
                const transaction = backupDB.transaction(['backups'], 'readonly');
                const objectStore = transaction.objectStore('backups');
                const request = objectStore.get(backupId);
                
                request.onsuccess = () => {
                    const backup = request.result;
                    if (!backup) {
                        showToast('âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                        return;
                    }
                    
                    const jsonStr = JSON.stringify(backup.data, null, 2);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    const date = new Date(backup.timestamp);
                    const dateStr = date.getFullYear() + 
                                  (date.getMonth() + 1).toString().padStart(2, '0') + 
                                  date.getDate().toString().padStart(2, '0') + '_' +
                                  date.getHours().toString().padStart(2, '0') + 
                                  date.getMinutes().toString().padStart(2, '0') + 
                                  date.getSeconds().toString().padStart(2, '0');
                    
                    const fileName = `MyAnkiApp_Backup_${dateStr}.json`;
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showToast('âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ', 3000, 'success');
                };
                
                request.onerror = () => {
                    showToast('âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 3000, 'error');
                };
                
            } catch (error) {
                console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ', 3000, 'error');
            }
        }
        
        // v14.02.7: å˜ä¸€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
        async function deleteSingleBackup(backupId) {
            if (!confirm('ã“ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            try {
                await deleteBackupFromIndexedDB(backupId);
                showToast('âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', 3000, 'success');
                await loadBackupList();
                await updateBackupStatus();
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', 3000, 'error');
            }
        }
        
        // v14.02.7: é¸æŠã—ãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        async function downloadSelectedBackups() {
            const checkboxes = document.querySelectorAll('.backup-checkbox:checked');
            if (checkboxes.length === 0) {
                showToast('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„', 3000, 'info');
                return;
            }
            
            for (const checkbox of checkboxes) {
                const backupId = parseInt(checkbox.getAttribute('data-backup-id'));
                await downloadSingleBackup(backupId);
            }
        }
        
        // v14.02.7: é¸æŠã—ãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
        async function deleteSelectedBackups() {
            const checkboxes = document.querySelectorAll('.backup-checkbox:checked');
            if (checkboxes.length === 0) {
                showToast('å‰Šé™¤ã™ã‚‹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„', 3000, 'info');
                return;
            }
            
            if (!confirm(`${checkboxes.length}å€‹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã™ã€‚\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                for (const checkbox of checkboxes) {
                    const backupId = parseInt(checkbox.getAttribute('data-backup-id'));
                    await deleteBackupFromIndexedDB(backupId);
                }
                
                showToast(`âœ… ${checkboxes.length}å€‹ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 5000, 'success');
                await loadBackupList();
                await updateBackupStatus();
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
        async function restoreFromBackup(backupId) {
            try {
                const transaction = backupDB.transaction(['backups'], 'readonly');
                const objectStore = transaction.objectStore('backups');
                const request = objectStore.get(backupId);
                
                request.onsuccess = async () => {
                    const backup = request.result;
                    if (!backup) {
                        showToast('âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 3000, 'error');
                        return;
                    }
                    
                    // æ—¢å­˜ã®importFromBackupé–¢æ•°ã‚’ä½¿ã£ã¦å¾©å…ƒ
                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ™‚çš„ã«Fileã¨ã—ã¦æ‰±ã†
                    const jsonStr = JSON.stringify(backup.data);
                    const blob = new Blob([jsonStr], { type: 'application/json' });
                    const file = new File([blob], 'backup.json', { type: 'application/json' });
                    
                    // FileReaderã§èª­ã¿è¾¼ã‚“ã§å¾©å…ƒ
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const backupData = JSON.parse(e.target.result);
                            await restoreBackupData(backupData);
                        } catch (error) {
                            console.error('å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                            showToast('âŒ å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
                        }
                    };
                    reader.readAsText(file);
                };
                
                request.onerror = () => {
                    showToast('âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 3000, 'error');
                };
                
            } catch (error) {
                console.error('å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.7: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒï¼ˆæ—¢å­˜ã®importFromBackupé–¢æ•°ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æµç”¨ï¼‰
        async function restoreBackupData(backupData) {
            if (!confirm('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã—ã¾ã™ã€‚\n\nç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            if (!confirm('æœ¬å½“ã«ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')) {
                return;
            }
            
            try {
                showToast('ğŸ”„ å¾©å…ƒä¸­...', 2000, 'info');
                
                // æ—¢å­˜ã®importFromBackupé–¢æ•°ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä½¿ç”¨
                // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯åŸºæœ¬çš„ãªå¾©å…ƒã®ã¿å®Ÿè£…
                const batch = db.batch();
                
                // ãƒ‡ãƒƒã‚­ã‚’å¾©å…ƒ
                if (backupData.data && backupData.data.decks) {
                    for (const deck of backupData.data.decks) {
                        const deckRef = db.collection('decks').doc(deck.id);
                        const deckData = { ...deck };
                        delete deckData.id;
                        batch.set(deckRef, deckData);
                    }
                }
                
                // ã‚«ãƒ¼ãƒ‰ã‚’å¾©å…ƒ
                if (backupData.data && backupData.data.flashcards) {
                    for (const card of backupData.data.flashcards) {
                        const cardRef = db.collection('flashcards').doc(card.id);
                        const cardData = { ...card };
                        delete cardData.id;
                        batch.set(cardRef, cardData);
                    }
                }
                
                await batch.commit();
                
                // è¨­å®šã‚’å¾©å…ƒ
                if (backupData.settings) {
                    for (const [key, value] of Object.entries(backupData.settings)) {
                        if (value !== null) {
                            localStorage.setItem(key, value);
                        }
                    }
                }
                
                showToast('âœ… å¾©å…ƒãŒå®Œäº†ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™...', 3000, 'success');
                
                setTimeout(() => {
                    location.reload();
                }, 3000);
                
            } catch (error) {
                console.error('å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.8: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½
        let integrityCheckResults = {
            ok: [],
            warnings: [],
            errors: []
        };
        
        // v14.02.8: æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        async function runIntegrityCheck() {
            try {
                showToast('ğŸ” ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œä¸­...', 2000, 'info');
                
                // çµæœã‚’ãƒªã‚»ãƒƒãƒˆ
                integrityCheckResults = {
                    ok: [],
                    warnings: [],
                    errors: []
                };
                
                // 1. ãƒ‡ãƒƒã‚­ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                await checkDeckIntegrity();
                
                // 2. ã‚«ãƒ¼ãƒ‰ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                await checkCardIntegrity();
                
                // 3. å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                await checkSessionIntegrity();
                
                // 4. PDFãƒãƒ¼ã‚«ãƒ¼ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                await checkPdfMarkerIntegrity();
                
                // 5. å­¤ç«‹ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯
                await checkOrphanedData();
                
                // çµæœã‚’è¡¨ç¤º
                displayIntegrityCheckResults();
                
                showToast('âœ… æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ', 3000, 'success');
                
            } catch (error) {
                console.error('æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.8: ãƒ‡ãƒƒã‚­ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        async function checkDeckIntegrity() {
            const decksSnapshot = await db.collection('decks').get();
            const deckIds = new Set();
            const deckMap = new Map();
            
            decksSnapshot.forEach(doc => {
                const deck = { id: doc.id, ...doc.data() };
                deckIds.add(deck.id);
                deckMap.set(deck.id, deck);
                
                // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
                if (!deck.name) {
                    integrityCheckResults.errors.push({
                        type: 'deck',
                        id: deck.id,
                        message: `ãƒ‡ãƒƒã‚­åãŒæœªè¨­å®šã§ã™`,
                        fixable: false
                    });
                }
                
                // è¦ªãƒ‡ãƒƒã‚­ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                if (deck.parentId && !deckIds.has(deck.parentId)) {
                    // è¦ªãƒ‡ãƒƒã‚­ã‚’æ¢ã™å‰ã«ã¾ã å‡¦ç†ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€å¾Œã§ãƒã‚§ãƒƒã‚¯
                }
            });
            
            // è¦ªãƒ‡ãƒƒã‚­ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
            deckMap.forEach((deck, deckId) => {
                if (deck.parentId && !deckMap.has(deck.parentId)) {
                    integrityCheckResults.warnings.push({
                        type: 'deck',
                        id: deckId,
                        message: `è¦ªãƒ‡ãƒƒã‚­ï¼ˆID: ${deck.parentId}ï¼‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“`,
                        fixable: true,
                        fix: 'removeParent'
                    });
                }
            });
            
            integrityCheckResults.ok.push({
                type: 'deck',
                message: `${deckIds.size}å€‹ã®ãƒ‡ãƒƒã‚­ã‚’ç¢ºèªã—ã¾ã—ãŸ`
            });
        }
        
        // v14.02.8: ã‚«ãƒ¼ãƒ‰ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        // v14.02.8: ã‚«ãƒ¼ãƒ‰ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        async function checkCardIntegrity() {
            const flashcardsSnapshot = await db.collection('flashcards').get();
            const decksSnapshot = await db.collection('decks').get();
            const deckIds = new Set();
            
            decksSnapshot.forEach(doc => {
                deckIds.add(doc.id);
            });
            
            let orphanedCards = 0;
            let invalidCards = 0;
            
            flashcardsSnapshot.forEach(doc => {
                const card = { id: doc.id, ...doc.data() };
                
                // v14.02.8.3: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¥ã®å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯
                let hasRequiredFields = true;
                
                if (card.type === 'cloze') {
                    // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã¯ text ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¿…è¦
                    if (!card.text) {
                        integrityCheckResults.errors.push({
                            type: 'card',
                            id: card.id,
                            message: `ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã®ãƒ†ã‚­ã‚¹ãƒˆãŒæœªè¨­å®šã§ã™`,
                            fixable: false
                        });
                        invalidCards++;
                        hasRequiredFields = false;
                    }
                } else if (card.type === 'typing') {
                    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã¯ question ã¨ (answer ã¾ãŸã¯ answers) ãŒå¿…è¦
                    if (!card.question || (!card.answer && (!card.answers || card.answers.length === 0))) {
                        integrityCheckResults.errors.push({
                            type: 'card',
                            id: card.id,
                            message: `ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®å•é¡Œã¾ãŸã¯ç­”ãˆãŒæœªè¨­å®šã§ã™`,
                            fixable: false
                        });
                        invalidCards++;
                        hasRequiredFields = false;
                    }
                } else {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ (basic, reverse) ã¯ question ã¨ answer ãŒå¿…è¦
                    if (!card.question || !card.answer) {
                        integrityCheckResults.errors.push({
                            type: 'card',
                            id: card.id,
                            message: `å•é¡Œã¾ãŸã¯ç­”ãˆãŒæœªè¨­å®šã§ã™`,
                            fixable: false
                        });
                        invalidCards++;
                        hasRequiredFields = false;
                    }
                }
                
                // ãƒ‡ãƒƒã‚­IDã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                if (card.deckId && !deckIds.has(card.deckId)) {
                    integrityCheckResults.warnings.push({
                        type: 'card',
                        id: card.id,
                        message: `æ‰€å±ãƒ‡ãƒƒã‚­ï¼ˆID: ${card.deckId}ï¼‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“`,
                        fixable: true,
                        fix: 'orphanedCard'
                    });
                    orphanedCards++;
                }
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®ãƒã‚§ãƒƒã‚¯
                if (card.type && !['basic', 'cloze', 'typing', 'reverse'].includes(card.type)) {
                    integrityCheckResults.warnings.push({
                        type: 'card',
                        id: card.id,
                        message: `ä¸æ˜ãªã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—: ${card.type}`,
                        fixable: true,
                        fix: 'resetCardType'
                    });
                }
            });
            
            if (orphanedCards === 0 && invalidCards === 0) {
                integrityCheckResults.ok.push({
                    type: 'card',
                    message: `${flashcardsSnapshot.size}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¾ã—ãŸï¼ˆå•é¡Œãªã—ï¼‰`
                });
            } else {
                integrityCheckResults.ok.push({
                    type: 'card',
                    message: `${flashcardsSnapshot.size}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ã¾ã—ãŸï¼ˆå­¤ç«‹: ${orphanedCards}æšã€ä¸æ­£: ${invalidCards}æšï¼‰`
                });
            }
        }
        
        // v14.02.8: å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        async function checkSessionIntegrity() {
            const sessionsSnapshot = await db.collection('studySessions').get();
            const flashcardsSnapshot = await db.collection('flashcards').get();
            const cardIds = new Set();
            
            flashcardsSnapshot.forEach(doc => {
                cardIds.add(doc.id);
            });
            
            let orphanedSessions = 0;
            
            sessionsSnapshot.forEach(doc => {
                const session = { id: doc.id, ...doc.data() };
                
                // ã‚«ãƒ¼ãƒ‰IDã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                if (session.cardId && !cardIds.has(session.cardId)) {
                    integrityCheckResults.warnings.push({
                        type: 'session',
                        id: session.id,
                        message: `å¯¾è±¡ã‚«ãƒ¼ãƒ‰ï¼ˆID: ${session.cardId}ï¼‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“`,
                        fixable: true,
                        fix: 'deleteSession'
                    });
                    orphanedSessions++;
                }
            });
            
            if (orphanedSessions === 0) {
                integrityCheckResults.ok.push({
                    type: 'session',
                    message: `${sessionsSnapshot.size}ä»¶ã®å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¾ã—ãŸï¼ˆå•é¡Œãªã—ï¼‰`
                });
            } else {
                integrityCheckResults.ok.push({
                    type: 'session',
                    message: `${sessionsSnapshot.size}ä»¶ã®å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¾ã—ãŸï¼ˆå­¤ç«‹: ${orphanedSessions}ä»¶ï¼‰`
                });
            }
        }
        
        // v14.02.8: PDFãƒãƒ¼ã‚«ãƒ¼ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        async function checkPdfMarkerIntegrity() {
            const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
            
            pdfMarkersSnapshot.forEach(doc => {
                const marker = doc.data();
                
                // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
                if (!marker.fileName) {
                    integrityCheckResults.warnings.push({
                        type: 'pdfMarker',
                        id: doc.id,
                        message: `PDFãƒ•ã‚¡ã‚¤ãƒ«åãŒæœªè¨­å®šã§ã™`,
                        fixable: false
                    });
                }
                
                if (!marker.markers || marker.markers.length === 0) {
                    integrityCheckResults.warnings.push({
                        type: 'pdfMarker',
                        id: doc.id,
                        message: `ãƒãƒ¼ã‚«ãƒ¼ãŒ0å€‹ã§ã™ï¼ˆå‰Šé™¤æ¨å¥¨ï¼‰`,
                        fixable: true,
                        fix: 'deletePdfMarker'
                    });
                }
            });
            
            integrityCheckResults.ok.push({
                type: 'pdfMarker',
                message: `${pdfMarkersSnapshot.size}å€‹ã®PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’ç¢ºèªã—ã¾ã—ãŸ`
            });
        }
        
        // v14.02.8: å­¤ç«‹ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯
        async function checkOrphanedData() {
            // ãƒ‡ãƒƒã‚­ã®ãªã„ã‚«ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢ã« checkCardIntegrity ã§ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ï¼‰
            // ã‚«ãƒ¼ãƒ‰ã®ãªã„å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢ã« checkSessionIntegrity ã§ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ï¼‰
            
            integrityCheckResults.ok.push({
                type: 'orphan',
                message: 'å­¤ç«‹ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ'
            });
        }
        
        // v14.02.8: æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯çµæœã‚’è¡¨ç¤º
        function displayIntegrityCheckResults() {
            const resultsDiv = document.getElementById('integrityCheckResults');
            const detailsDiv = document.getElementById('integrityCheckDetails');
            const fixSection = document.getElementById('integrityFixSection');
            
            // ã‚µãƒãƒªãƒ¼ã‚’æ›´æ–°
            document.getElementById('integrityOkCount').textContent = integrityCheckResults.ok.length;
            document.getElementById('integrityWarningCount').textContent = integrityCheckResults.warnings.length;
            document.getElementById('integrityErrorCount').textContent = integrityCheckResults.errors.length;
            
            // è©³ç´°ã‚’ç”Ÿæˆ
            let detailsHTML = '';
            
            // æ­£å¸¸é …ç›®
            if (integrityCheckResults.ok.length > 0) {
                detailsHTML += '<div style="margin-bottom: 15px;"><h4 style="color: #27ae60; margin-bottom: 10px;">âœ… æ­£å¸¸é …ç›®</h4>';
                integrityCheckResults.ok.forEach(item => {
                    detailsHTML += `<div style="background: #d4edda; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 13px;">${item.message}</div>`;
                });
                detailsHTML += '</div>';
            }
            
            // è­¦å‘Šé …ç›®
            if (integrityCheckResults.warnings.length > 0) {
                detailsHTML += '<div style="margin-bottom: 15px;"><h4 style="color: #f39c12; margin-bottom: 10px;">âš ï¸ è­¦å‘Šé …ç›®</h4>';
                integrityCheckResults.warnings.forEach((item, index) => {
                    const editButton = item.type === 'card' && item.id ? 
                        `<button onclick="editCardFromIntegrity('${item.id}')" style="background: #3498db; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-top: 5px;">ğŸ“ ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†</button>` : '';
                    
                    detailsHTML += `<div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 13px;">
                        <div><strong>${item.type}</strong> - ${item.message}</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                            ${item.fixable ? '<div style="color: #666; font-size: 12px;">ï¼ˆè‡ªå‹•ä¿®å¾©å¯èƒ½ï¼‰</div>' : ''}
                            ${editButton}
                        </div>
                    </div>`;
                });
                detailsHTML += '</div>';
            }
            
            // ã‚¨ãƒ©ãƒ¼é …ç›®
            if (integrityCheckResults.errors.length > 0) {
                detailsHTML += '<div style="margin-bottom: 15px;"><h4 style="color: #e74c3c; margin-bottom: 10px;">âŒ ã‚¨ãƒ©ãƒ¼é …ç›®</h4>';
                integrityCheckResults.errors.forEach((item, index) => {
                    const editButton = item.type === 'card' && item.id ? 
                        `<button onclick="editCardFromIntegrity('${item.id}')" style="background: #3498db; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin-top: 5px;">ğŸ“ ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†</button>` : '';
                    
                    detailsHTML += `<div style="background: #f8d7da; padding: 10px; border-radius: 5px; margin-bottom: 5px; font-size: 13px;">
                        <div><strong>${item.type}</strong> - ${item.message}</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                            ${item.fixable ? '<div style="color: #666; font-size: 12px;">ï¼ˆè‡ªå‹•ä¿®å¾©å¯èƒ½ï¼‰</div>' : '<div style="color: #666; font-size: 12px;">ï¼ˆæ‰‹å‹•ä¿®æ­£ãŒå¿…è¦ï¼‰</div>'}
                            ${editButton}
                        </div>
                    </div>`;
                });
                detailsHTML += '</div>';
            }
            
            detailsDiv.innerHTML = detailsHTML;
            
            // ä¿®å¾©å¯èƒ½ãªé …ç›®ãŒã‚ã‚‹å ´åˆã¯ä¿®å¾©ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            const hasFixableIssues = integrityCheckResults.warnings.some(item => item.fixable) || 
                                    integrityCheckResults.errors.some(item => item.fixable);
            
            if (hasFixableIssues) {
                fixSection.style.display = 'block';
            } else {
                fixSection.style.display = 'none';
            }
            
            resultsDiv.style.display = 'block';
        }
        
        // v14.02.8.1: ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†ï¼ˆæ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã‹ã‚‰ï¼‰
        async function editCardFromIntegrity(cardId) {
            try {
                // ã‚«ãƒ¼ãƒ‰ã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ
                switchTab('cards');
                
                // ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
                const cardDoc = await db.collection('flashcards').doc(cardId).get();
                if (!cardDoc.exists) {
                    showToast('âŒ ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 3000, 'error');
                    return;
                }
                
                const cardData = { id: cardDoc.id, ...cardDoc.data() };
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®cardsé…åˆ—ã‚’æ›´æ–°ï¼ˆeditCardé–¢æ•°ãŒä½¿ç”¨ã™ã‚‹ãŸã‚ï¼‰
                if (!cards) {
                    cards = [];
                }
                
                // cardsé…åˆ—å†…ã§è©²å½“ã‚«ãƒ¼ãƒ‰ã‚’æ¢ã™
                const cardIndex = cards.findIndex(c => c.id === cardId);
                if (cardIndex >= 0) {
                    // æ—¢å­˜ã®ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°
                    cards[cardIndex] = cardData;
                } else {
                    // ã‚«ãƒ¼ãƒ‰ãŒé…åˆ—ã«ãªã„å ´åˆã¯è¿½åŠ 
                    cards.push(cardData);
                }
                
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰editCardé–¢æ•°ã‚’å‘¼ã³å‡ºã™ï¼ˆã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã®å®Œäº†ã‚’å¾…ã¤ï¼‰
                setTimeout(() => {
                    editCard(cardId);
                    showToast('âœ… ã‚«ãƒ¼ãƒ‰ç·¨é›†ç”»é¢ã‚’é–‹ãã¾ã—ãŸ', 3000, 'info');
                }, 300);
                
            } catch (error) {
                console.error('ã‚«ãƒ¼ãƒ‰ç·¨é›†ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ ã‚«ãƒ¼ãƒ‰ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ', 3000, 'error');
            }
        }
        
        // v14.02.8.1: è‡ªå‹•ä¿®å¾©ã‚’å®Ÿè¡Œï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä»˜ãï¼‰
        async function autoFixIntegrityIssues() {
            // ä¿®å¾©å¯èƒ½ãªé …ç›®ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦å†…å®¹ã‚’ç”Ÿæˆ
            let fixableItems = [];
            
            // è­¦å‘Šé …ç›®ã®ä¿®å¾©å¯èƒ½é …ç›®ã‚’åé›†
            for (const item of integrityCheckResults.warnings) {
                if (item.fixable) {
                    let action = '';
                    switch (item.fix) {
                        case 'removeParent':
                            action = 'è¦ªãƒ‡ãƒƒã‚­ã®å‚ç…§ã‚’å‰Šé™¤';
                            break;
                        case 'orphanedCard':
                            action = 'å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤';
                            break;
                        case 'resetCardType':
                            action = 'ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’"basic"ã«ãƒªã‚»ãƒƒãƒˆ';
                            break;
                        case 'deleteSession':
                            action = 'å­¤ç«‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤';
                            break;
                        case 'deletePdfMarker':
                            action = 'ãƒãƒ¼ã‚«ãƒ¼0å€‹ã®PDFæƒ…å ±ã‚’å‰Šé™¤';
                            break;
                    }
                    fixableItems.push({ type: item.type, message: item.message, action: action });
                }
            }
            
            // ã‚¨ãƒ©ãƒ¼é …ç›®ã®ä¿®å¾©å¯èƒ½é …ç›®ã‚’åé›†
            for (const item of integrityCheckResults.errors) {
                if (item.fixable) {
                    fixableItems.push({ type: item.type, message: item.message, action: 'è‡ªå‹•ä¿®å¾©' });
                }
            }
            
            if (fixableItems.length === 0) {
                showToast('ä¿®å¾©å¯èƒ½ãªé …ç›®ã¯ã‚ã‚Šã¾ã›ã‚“', 3000, 'info');
                return;
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            let previewMessage = `ä»¥ä¸‹ã®${fixableItems.length}ä»¶ã®å•é¡Œã‚’è‡ªå‹•ä¿®å¾©ã—ã¾ã™ï¼š\n\n`;
            fixableItems.forEach((item, index) => {
                previewMessage += `${index + 1}. [${item.type}] ${item.message}\n   â†’ ${item.action}\n\n`;
            });
            previewMessage += 'ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚ç¶šã‘ã¾ã™ã‹ï¼Ÿ';
            
            // 1æ®µéšç›®ã®ç¢ºèª
            if (!confirm(previewMessage)) {
                return;
            }
            
            // 2æ®µéšç›®ã®ç¢ºèª
            if (!confirm('æœ¬å½“ã«å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ\n\nå‰Šé™¤ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯å¾©å…ƒã§ãã¾ã›ã‚“ã€‚\n\nå®Ÿè¡Œå‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å–ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚')) {
                return;
            }
            
            try {
                showToast('ğŸ”§ è‡ªå‹•ä¿®å¾©ã‚’å®Ÿè¡Œä¸­...', 2000, 'info');
                
                let fixedCount = 0;
                const batch = db.batch();
                
                // è­¦å‘Šé …ç›®ã®ä¿®å¾©
                for (const item of integrityCheckResults.warnings) {
                    if (item.fixable) {
                        switch (item.fix) {
                            case 'removeParent':
                                // è¦ªãƒ‡ãƒƒã‚­ã®å‚ç…§ã‚’å‰Šé™¤
                                const deckRef = db.collection('decks').doc(item.id);
                                batch.update(deckRef, { parentId: null });
                                fixedCount++;
                                break;
                                
                            case 'orphanedCard':
                                // å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                                const cardRef = db.collection('flashcards').doc(item.id);
                                batch.delete(cardRef);
                                fixedCount++;
                                break;
                                
                            case 'resetCardType':
                                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
                                const cardTypeRef = db.collection('flashcards').doc(item.id);
                                batch.update(cardTypeRef, { type: 'basic' });
                                fixedCount++;
                                break;
                                
                            case 'deleteSession':
                                // å­¤ç«‹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
                                const sessionRef = db.collection('studySessions').doc(item.id);
                                batch.delete(sessionRef);
                                fixedCount++;
                                break;
                                
                            case 'deletePdfMarker':
                                // ãƒãƒ¼ã‚«ãƒ¼ãŒ0å€‹ã®PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’å‰Šé™¤
                                const pdfRef = db.collection('pdfMarkers').doc(item.id);
                                batch.delete(pdfRef);
                                fixedCount++;
                                break;
                        }
                    }
                }
                
                // ã‚¨ãƒ©ãƒ¼é …ç›®ã®ä¿®å¾©ï¼ˆä¿®å¾©å¯èƒ½ãªã‚‚ã®ã®ã¿ï¼‰
                for (const item of integrityCheckResults.errors) {
                    if (item.fixable) {
                        // ã‚¨ãƒ©ãƒ¼é …ç›®ã®ä¿®å¾©ãƒ­ã‚¸ãƒƒã‚¯
                        fixedCount++;
                    }
                }
                
                if (fixedCount > 0) {
                    await batch.commit();
                    showToast(`âœ… ${fixedCount}ä»¶ã®å•é¡Œã‚’ä¿®å¾©ã—ã¾ã—ãŸ`, 5000, 'success');
                    
                    // å†åº¦ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
                    setTimeout(() => {
                        runIntegrityCheck();
                    }, 2000);
                } else {
                    showToast('ä¿®å¾©å¯èƒ½ãªå•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 3000, 'info');
                }
                
            } catch (error) {
                console.error('è‡ªå‹•ä¿®å¾©ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ è‡ªå‹•ä¿®å¾©ã«å¤±æ•—ã—ã¾ã—ãŸ', 5000, 'error');
            }
        }
        
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½
        let storageHistory = [];
        
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã®å±¥æ­´ã‚’è¨˜éŒ²
        function recordStorageUsage(storageInfo) {
            const today = new Date().toISOString().split('T')[0];
            
            // localStorageã‹ã‚‰å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            const historyStr = localStorage.getItem('storageHistory');
            if (historyStr) {
                storageHistory = JSON.parse(historyStr);
            }
            
            // ä»Šæ—¥ã®è¨˜éŒ²ãŒã‚ã‚Œã°æ›´æ–°ã€ãªã‘ã‚Œã°è¿½åŠ 
            const existingIndex = storageHistory.findIndex(item => item.date === today);
            if (existingIndex >= 0) {
                storageHistory[existingIndex] = {
                    date: today,
                    usage: storageInfo.usedMB,
                    percentage: storageInfo.usagePercentage
                };
            } else {
                storageHistory.push({
                    date: today,
                    usage: storageInfo.usedMB,
                    percentage: storageInfo.usagePercentage
                });
            }
            
            // éå»30æ—¥åˆ†ã®ã¿ä¿æŒ
            if (storageHistory.length > 30) {
                storageHistory = storageHistory.slice(-30);
            }
            
            // localStorageã«ä¿å­˜
            localStorage.setItem('storageHistory', JSON.stringify(storageHistory));
        }
        
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ›´æ–°
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ›´æ–°
        async function updateStorageAlert() {
            try {
                const alertDiv = document.getElementById('storageAlertStatus');
                const recommendDiv = document.getElementById('storageRecommendations');
                const recommendList = document.getElementById('storageRecommendationsList');
                
                // è¦ç´ ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯å‡¦ç†ã‚’ä¸­æ–­
                if (!alertDiv) {
                    console.log('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’å–å¾—
                const storageInfo = await calculateStorageUsage();
                
                if (!storageInfo) {
                    console.log('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    alertDiv.innerHTML = `<div style="background: #f8f9fa; border-left: 4px solid #999; padding: 15px; border-radius: 5px;">
                        <div style="font-weight: bold; color: #666; margin-bottom: 5px;">â„¹ï¸ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã‚’è¨ˆç®—ä¸­...</div>
                        <div style="font-size: 13px; color: #999;">çµ±è¨ˆã‚¿ãƒ–ã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’è¨ˆç®—ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</div>
                    </div>`;
                    return;
                }
                
                // å±¥æ­´ã«è¨˜éŒ²
                recordStorageUsage(storageInfo);
                
                const percentage = storageInfo.usagePercentage || 0;
                
                let alertHTML = '';
                let alertColor = '';
                let alertIcon = '';
                let alertMessage = '';
                
                if (percentage >= 90) {
                    alertColor = '#e74c3c';
                    alertIcon = 'ğŸ”´';
                    alertMessage = 'å±é™ºï¼šã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒ90%ã‚’è¶…ãˆã¦ã„ã¾ã™ï¼æ—©æ€¥ã«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚';
                } else if (percentage >= 80) {
                    alertColor = '#f39c12';
                    alertIcon = 'âš ï¸';
                    alertMessage = 'è­¦å‘Šï¼šã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒ80%ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®æ•´ç†ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚';
                } else if (percentage >= 70) {
                    alertColor = '#3498db';
                    alertIcon = 'â„¹ï¸';
                    alertMessage = 'æ³¨æ„ï¼šã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãŒ70%ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚å®¹é‡ã«ä½™è£•ã‚’æŒãŸã›ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚';
                } else {
                    alertColor = '#27ae60';
                    alertIcon = 'âœ…';
                    alertMessage = 'æ­£å¸¸ï¼šã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚';
                }
                
                alertHTML = `<div style="background: ${alertColor}22; border-left: 4px solid ${alertColor}; padding: 15px; border-radius: 5px;">
                    <div style="font-weight: bold; color: ${alertColor}; margin-bottom: 5px;">${alertIcon} ${alertMessage}</div>
                    <div style="font-size: 13px; color: #666;">ç¾åœ¨ã®ä½¿ç”¨é‡: ${storageInfo.usedMB.toFixed(2)} MB / ${storageInfo.totalMB} MB (${percentage.toFixed(1)}%)</div>
                </div>`;
                
                alertDiv.innerHTML = alertHTML;
                
                // å‰Šé™¤æ¨å¥¨é …ç›®ã‚’è¡¨ç¤º
                if (percentage >= 70 && recommendDiv && recommendList) {
                    const recommendations = await getStorageRecommendations();
                    
                    if (recommendations.length > 0) {
                        let recommendHTML = '';
                        recommendations.forEach(rec => {
                            recommendHTML += `<div style="background: #f8f9fa; padding: 12px; border-radius: 5px; margin-bottom: 8px; border-left: 3px solid #3498db;">
                                <div style="font-weight: bold; margin-bottom: 5px;">${rec.title}</div>
                                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">${rec.description}</div>
                                <div style="font-size: 12px; color: #999;">å‰Šæ¸›è¦‹è¾¼ã¿: ${rec.savingsMB} MB</div>
                            </div>`;
                        });
                        recommendList.innerHTML = recommendHTML;
                        recommendDiv.style.display = 'block';
                    } else {
                        recommendDiv.style.display = 'none';
                    }
                } else if (recommendDiv) {
                    recommendDiv.style.display = 'none';
                }
                
                // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡æ¨ç§»ã‚°ãƒ©ãƒ•ã‚’æ›´æ–°
                updateStorageHistoryChart();
                
            } catch (error) {
                console.error('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                const alertDiv = document.getElementById('storageAlertStatus');
                if (alertDiv) {
                    alertDiv.innerHTML = `<div style="background: #f8d7da; border-left: 4px solid #e74c3c; padding: 15px; border-radius: 5px;">
                        <div style="font-weight: bold; color: #e74c3c; margin-bottom: 5px;">âŒ ã‚¨ãƒ©ãƒ¼</div>
                        <div style="font-size: 13px; color: #666;">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}</div>
                    </div>`;
                }
            }
        }
        
        // v14.02.10: å‰Šé™¤æ¨å¥¨é …ç›®ã‚’å–å¾—
        async function getStorageRecommendations() {
            const recommendations = [];
            
            // å¤ã„å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            
            const oldSessionsSnapshot = await db.collection('studySessions')
                .where('timestamp', '<', firebase.firestore.Timestamp.fromDate(sixMonthsAgo))
                .get();
            
            if (oldSessionsSnapshot.size > 100) {
                recommendations.push({
                    title: 'å¤ã„å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ²',
                    description: `6ãƒ¶æœˆä»¥ä¸Šå‰ã®å­¦ç¿’è¨˜éŒ²ãŒ${oldSessionsSnapshot.size}ä»¶ã‚ã‚Šã¾ã™`,
                    savingsMB: (oldSessionsSnapshot.size * 0.001).toFixed(2)
                });
            }
            
            // å­¤ç«‹ã‚«ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
            const decksSnapshot = await db.collection('decks').get();
            const deckIds = new Set();
            decksSnapshot.forEach(doc => deckIds.add(doc.id));
            
            const flashcardsSnapshot = await db.collection('flashcards').get();
            let orphanedCount = 0;
            
            flashcardsSnapshot.forEach(doc => {
                const card = doc.data();
                if (card.deckId && !deckIds.has(card.deckId)) {
                    orphanedCount++;
                }
            });
            
            if (orphanedCount > 0) {
                recommendations.push({
                    title: 'å­¤ç«‹ã‚«ãƒ¼ãƒ‰',
                    description: `æ‰€å±ãƒ‡ãƒƒã‚­ãŒå­˜åœ¨ã—ãªã„ã‚«ãƒ¼ãƒ‰ãŒ${orphanedCount}æšã‚ã‚Šã¾ã™`,
                    savingsMB: (orphanedCount * 0.002).toFixed(2)
                });
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼ãŒ0å€‹ã®PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±
            const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
            let emptyPdfMarkers = 0;
            
            pdfMarkersSnapshot.forEach(doc => {
                const data = doc.data();
                if (!data.markers || data.markers.length === 0) {
                    emptyPdfMarkers++;
                }
            });
            
            if (emptyPdfMarkers > 0) {
                recommendations.push({
                    title: 'ãƒãƒ¼ã‚«ãƒ¼ãŒ0å€‹ã®PDFæƒ…å ±',
                    description: `ãƒãƒ¼ã‚«ãƒ¼ãŒ1ã¤ã‚‚ãªã„PDFæƒ…å ±ãŒ${emptyPdfMarkers}ä»¶ã‚ã‚Šã¾ã™`,
                    savingsMB: (emptyPdfMarkers * 0.001).toFixed(2)
                });
            }
            
            return recommendations;
        }
        
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡æ¨ç§»ã‚°ãƒ©ãƒ•ã‚’æ›´æ–°
        // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡æ¨ç§»ã‚°ãƒ©ãƒ•ã‚’æ›´æ–°
        function updateStorageHistoryChart() {
            const chartDiv = document.getElementById('storageHistoryChart');
            
            if (!chartDiv) return;
            
            // localStorageã‹ã‚‰å±¥æ­´ã‚’èª­ã¿è¾¼ã¿
            const historyStr = localStorage.getItem('storageHistory');
            if (!historyStr) {
                chartDiv.innerHTML = `<div style="text-align: center; color: #999; padding: 30px;">
                    <div style="font-size: 14px; margin-bottom: 10px;">ğŸ“Š ãƒ‡ãƒ¼ã‚¿åé›†ä¸­</div>
                    <div style="font-size: 12px;">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã®å±¥æ­´ã‚’è¨˜éŒ²ã—ã¦ã„ã¾ã™ã€‚<br>ãƒ‡ãƒ¼ã‚¿ãŒè“„ç©ã•ã‚Œã‚‹ã¨ã€ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>`;
                return;
            }
            
            const history = JSON.parse(historyStr);
            
            // éå»7æ—¥åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const last7Days = history.slice(-7);
            
            if (last7Days.length === 0) {
                chartDiv.innerHTML = `<div style="text-align: center; color: #999; padding: 30px;">
                    <div style="font-size: 14px; margin-bottom: 10px;">ğŸ“Š ãƒ‡ãƒ¼ã‚¿åé›†ä¸­</div>
                    <div style="font-size: 12px;">ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã®å±¥æ­´ã‚’è¨˜éŒ²ã—ã¦ã„ã¾ã™ã€‚<br>ãƒ‡ãƒ¼ã‚¿ãŒè“„ç©ã•ã‚Œã‚‹ã¨ã€ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
                </div>`;
                return;
            }
            
            // ç°¡æ˜“çš„ãªãƒãƒ¼ãƒãƒ£ãƒ¼ãƒˆã‚’ç”Ÿæˆ
            const maxUsage = Math.max(...last7Days.map(item => item.usage || 0));
            
            // maxUsageãŒ0ã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            const chartMaxUsage = maxUsage > 0 ? maxUsage : 1;
            
            let chartHTML = '<div style="display: flex; align-items: flex-end; justify-content: space-around; height: 100%;">';
            
            last7Days.forEach(item => {
                const usage = item.usage || 0;
                const height = Math.max((usage / chartMaxUsage) * 80, 5); // æœ€å°5pxã®é«˜ã•
                const date = new Date(item.date);
                const dayLabel = `${date.getMonth() + 1}/${date.getDate()}`;
                
                let barColor = '#27ae60';
                if (item.percentage >= 90) barColor = '#e74c3c';
                else if (item.percentage >= 80) barColor = '#f39c12';
                else if (item.percentage >= 70) barColor = '#3498db';
                
                chartHTML += `<div style="flex: 1; text-align: center; position: relative; min-height: 100px;">
                    <div style="background: ${barColor}; width: 80%; margin: 0 auto; height: ${height}px; border-radius: 3px 3px 0 0; position: absolute; bottom: 20px; left: 10%;" title="${usage.toFixed(2)} MB (${item.percentage.toFixed(1)}%)"></div>
                    <div style="font-size: 10px; color: #999; position: absolute; bottom: 0; left: 0; right: 0;">${dayLabel}</div>
                </div>`;
            });
            
            chartHTML += '</div>';
            
            chartDiv.innerHTML = chartHTML;
        }
        
        // v14.02.8.1: å®‰å…¨ãªTimestampå‡¦ç†é–¢æ•°
        function safeToMillis(timestamp) {
            if (!timestamp) return 0;
            
            // Firestoreã® Timestamp ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
            if (timestamp.toMillis && typeof timestamp.toMillis === 'function') {
                return timestamp.toMillis();
            }
            
            // seconds ã¨ nanoseconds ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
            if (timestamp.seconds !== undefined) {
                return timestamp.seconds * 1000 + (timestamp.nanoseconds || 0) / 1000000;
            }
            
            // æ•°å€¤ã®å ´åˆï¼ˆã™ã§ã«ãƒŸãƒªç§’ï¼‰
            if (typeof timestamp === 'number') {
                return timestamp;
            }
            
            // Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
            if (timestamp instanceof Date) {
                return timestamp.getTime();
            }
            
            // ãã‚Œä»¥å¤–ã®å ´åˆã¯0ã‚’è¿”ã™
            return 0;
        }
        
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let scale = 1.0;
        let pdfHash = null;
        let currentPDFFile = null;
        
        // v15.00.0: ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç”¨å¤‰æ•°
        let isPinching = false;
        let pinchStartDistance = 0;
        let pinchStartScale = 1.0;
        
        // v15.00.1: ãƒ‘ãƒ³ç”¨å¤‰æ•°
        let pinchCenterX;
        let pinchCenterY;
        
        // v15.00.2: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¤å®šç”¨å¤‰æ•°ï¼ˆãƒ‘ãƒ³ã¨ãƒ”ãƒ³ãƒã‚’æ’ä»–çš„ã«ï¼‰
        let gestureMode = null; // null, 'pan', 'pinch'
        let gestureStartTime = 0;
        let gestureDecisionTime = 100; // åˆ¤å®šçŒ¶äºˆæ™‚é–“ï¼ˆmsï¼‰
        
        // v15.01.0: å…¨ç”»é¢è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰
        let fullscreenMode = false;
        let savedScaleBeforeFullscreen = null;  // v15.01.5: å…¨ç”»é¢å‰ã®scaleã‚’ä¿å­˜
        
        // v14.00: PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä¿å­˜ç”¨
        let currentPdfMetadata = {
            fileName: '',
            totalPages: 0,
            fileSize: 0,
            lastUpdated: null
        };
        
        let markers = {};
        let currentMarkerColor = 'yellow';
        let markerMode = false;
        let isDrawing = false;
        let startX, startY;
        let redSheetMode = false;
        
        let editMode = false;
        let deleteMode = false;
        let redSheetColors = { yellow: false, red: false, green: false, blue: false, all: false };
        let selectedMarkerIndex = null;
        let selectedMarkerPage = null;
        let isDraggingMarker = false;
        let dragStartX, dragStartY;
        let instantDeleteMode = false;
        let resizingHandle = null;
        let movingMarker = false; // v15.01.14: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•ä¸­ãƒ•ãƒ©ã‚°
        let lastMarkerHeight = 0; // v15.01.13: ç›´å‰ã®ãƒãƒ¼ã‚«ãƒ¼é«˜ã•ã‚’è¨˜æ†¶
        let fixHeightMode = false; // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰
        
        // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
        let studyMode = false;
        let savedRedSheetColors = null; // v14.00.9: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰é–‹å§‹å‰ã®ã‚·ãƒ¼ãƒˆçŠ¶æ…‹ã‚’ä¿å­˜
        
        // v7.00.2: å­¦ç¿’OFFæ™‚ã®ã‚·ãƒ¼ãƒˆæ©Ÿèƒ½ã§ã®ã‚¯ãƒªãƒƒã‚¯æ˜è»¢ç®¡ç†ï¼ˆãƒšãƒ¼ã‚¸ãƒ»ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³å¤‰æ›´ã§ãƒªã‚»ãƒƒãƒˆï¼‰
        let sheetClickToggles = {}; // { 'pageNum-markerIndex': true/false }
        
        // v7.01: å­¦ç¿’çµ±è¨ˆç®¡ç†
        let studyStartTime = null; // å­¦ç¿’é–‹å§‹æ™‚åˆ»
        let studyElapsedTime = 0; // ç´¯ç©å­¦ç¿’æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
        let studyTimerInterval = null; // ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ID
        
        // v7.02: PDFå˜ä½ã®å­¦ç¿’è¨˜éŒ²
        let totalStudyTime = 0; // ç·å­¦ç¿’æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
        let lapCount = 1; // å‘¨å›æ•°
        
        // v9.00: PDFå­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´
        let currentSessionStartTime = null; // ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»
        let sessionCorrectCount = 0; // ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã®æ­£ç­”æ•°
        let sessionIncorrectCount = 0; // ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã®èª¤ç­”æ•°
        let sessionStudiedMarkers = new Set(); // ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã«å­¦ç¿’ã—ãŸãƒãƒ¼ã‚«ãƒ¼ã®ID
        
        // v7.02.1: å®šæœŸä¿å­˜ç®¡ç†
        let autoSaveInterval = null; // å®šæœŸä¿å­˜ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ID
        
        // v12.00: ãƒ‡ãƒƒã‚­æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ç®¡ç†
        let collapsedDecks = JSON.parse(localStorage.getItem('collapsedDecks') || '{}');
        
        // v12.01: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆç”¨ï¼‰
        // v12.01.6: è¡¨ç¤ºä»¶æ•°ã‚’localStorageã‹ã‚‰èª­ã¿è¾¼ã¿
        let currentCardPage = 1;
        let cardsPerPage = parseInt(localStorage.getItem('cardsPerPage') || '50');
        let totalFilteredCards = 0;
        
        let pdfDB = null;
        let useFileSystemAPI = false;
        
        let isPanning = false;
        let panStartX, panStartY;
        let offsetX = 0, offsetY = 0;

        // v6.00: ãƒ‡ãƒƒã‚­èª­ã¿è¾¼ã¿ã¨ã‚«ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿
        db.collection('decks').orderBy('order').onSnapshot((snapshot) => {
            decks = [];
            snapshot.forEach((doc) => {
                decks.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            decksLoaded = true;
            updateDeckSelectors();
            updateStudyDeckSelector(); // v8.00: å­¦ç¿’ç”¨ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚‚æ›´æ–°
            // v6.01.1: ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿ãŒæƒã£ãŸã‚‰è¡¨ç¤º
            if (cardsLoaded) {
                displayDecks();
            }
        }, (error) => {
            console.error('Error fetching decks:', error);
        });

        // v10.02: orderé †ã§èª­ã¿è¾¼ã¿ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯createdAté †ï¼‰
        db.collection('flashcards').onSnapshot((snapshot) => {
            cards = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                cards.push({
                    id: doc.id,
                    ...data,
                    // v10.02: orderãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãªã„å ´åˆã¯æœ«å°¾ã«é…ç½®
                    order: data.order !== undefined ? data.order : 999999
                });
            });
            
            // v10.02: orderé †ã§ã‚½ãƒ¼ãƒˆï¼ˆorderãŒåŒã˜å ´åˆã¯createdAté †ï¼‰
            cards.sort((a, b) => {
                if (a.order !== b.order) {
                    return a.order - b.order;
                }
                const dateA = safeToMillis(a.createdAt) || 0;
                const dateB = safeToMillis(b.createdAt) || 0;
                return dateB - dateA;
            });
            
            cardsLoaded = true;
            updateSyncStatus('synced');
            displayCard();
            
            // v12.01.5: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œã®è¡¨ç¤ºé–¢æ•°ã‚’ä½¿ç”¨
            displayCardListWithPagination();
            
            // v6.01.2: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çŠ¶æ…‹ã‚’ç¶­æŒ
            if (currentDeckFilter) {
                filterCards();
            }
            
            // v6.01.1: ä¸¡æ–¹ã®ãƒ‡ãƒ¼ã‚¿ãŒæƒã£ãŸã‚‰è¡¨ç¤º
            if (decksLoaded) {
                displayDecks();
            }
        }, (error) => {
            console.error('Error fetching cards:', error);
            updateSyncStatus('error');
        });
        
        // v6.00: ãƒ‡ãƒƒã‚­ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’æ›´æ–°
        function updateDeckSelectors() {
            const deckSelector = document.getElementById('deckId');
            const deckFilter = document.getElementById('deckFilter');
            const editDeckSelector = document.getElementById('editDeckId');
            
            let deckOptions = '<option value="">ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
            let filterOptions = '<option value="">ã™ã¹ã¦ã®ãƒ‡ãƒƒã‚­</option>';
            filterOptions += '<option value="__uncategorized__">æœªåˆ†é¡ã‚«ãƒ¼ãƒ‰</option>';
            
            // ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒƒã‚­ã‹ã‚‰éšå±¤çš„ã«æ§‹ç¯‰
            function buildDeckOptions(parentId = null, prefix = '') {
                const children = decks.filter(d => {
                    if (parentId === null) return !d.parentId;
                    return d.parentId === parentId;
                });
                
                children.forEach(deck => {
                    const displayName = prefix + deck.name;
                    deckOptions += `<option value="${deck.id}">${displayName}</option>`;
                    filterOptions += `<option value="${deck.id}">${displayName}</option>`;
                    
                    // å†å¸°çš„ã«ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’è¿½åŠ 
                    buildDeckOptions(deck.id, displayName + ' > ');
                });
            }
            
            buildDeckOptions();
            
            if (deckSelector) {
                deckSelector.innerHTML = deckOptions;
                // v6.00.2: å‰å›é¸æŠã—ãŸãƒ‡ãƒƒã‚­ã‚’å¾©å…ƒ
                const lastDeckId = localStorage.getItem('lastSelectedDeckId');
                if (lastDeckId && decks.find(d => d.id === lastDeckId)) {
                    deckSelector.value = lastDeckId;
                }
            }
            if (deckFilter) deckFilter.innerHTML = filterOptions;
            if (editDeckSelector) editDeckSelector.innerHTML = deckOptions;
        }
        
        // v6.00: ãƒ‡ãƒƒã‚­åã‚’å–å¾—
        function getDeckNameById(deckId) {
            if (!deckId) return '';
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return '';
            
            const path = [];
            let currentDeck = deck;
            
            while (currentDeck) {
                path.unshift(currentDeck.name);
                if (!currentDeck.parentId) break;
                currentDeck = decks.find(d => d.id === currentDeck.parentId);
            }
            
            return path.join(' > ');
        }
        
        // v8.02: çµ±è¨ˆã‚¿ãƒ–ã®è¡¨ç¤ºã‚’æ›´æ–°
        async function updateStatsDisplay() {
            console.log('=== çµ±è¨ˆè¡¨ç¤ºã‚’æ›´æ–° ===');
            
            // v8.02.1: ã‚«ãƒ¼ãƒ‰çŠ¶æ…‹ã®é›†è¨ˆ
            const now = Date.now();
            const TWENTY_ONE_DAYS = 21 * 24 * 60 * 60 * 1000;
            
            let totalCards = cards.length;
            let totalNew = 0;
            let totalLearning = 0;
            let totalReview = 0;
            let totalYoung = 0;
            let totalMature = 0;
            
            cards.forEach(card => {
                const c = initializeCard(card);
                if (c.state === 'new') totalNew++;
                else if (c.state === 'learning' || c.state === 'relearning') totalLearning++;
                else if (c.state === 'review') {
                    totalReview++;
                    // Young/Matureã®åˆ¤å®š
                    const intervalMs = c.interval * 24 * 60 * 60 * 1000;
                    if (intervalMs < TWENTY_ONE_DAYS) {
                        totalYoung++;
                    } else {
                        totalMature++;
                    }
                }
            });
            
            document.getElementById('totalCards').textContent = totalCards;
            document.getElementById('totalNew').textContent = totalNew;
            document.getElementById('totalLearning').textContent = totalLearning;
            document.getElementById('totalReview').textContent = totalReview;
            document.getElementById('totalYoung').textContent = totalYoung;
            document.getElementById('totalMature').textContent = totalMature;
            
            // v8.02.3: ä»Šæ—¥ã®å­¦ç¿’å±¥æ­´ã‚’é›†è¨ˆ
            const todayStart = new Date();
            todayStart.setHours(0, 0, 0, 0);
            const todayStartMs = todayStart.getTime();
            
            try {
                const sessionsSnapshot = await db.collection('studySessions')
                    .where('startTime', '>=', todayStartMs)
                    .get();
                
                let todayDuration = 0;
                let todayAgain = 0;
                let todayHard = 0;
                let todayGood = 0;
                let todayEasy = 0;
                
                sessionsSnapshot.forEach(doc => {
                    const session = doc.data();
                    todayDuration += session.duration || 0;
                    todayAgain += session.ratings?.again || 0;
                    todayHard += session.ratings?.hard || 0;
                    todayGood += session.ratings?.good || 0;
                    todayEasy += session.ratings?.easy || 0;
                });
                
                // å­¦ç¿’æ™‚é–“ã‚’åˆ†å˜ä½ã§è¡¨ç¤º
                const todayMinutes = Math.round(todayDuration / 1000 / 60);
                document.getElementById('todayStudyTime').textContent = todayMinutes + 'åˆ†';
                
                // æ­£ç­”ç‡ã‚’è¨ˆç®—
                const todayTotal = todayAgain + todayHard + todayGood + todayEasy;
                let todayAccuracy = 'N/A';
                if (todayTotal > 0) {
                    const correctCount = todayGood + todayEasy;
                    todayAccuracy = Math.round((correctCount / todayTotal) * 100) + '%';
                }
                document.getElementById('todayAccuracy').textContent = todayAccuracy;
                
                // è©•ä¾¡ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ç¤º
                document.getElementById('todayAgain').textContent = todayAgain;
                document.getElementById('todayHard').textContent = todayHard;
                document.getElementById('todayGood').textContent = todayGood;
                document.getElementById('todayEasy').textContent = todayEasy;
                
                // ä»Šé€±ã®å­¦ç¿’æ™‚é–“
                const weekStart = new Date(todayStart);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // æ—¥æ›œæ—¥
                const weekStartMs = weekStart.getTime();
                
                const weekSessionsSnapshot = await db.collection('studySessions')
                    .where('startTime', '>=', weekStartMs)
                    .get();
                
                let weekDuration = 0;
                weekSessionsSnapshot.forEach(doc => {
                    const session = doc.data();
                    weekDuration += session.duration || 0;
                });
                
                const weekMinutes = Math.round(weekDuration / 1000 / 60);
                const weekHours = Math.floor(weekMinutes / 60);
                const weekMins = weekMinutes % 60;
                document.getElementById('weekStudyTime').textContent = 
                    weekHours + 'æ™‚é–“' + weekMins + 'åˆ†';
                
                const daysInWeek = Math.ceil((now - weekStartMs) / (1000 * 60 * 60 * 24));
                const weekAvg = Math.round(weekMinutes / Math.max(daysInWeek, 1));
                document.getElementById('weekAvgTime').textContent = weekAvg + 'åˆ†/æ—¥';
                
                // ä»Šæœˆã®å­¦ç¿’æ™‚é–“
                const monthStart = new Date(todayStart);
                monthStart.setDate(1);
                const monthStartMs = monthStart.getTime();
                
                const monthSessionsSnapshot = await db.collection('studySessions')
                    .where('startTime', '>=', monthStartMs)
                    .get();
                
                let monthDuration = 0;
                const studyDaysSet = new Set();
                monthSessionsSnapshot.forEach(doc => {
                    const session = doc.data();
                    monthDuration += session.duration || 0;
                    const sessionDate = new Date(session.startTime);
                    const dateKey = sessionDate.toISOString().split('T')[0];
                    studyDaysSet.add(dateKey);
                });
                
                const monthMinutes = Math.round(monthDuration / 1000 / 60);
                const monthHours = Math.floor(monthMinutes / 60);
                const monthMins = monthMinutes % 60;
                document.getElementById('monthStudyTime').textContent = 
                    monthHours + 'æ™‚é–“' + monthMins + 'åˆ†';
                
                document.getElementById('monthStudyDays').textContent = studyDaysSet.size + 'æ—¥';
                
            } catch (error) {
                console.error('çµ±è¨ˆå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
            
            // v8.02.1: ãƒ‡ãƒƒã‚­ã”ã¨ã®çµ±è¨ˆ
            displayDeckStats();
            
            // v8.02.3: Firestoreä½¿ç”¨çŠ¶æ³ã‚’æ›´æ–°
            updateFirestoreUsage();
            
            // v14.02.1: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨é‡ã‚’è¨ˆç®—
            calculateStorageUsage();
            
            // v14.02.2: ã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¨ˆç®—
            previewSessionDeletion();
            
            console.log('çµ±è¨ˆè¡¨ç¤ºå®Œäº†');
        }
        
        // v8.02.1: ãƒ‡ãƒƒã‚­ã”ã¨ã®çµ±è¨ˆã‚’è¡¨ç¤º
        function displayDeckStats() {
            const deckStatsEl = document.getElementById('deckStats');
            if (!deckStatsEl) return;
            
            if (decks.length === 0) {
                deckStatsEl.innerHTML = '<p style="color: #999;">ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            const now = Date.now();
            let html = '';
            
            decks.forEach(deck => {
                const deckCards = cards.filter(c => c.deckId === deck.id);
                if (deckCards.length === 0) return;
                
                let newCount = 0;
                let learningCount = 0;
                let reviewCount = 0;
                let dueCount = 0;
                
                deckCards.forEach(card => {
                    const c = initializeCard(card);
                    if (c.state === 'new') newCount++;
                    else if (c.state === 'learning' || c.state === 'relearning') learningCount++;
                    else if (c.state === 'review') reviewCount++;
                    
                    if (!c.nextReview || c.nextReview <= now) dueCount++;
                });
                
                html += `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #667eea;">
                        <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px;">${deck.name}</div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; font-size: 14px;">
                            <div>
                                <span style="color: #666;">ç·ã‚«ãƒ¼ãƒ‰æ•°:</span>
                                <strong>${deckCards.length}</strong>
                            </div>
                            <div>
                                <span style="color: #e74c3c;">æ–°è¦:</span>
                                <strong>${newCount}</strong>
                            </div>
                            <div>
                                <span style="color: #f39c12;">å­¦ç¿’ä¸­:</span>
                                <strong>${learningCount}</strong>
                            </div>
                            <div>
                                <span style="color: #3498db;">å¾©ç¿’:</span>
                                <strong>${reviewCount}</strong>
                            </div>
                            <div>
                                <span style="color: #27ae60;">ä»Šæ—¥å­¦ç¿’å¯èƒ½:</span>
                                <strong>${dueCount}</strong>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            deckStatsEl.innerHTML = html;
        }
        
        window.addEventListener('load', async () => {
            if ('showOpenFilePicker' in window) {
                await initIndexedDB();
            } else {
                useFileSystemAPI = false;
            }
            
            loadInstantDeleteSetting();
            
            // v8.01.1: ãƒ‡ãƒƒã‚­è¨­å®šã‚’èª­ã¿è¾¼ã¿
            loadDeckSettings();
            
            // v8.02.4: ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚’åˆæœŸåŒ–
            initGlobalSettings();
            
            // v14.02.7: è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åˆæœŸåŒ–
            try {
                await initBackupDB();
                await loadAutoBackupSettings();
            } catch (error) {
                console.error('è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
            
            // v14.02.10: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆåˆæœŸåŒ–
            try {
                await updateStorageAlert();
            } catch (error) {
                console.error('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
            
            // v8.02.3: åˆæœŸè­¦å‘Šãƒã‚§ãƒƒã‚¯
            const currentWrites = getWriteCount();
            if (currentWrites >= FIRESTORE_DAILY_LIMIT * 0.8) {
                showWriteLimitWarning(currentWrites);
            }
            
            // v5.01: ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã®å¤‰æ›´ã‚’ç›£è¦–ã—ã¦ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
            const clozeText = document.getElementById('clozeText');
            if (clozeText) {
                clozeText.addEventListener('input', updateClozePreview);
                updateClozePreview(); // åˆæœŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
            }
            
            const editClozeText = document.getElementById('editClozeText');
            if (editClozeText) {
                editClozeText.addEventListener('input', updateEditClozePreview);
            }
        });
        
        // ========== v8.00: Ankiæ”¹è‰¯ç‰ˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  ==========
        
        // ã‚«ãƒ¼ãƒ‰ã®åˆæœŸåŒ–ï¼ˆæ–°è¦ã‚«ãƒ¼ãƒ‰ç”¨ï¼‰
        function initializeCard(card) {
            if (!card.state) {
                card.state = 'new';
                card.easeFactor = defaultStudySettings.startingEase;
                card.interval = 0;
                card.learningStep = 0;
                card.repetitions = 0;
                card.nextReview = Date.now();
                card.lastReviewed = null;
                card.lapses = 0;
            }
            return card;
        }
        
        // æ¬¡å›å¾©ç¿’æ—¥æ™‚ã‚’è¨ˆç®—
        function calculateNextReview(card, rating, settings = defaultStudySettings) {
            const now = Date.now();
            let newInterval = 0;
            let newState = card.state;
            
            if (card.state === 'new' || card.state === 'learning') {
                // æ–°è¦ã‚«ãƒ¼ãƒ‰ã¾ãŸã¯å­¦ç¿’ä¸­ã‚«ãƒ¼ãƒ‰
                if (rating === 'again') {
                    // æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã«æˆ»ã‚‹
                    card.learningStep = 0;
                    newInterval = settings.learningSteps[0] * 60 * 1000; // ãƒŸãƒªç§’ã«å¤‰æ›
                    newState = 'learning';
                } else if (rating === 'hard') {
                    // ç¾åœ¨ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç¶­æŒ
                    const step = Math.min(card.learningStep, settings.learningSteps.length - 1);
                    newInterval = settings.learningSteps[step] * 60 * 1000;
                    newState = 'learning';
                } else if (rating === 'good') {
                    // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸é€²ã‚€
                    card.learningStep++;
                    if (card.learningStep >= settings.learningSteps.length) {
                        // å’æ¥­ â†’ ReviewçŠ¶æ…‹ã¸
                        newState = 'review';
                        newInterval = settings.graduatingInterval * 24 * 60 * 60 * 1000;
                        card.interval = settings.graduatingInterval;
                        card.repetitions = 1;
                    } else {
                        newInterval = settings.learningSteps[card.learningStep] * 60 * 1000;
                        newState = 'learning';
                    }
                } else if (rating === 'easy') {
                    // å³åº§ã«å’æ¥­
                    newState = 'review';
                    newInterval = settings.easyInterval * 24 * 60 * 60 * 1000;
                    card.interval = settings.easyInterval;
                    card.repetitions = 1;
                }
            } else if (card.state === 'review' || card.state === 'relearning') {
                // å¾©ç¿’ã‚«ãƒ¼ãƒ‰ã¾ãŸã¯å†å­¦ç¿’ã‚«ãƒ¼ãƒ‰
                if (rating === 'again') {
                    // å†å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã¸
                    newState = 'relearning';
                    card.learningStep = 0;
                    newInterval = settings.learningSteps[0] * 60 * 1000;
                    card.lapses = (card.lapses || 0) + 1;
                    card.easeFactor = Math.max(1.3, card.easeFactor - 0.2);
                    card.repetitions = 0;
                } else if (rating === 'hard') {
                    newInterval = card.interval * 1.2 * settings.intervalModifier * 24 * 60 * 60 * 1000;
                    card.interval = Math.round(card.interval * 1.2 * settings.intervalModifier);
                    card.easeFactor = Math.max(1.3, card.easeFactor - 0.15);
                    card.repetitions++;
                } else if (rating === 'good') {
                    newInterval = card.interval * card.easeFactor * settings.intervalModifier * 24 * 60 * 60 * 1000;
                    card.interval = Math.round(card.interval * card.easeFactor * settings.intervalModifier);
                    card.repetitions++;
                } else if (rating === 'easy') {
                    newInterval = card.interval * card.easeFactor * settings.easyBonus * settings.intervalModifier * 24 * 60 * 60 * 1000;
                    card.interval = Math.round(card.interval * card.easeFactor * settings.easyBonus * settings.intervalModifier);
                    card.easeFactor += 0.15;
                    card.repetitions++;
                }
                
                // æœ€å¤§é–“éš”ã§ã‚­ãƒ£ãƒƒãƒ—
                card.interval = Math.min(card.interval, settings.maximumInterval);
                newInterval = Math.min(newInterval, settings.maximumInterval * 24 * 60 * 60 * 1000);
            }
            
            card.state = newState;
            card.nextReview = now + newInterval;
            card.lastReviewed = now;
            
            return card;
        }
        
        // æ¬¡å›å‡ºé¡Œæ™‚é–“ã‚’äººé–“ãŒèª­ã‚ã‚‹å½¢å¼ã§è¡¨ç¤º
        function formatNextReviewTime(milliseconds) {
            const minutes = Math.round(milliseconds / (60 * 1000));
            const hours = Math.round(milliseconds / (60 * 60 * 1000));
            const days = Math.round(milliseconds / (24 * 60 * 60 * 1000));
            
            if (minutes < 1) return '1åˆ†';
            if (minutes < 60) return `${minutes}åˆ†`;
            if (hours < 24) return `${hours}æ™‚é–“`;
            if (days === 1) return '1æ—¥';
            if (days < 31) return `${days}æ—¥`;
            if (days < 365) return `${Math.round(days / 30)}ãƒ¶æœˆ`;
            return `${Math.round(days / 365)}å¹´`;
        }

        function updateSyncStatus(status) {
            const statusEl = document.getElementById('syncStatus');
            if (status === 'synced') {
                statusEl.textContent = 'âœ… åŒæœŸå®Œäº†';
                statusEl.className = 'sync-status synced';
            } else if (status === 'syncing') {
                statusEl.textContent = 'ğŸ”„ åŒæœŸä¸­...';
                statusEl.className = 'sync-status syncing';
            } else {
                statusEl.textContent = 'âš ï¸ åŒæœŸã‚¨ãƒ©ãƒ¼';
                statusEl.className = 'sync-status';
            }
        }

        // v14.02.1.2: ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚¤ãƒ™ãƒ³ãƒˆä¸è¦ã«ä¿®æ­£ï¼‰
        async function switchTab(tab) {
            // ã™ã¹ã¦ã®ã‚¿ãƒ–ã¨ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã® active ã‚’å‰Šé™¤
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            
            // v14.02.1.2: ã‚¿ãƒ–ã®onclickå±æ€§ã‹ã‚‰å¯¾è±¡ã‚’ç‰¹å®šã—ã¦ç›´æ¥activeã‚’ä»˜ä¸
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(t => {
                const onclickAttr = t.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${tab}'`)) {
                    t.classList.add('active');
                }
            });
            
            // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
            const section = document.getElementById(tab + '-section');
            if (section) {
                section.classList.add('active');
            }
            
            // ã‚¿ãƒ–ã”ã¨ã®åˆæœŸåŒ–å‡¦ç†
            if (tab === 'home') {
                loadDecks();
            } else if (tab === 'cards') {
                currentIndex = 0;
                showingQuestion = true;
                displayCard();
                displayCardListWithPagination();
            } else if (tab === 'study') {
                // v8.00: å­¦ç¿’ã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ãƒ‡ãƒƒã‚­ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’æ›´æ–°
                updateStudyDeckSelector();
            } else if (tab === 'stats') {
                // v8.02: çµ±è¨ˆã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆæ™‚ã«çµ±è¨ˆã‚’æ›´æ–°
                await updateStatsDisplay();
                
                // v14.02.8.4: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã‚’è¨ˆç®—ã—ã¦ã‹ã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ›´æ–°
                try {
                    console.log('çµ±è¨ˆã‚¿ãƒ–: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã‚’è¨ˆç®—ä¸­...');
                    const storageInfo = await calculateStorageUsage();
                    console.log('çµ±è¨ˆã‚¿ãƒ–: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã‚’å–å¾—:', storageInfo);
                    
                    if (storageInfo) {
                        await updateStorageAlert();
                        console.log('çµ±è¨ˆã‚¿ãƒ–: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ãƒ©ãƒ¼ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ');
                    } else {
                        console.warn('çµ±è¨ˆã‚¿ãƒ–: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æƒ…å ±ã®å–å¾—ã«å¤±æ•—');
                    }
                } catch (err) {
                    console.error('çµ±è¨ˆã‚¿ãƒ–: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å‡¦ç†ã‚¨ãƒ©ãƒ¼:', err);
                }
            } else if (tab === 'settings') {
                // v8.02.4: è¨­å®šã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆæ™‚ã«è¨­å®šUIã‚’èª­ã¿è¾¼ã¿
                loadGlobalSettingsUI();
            }
        }
        
        // v8.00: å­¦ç¿’ç”¨ãƒ‡ãƒƒã‚­ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’æ›´æ–°
        function updateStudyDeckSelector() {
            const selector = document.getElementById('studyDeckId');
            if (!selector) return;
            
            let options = '<option value="">ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„</option>';
            
            function buildOptions(parentId = null, prefix = '') {
                const children = decks.filter(d => {
                    if (parentId === null) return !d.parentId;
                    return d.parentId === parentId;
                });
                
                children.forEach(deck => {
                    const displayName = prefix + deck.name;
                    options += `<option value="${deck.id}">${displayName}</option>`;
                    buildOptions(deck.id, displayName + ' > ');
                });
            }
            
            buildOptions();
            selector.innerHTML = options;
        }
        
        // v8.00: å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³èª­ã¿è¾¼ã¿ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
        function loadStudySession() {
            // ã“ã®é–¢æ•°ã¯ç¾åœ¨ä½¿ç”¨ã—ã¦ã„ã¾ã›ã‚“
            // çµ±è¨ˆã®ç¢ºèªã¯å­¦ç¿’é–‹å§‹æ™‚ã«è¡Œã‚ã‚Œã¾ã™
        }
        
        // v8.00: å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹
        async function startStudySession() {
            const deckId = document.getElementById('studyDeckId').value;
            if (!deckId) {
                alert('ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // v8.02.3: æ›¸ãè¾¼ã¿ä¸Šé™ã‚’ãƒã‚§ãƒƒã‚¯
            const currentWrites = getWriteCount();
            if (currentWrites >= FIRESTORE_DAILY_LIMIT * 0.8) {
                showWriteLimitWarning(currentWrites);
            }
            
            console.log('=== v8.01.1 å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ ===');
            console.log('é¸æŠãƒ‡ãƒƒã‚­ID:', deckId);
            
            // v8.01: è¨­å®šã‚’å–å¾—
            studySession.deckId = deckId;
            const includeSubdecks = document.getElementById('includeSubdecks').checked;
            
            studySession.settings = {
                newCardsPerDay: parseInt(document.getElementById('newCardsLimit').value) || 20,
                reviewCardsPerDay: parseInt(document.getElementById('reviewCardsLimit').value) || 200,
                studyMode: document.getElementById('studyMode').value,
                includeSubdecks: includeSubdecks,
                newCardOrder: document.getElementById('newCardOrder').value, // v8.01.1
                reviewCardOrder: document.getElementById('reviewCardOrder').value, // v8.01.1
                mixNewAndReview: document.getElementById('mixNewAndReview').checked // v8.01.2
            };
            
            // v8.01.1: ã‚µãƒ–ãƒ‡ãƒƒã‚­è¨­å®šã‚’ä¿å­˜
            setDeckSetting(deckId, 'includeSubdecks', includeSubdecks);
            
            console.log('å­¦ç¿’è¨­å®š:', studySession.settings);
            
            // v8.01: ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’å«ã‚€ã‚«ãƒ¼ãƒ‰å–å¾—
            let deckCards = [];
            if (studySession.settings.includeSubdecks) {
                const targetDeckIds = [deckId];
                const getChildDeckIds = (parentId) => {
                    const children = decks.filter(d => d.parentId === parentId);
                    children.forEach(child => {
                        targetDeckIds.push(child.id);
                        getChildDeckIds(child.id);
                    });
                };
                getChildDeckIds(deckId);
                console.log('å¯¾è±¡ãƒ‡ãƒƒã‚­IDï¼ˆã‚µãƒ–ãƒ‡ãƒƒã‚­å«ã‚€ï¼‰:', targetDeckIds);
                deckCards = cards.filter(c => targetDeckIds.includes(c.deckId));
            } else {
                deckCards = cards.filter(c => c.deckId === deckId);
            }
            
            console.log('ãƒ‡ãƒƒã‚­å†…ã‚«ãƒ¼ãƒ‰æ•°:', deckCards.length);
            
            // v8.00.1: æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–ã—ã¦Firestoreã«ä¿å­˜
            const updatePromises = [];
            deckCards = deckCards.map(card => {
                const needsInitialization = !card.state;
                const initializedCard = initializeCard(card);
                
                if (needsInitialization) {
                    console.log('åˆæœŸåŒ–:', card.id);
                    updatePromises.push(
                        db.collection('flashcards').doc(card.id).update({
                            state: initializedCard.state,
                            easeFactor: initializedCard.easeFactor,
                            interval: initializedCard.interval,
                            learningStep: initializedCard.learningStep,
                            repetitions: initializedCard.repetitions,
                            nextReview: initializedCard.nextReview,
                            lastReviewed: initializedCard.lastReviewed,
                            lapses: initializedCard.lapses
                        })
                    );
                }
                
                return initializedCard;
            });
            
            if (updatePromises.length > 0) {
                try {
                    await Promise.all(updatePromises);
                    console.log(`${updatePromises.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ`);
                } catch (error) {
                    console.error('ã‚«ãƒ¼ãƒ‰åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            console.log('åˆæœŸåŒ–å¾Œã®ã‚«ãƒ¼ãƒ‰:', deckCards);
            
            // v8.01.3: å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ï¼ˆnextReviewãŒæœªæ¥ã®Learning/Relearningã‚«ãƒ¼ãƒ‰ï¼‰ã‚’ãƒã‚§ãƒƒã‚¯
            const now = Date.now();
            const waitingCards = deckCards.filter(card => {
                const isWaiting = card.nextReview && card.nextReview > now;
                const isLearningState = card.state === 'learning' || card.state === 'relearning';
                return isWaiting && isLearningState;
            });
            
            console.log('å¾…æ©Ÿã‚«ãƒ¼ãƒ‰æ•°:', waitingCards.length);
            
            // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
            let includeWaitingCards = false;
            if (waitingCards.length > 0) {
                const waitingMinutes = Math.ceil((Math.min(...waitingCards.map(c => c.nextReview)) - now) / 60000);
                const confirmed = confirm(
                    `å¾…æ©Ÿä¸­ã®ã‚«ãƒ¼ãƒ‰ãŒ${waitingCards.length}æšã‚ã‚Šã¾ã™ã€‚\n` +
                    `ï¼ˆã‚ã¨ç´„${waitingMinutes}åˆ†ã§å­¦ç¿’å¯èƒ½ï¼‰\n\n` +
                    `å¾…æ©Ÿæ™‚é–“ã‚’å¾…ãŸãšã«ã€ã™ãã«å­¦ç¿’ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ`
                );
                includeWaitingCards = confirmed;
                console.log('å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã‚’å«ã‚ã‚‹:', includeWaitingCards);
            }
            
            // ä»Šæ—¥å­¦ç¿’ã™ã¹ãã‚«ãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            let dueCards;
            if (includeWaitingCards) {
                // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã‚‚å«ã‚ã‚‹ï¼ˆæœŸé™ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                dueCards = deckCards.filter(card => {
                    // æœŸé™åˆ°é”ã‚«ãƒ¼ãƒ‰ ã¾ãŸã¯ å¾…æ©Ÿã‚«ãƒ¼ãƒ‰
                    return !card.nextReview || card.nextReview <= now || 
                           (waitingCards.includes(card));
                });
                console.log('æœŸé™åˆ°é”ã‚«ãƒ¼ãƒ‰ + å¾…æ©Ÿã‚«ãƒ¼ãƒ‰:', dueCards.length);
            } else {
                // é€šå¸¸é€šã‚Šï¼ˆæœŸé™åˆ°é”ã‚«ãƒ¼ãƒ‰ã®ã¿ï¼‰
                dueCards = deckCards.filter(card => {
                    return !card.nextReview || card.nextReview <= now;
                });
                console.log('æœŸé™åˆ°é”ã‚«ãƒ¼ãƒ‰æ•°:', dueCards.length);
            }
            
            // v8.01: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            if (studySession.settings.studyMode === 'new') {
                dueCards = dueCards.filter(c => c.state === 'new');
                console.log('æ–°è¦ã‚«ãƒ¼ãƒ‰ã®ã¿:', dueCards.length);
            } else if (studySession.settings.studyMode === 'review') {
                dueCards = dueCards.filter(c => c.state === 'review' || c.state === 'relearning');
                console.log('å¾©ç¿’ã‚«ãƒ¼ãƒ‰ã®ã¿:', dueCards.length);
            }
            
            // v8.01: æšæ•°åˆ¶é™ã‚’é©ç”¨
            const newCards = dueCards.filter(c => c.state === 'new');
            const reviewCards = dueCards.filter(c => c.state === 'review' || c.state === 'relearning' || c.state === 'learning');
            
            // v8.01.1: å‡ºé¡Œé †ã«ã‚ˆã‚‹ã‚½ãƒ¼ãƒˆ
            if (studySession.settings.newCardOrder === 'random') {
                newCards.sort(() => Math.random() - 0.5);
                console.log('æ–°è¦ã‚«ãƒ¼ãƒ‰: ãƒ©ãƒ³ãƒ€ãƒ é †');
            } else {
                // è¿½åŠ é †ï¼ˆcreatedAtã§ã‚½ãƒ¼ãƒˆï¼‰
                newCards.sort((a, b) => {
                    const timeA = a.createdAt?.toMillis?.() || 0;
                    const timeB = b.createdAt?.toMillis?.() || 0;
                    return timeA - timeB;
                });
                console.log('æ–°è¦ã‚«ãƒ¼ãƒ‰: è¿½åŠ é †');
            }
            
            if (studySession.settings.reviewCardOrder === 'random') {
                reviewCards.sort(() => Math.random() - 0.5);
                console.log('å¾©ç¿’ã‚«ãƒ¼ãƒ‰: ãƒ©ãƒ³ãƒ€ãƒ é †');
            } else {
                // æœŸé™é †ï¼ˆnextReviewã§ã‚½ãƒ¼ãƒˆï¼‰
                reviewCards.sort((a, b) => (a.nextReview || 0) - (b.nextReview || 0));
                console.log('å¾©ç¿’ã‚«ãƒ¼ãƒ‰: æœŸé™é †');
            }
            
            const limitedNewCards = newCards.slice(0, studySession.settings.newCardsPerDay);
            const limitedReviewCards = reviewCards.slice(0, studySession.settings.reviewCardsPerDay);
            
            console.log(`æ–°è¦ã‚«ãƒ¼ãƒ‰: ${newCards.length}æš â†’ ${limitedNewCards.length}æšï¼ˆä¸Šé™: ${studySession.settings.newCardsPerDay}ï¼‰`);
            console.log(`å¾©ç¿’ã‚«ãƒ¼ãƒ‰: ${reviewCards.length}æš â†’ ${limitedReviewCards.length}æšï¼ˆä¸Šé™: ${studySession.settings.reviewCardsPerDay}ï¼‰`);
            
            studySession.cards = [...limitedNewCards, ...limitedReviewCards];
            studySession.waitingCards = []; // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã¯ç©ºã§ã‚¹ã‚¿ãƒ¼ãƒˆ
            
            // v8.01.2: æ–°è¦ã¨å¾©ç¿’ã‚’æ··ãœã‚‹è¨­å®š
            if (studySession.settings.mixNewAndReview) {
                // å®Œå…¨ã«ãƒ©ãƒ³ãƒ€ãƒ ã§æ··ãœã‚‹
                studySession.cards.sort(() => Math.random() - 0.5);
                console.log('æ–°è¦ã¨å¾©ç¿’ã‚’æ··ãœã‚‹: ONï¼ˆå®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ ï¼‰');
            } else {
                // çŠ¶æ…‹åˆ¥ã«ã‚½ãƒ¼ãƒˆï¼ˆæ–°è¦â†’å­¦ç¿’ä¸­â†’å¾©ç¿’â†’å†å­¦ç¿’ï¼‰
                studySession.cards.sort((a, b) => {
                    const stateOrder = { new: 0, learning: 1, review: 2, relearning: 3 };
                    return stateOrder[a.state] - stateOrder[b.state];
                });
                console.log('æ–°è¦ã¨å¾©ç¿’ã‚’æ··ãœã‚‹: OFFï¼ˆæ–°è¦â†’å¾©ç¿’ã®é †ï¼‰');
            }
            
            console.log('å­¦ç¿’å¯¾è±¡ã‚«ãƒ¼ãƒ‰æ•°:', studySession.cards.length);
            
            if (studySession.cards.length === 0) {
                alert('æœ¬æ—¥å­¦ç¿’ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã¯ã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // çµ±è¨ˆã‚’æ›´æ–°
            updateStudyStatsV2();
            
            console.log('çµ±è¨ˆ:', studySession.stats);
            
            // UIã‚’åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('studyDeckSelector').style.display = 'none';
            document.getElementById('studyCardDisplay').style.display = 'block';
            document.getElementById('studyComplete').style.display = 'none';
            
            // æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
            studySession.currentCardIndex = 0;
            studySession.showingAnswer = false;
            displayStudyCard();
            
            // v8.02.3: å­¦ç¿’é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²
            studySession.sessionStart = Date.now();
            studySession.sessionRatings = {
                again: 0,
                hard: 0,
                good: 0,
                easy: 0
            };
            // v8.02.2: Ankiå¼æ™‚é–“è¨ˆæ¸¬ã®åˆæœŸåŒ–
            studySession.currentCardStartTime = null;
            studySession.totalStudyDuration = 0;
            console.log('å­¦ç¿’é–‹å§‹æ™‚åˆ»:', new Date(studySession.sessionStart));
            
            console.log('=== v8.02.2 å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹å®Œäº† ===');
        }
        
        // v8.00: å­¦ç¿’çµ±è¨ˆã‚’æ›´æ–°
        function updateStudyStatsV2() {
            console.log('=== çµ±è¨ˆæ›´æ–°V2 ===');
            console.log('studySession:', studySession);
            console.log('studySession.cards:', studySession.cards);
            console.log('cardsé…åˆ—ã®å‹:', Array.isArray(studySession.cards));
            console.log('ã‚«ãƒ¼ãƒ‰æ•°:', studySession.cards ? studySession.cards.length : 0);
            console.log('å¾…æ©Ÿã‚«ãƒ¼ãƒ‰æ•°:', studySession.waitingCards ? studySession.waitingCards.length : 0);
            
            if (!studySession.cards || !Array.isArray(studySession.cards)) {
                console.error('studySession.cardsãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // å„ã‚«ãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
            studySession.cards.forEach((c, i) => {
                console.log(`ã‚«ãƒ¼ãƒ‰${i}: state="${c.state}", type="${c.type}", id=${c.id}`);
            });
            
            const newCount = studySession.cards.filter(c => {
                return c.state === 'new';
            }).length;
            
            studySession.stats = {
                new: newCount,
                learning: studySession.cards.filter(c => c.state === 'learning').length,
                review: studySession.cards.filter(c => c.state === 'review').length,
                relearning: studySession.cards.filter(c => c.state === 'relearning').length
            };
            
            console.log('è¨ˆç®—ã•ã‚ŒãŸçµ±è¨ˆV2:', studySession.stats);
            
            document.getElementById('newCardsCount').textContent = studySession.stats.new;
            document.getElementById('learningCardsCount').textContent = studySession.stats.learning;
            document.getElementById('reviewCardsCount').textContent = studySession.stats.review;
            document.getElementById('relearnCardsCount').textContent = studySession.stats.relearning;
            
            // v8.01: å¾…æ©Ÿã‚«ãƒ¼ãƒ‰æ•°ã‚’è¡¨ç¤º
            const waitingCount = studySession.waitingCards ? studySession.waitingCards.length : 0;
            document.getElementById('waitingCardsCount').textContent = waitingCount;
            const waitingInfo = document.getElementById('waitingCardsInfo');
            if (waitingCount > 0) {
                waitingInfo.style.display = 'block';
            } else {
                waitingInfo.style.display = 'none';
            }
            
            console.log('=== çµ±è¨ˆæ›´æ–°V2å®Œäº† ===');
        }
        
        // v8.00: å­¦ç¿’ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
        function displayStudyCard() {
            // v8.01.4: å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦æœŸé™åˆ°é”ã—ãŸã‚‚ã®ã‚’ãƒ¡ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã«æˆ»ã™ï¼ˆAnkiå¼ï¼‰
            const now = Date.now();
            const dueWaitingCards = [];
            const remainingWaitingCards = [];
            
            studySession.waitingCards.forEach(card => {
                if (card.nextReview && card.nextReview <= now) {
                    dueWaitingCards.push(card);
                } else {
                    remainingWaitingCards.push(card);
                }
            });
            
            if (dueWaitingCards.length > 0) {
                console.log(`å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ ${dueWaitingCards.length}æšãŒæœŸé™åˆ°é” â†’ ãƒ¡ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã«æŒ¿å…¥`);
                
                // ãƒ¡ã‚¤ãƒ³ã‚­ãƒ¥ãƒ¼ã®ç¾åœ¨ä½ç½®ã®æ¬¡ã«æŒ¿å…¥
                const insertPosition = studySession.currentCardIndex + 1;
                studySession.cards.splice(insertPosition, 0, ...dueWaitingCards);
                
                // å¾…æ©Ÿã‚­ãƒ¥ãƒ¼ã‚’æ›´æ–°
                studySession.waitingCards = remainingWaitingCards;
                
                // çµ±è¨ˆã‚’æ›´æ–°
                updateStudyStatsV2();
            }
            
            // v8.01: é€šå¸¸ã‚«ãƒ¼ãƒ‰ãŒå…¨ã¦çµ‚äº†ã—ãŸå ´åˆ
            if (studySession.currentCardIndex >= studySession.cards.length) {
                if (studySession.waitingCards && studySession.waitingCards.length > 0) {
                    // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆ
                    showWaitingCardsPrompt();
                } else {
                    // å®Œå…¨ã«çµ‚äº†
                    showStudyComplete();
                }
                return;
            }
            
            const card = studySession.cards[studySession.currentCardIndex];
            const container = document.getElementById('studyCardContainer');
            const controls = document.getElementById('studyControls');
            
            // v8.02.2: ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºæ™‚åˆ»ã‚’è¨˜éŒ²ï¼ˆAnkiå¼ï¼‰
            studySession.currentCardStartTime = Date.now();
            console.log('ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºé–‹å§‹:', new Date(studySession.currentCardStartTime));
            
            // ã‚«ãƒ¼ãƒ‰çŠ¶æ…‹ãƒãƒƒã‚¸
            const stateBadges = {
                new: 'ğŸ†• æ–°è¦',
                learning: 'ğŸ“– å­¦ç¿’ä¸­',
                review: 'ğŸ”„ å¾©ç¿’',
                relearning: 'ğŸ” å†å­¦ç¿’'
            };
            const stateBadge = stateBadges[card.state] || '';
            
            if (!studySession.showingAnswer) {
                // å•é¡Œé¢ã‚’è¡¨ç¤º
                let questionContent = '';
                
                if (card.type === 'cloze') {
                    // v10.03: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ - ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    let clozeIndex = 0;
                    questionContent = card.text.replace(clozeRegex, (match, num, answer) => {
                        const idx = clozeIndex++;
                        return `<span class="cloze-blank cloze-clickable" onclick="revealCloze(${idx})" id="cloze-${idx}" data-answer="${answer}">[...]</span>`;
                    });
                } else if (card.type === 'typing') {
                    // v10.03: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ - å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¡¨ç¤º
                    questionContent = `
                        <div style="margin-bottom: 20px;">${card.question.replace(/\n/g, '<br>')}</div>
                        <div class="typing-input-container">
                            <input type="text" id="studyTypingInput" class="typing-input" 
                                   placeholder="ç­”ãˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" 
                                   onkeypress="if(event.key==='Enter') checkTypingAnswer()">
                        </div>
                        <div id="studyTypingResult" style="margin-top: 15px;"></div>
                    `;
                } else {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ - v16.02.00: é€†è»¢åˆ¤å®šã‚’å‰Šé™¤ã€ã‚«ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾è¡¨ç¤º
                    questionContent = card.question;
                }
                
                // v10.03: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«ã‚ˆã£ã¦è¡¨ç¤ºæ–¹æ³•ã‚’å¤‰æ›´
                if (card.type === 'typing') {
                    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã¯å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãã§è¡¨ç¤ºï¼ˆã‚¯ãƒªãƒƒã‚¯ä¸å¯ï¼‰
                    container.innerHTML = `
                        <div class="card" style="cursor: default;">
                            <div class="card-category">${stateBadge}</div>
                            <div class="card-content">${questionContent}</div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div style="text-align: center;">
                            <button class="btn" onclick="checkTypingAnswer()">è§£ç­”ã™ã‚‹</button>
                        </div>
                    `;
                    
                    // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
                    setTimeout(() => {
                        const input = document.getElementById('studyTypingInput');
                        if (input) input.focus();
                    }, 100);
                } else if (card.type === 'cloze') {
                    // ç©´åŸ‹ã‚ã¯ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã§è¡¨ç¤º
                    container.innerHTML = `
                        <div class="card" style="cursor: default;">
                            <div class="card-category">${stateBadge}</div>
                            <div class="card-content">${questionContent}</div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div style="text-align: center;">
                            <button class="btn" onclick="showStudyAnswer()">ç­”ãˆã‚’è¡¨ç¤º</button>
                        </div>
                    `;
                } else {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ã¯å¾“æ¥é€šã‚Š
                    container.innerHTML = `
                        <div class="card" onclick="showStudyAnswer()" style="cursor: pointer;">
                            <div class="card-category">${stateBadge}</div>
                            <div class="card-content">${questionContent}</div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div style="text-align: center;">
                            <button class="btn" onclick="showStudyAnswer()">ç­”ãˆã‚’è¡¨ç¤º</button>
                        </div>
                    `;
                }
            } else {
                // ç­”ãˆé¢ã‚’è¡¨ç¤º
                let answerContent = '';
                
                if (card.type === 'cloze') {
                    // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    answerContent = card.text.replace(clozeRegex, (match, num, answer) => {
                        return `<span class="cloze-answer-shown">${answer}</span>`;
                    });
                } else if (card.type === 'typing') {
                    // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰
                    const question = card.question.replace(/\n/g, '<br>');
                    const answer = card.answer;
                    answerContent = `
                        <div style="margin-bottom: 20px;">${question}</div>
                        <div style="font-size: 18px; color: rgba(255,255,255,0.9);">
                            <strong>æ­£è§£:</strong> ${answer}
                        </div>
                    `;
                } else {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ - v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã¯æ—¢ã«å•é¡Œã¨ç­”ãˆãŒå…¥ã‚Œæ›¿ã‚ã£ã¦ã„ã‚‹ã®ã§ãã®ã¾ã¾è¡¨ç¤º
                    answerContent = card.answer;
                }
                
                container.innerHTML = `
                    <div class="card" style="cursor: default;">
                        <div class="card-category">${stateBadge}</div>
                        <div class="card-content">${answerContent}</div>
                    </div>
                `;
                
                // å„è©•ä¾¡ãƒœã‚¿ãƒ³ã®æ¬¡å›å‡ºé¡Œæ™‚é–“ã‚’è¨ˆç®—
                const timeAgain = formatNextReviewTime(defaultStudySettings.learningSteps[0] * 60 * 1000);
                let timeHard, timeGood, timeEasy;
                
                if (card.state === 'new' || card.state === 'learning') {
                    const currentStep = Math.min(card.learningStep, defaultStudySettings.learningSteps.length - 1);
                    timeHard = formatNextReviewTime(defaultStudySettings.learningSteps[currentStep] * 60 * 1000);
                    
                    if (card.learningStep + 1 >= defaultStudySettings.learningSteps.length) {
                        timeGood = formatNextReviewTime(defaultStudySettings.graduatingInterval * 24 * 60 * 60 * 1000);
                    } else {
                        timeGood = formatNextReviewTime(defaultStudySettings.learningSteps[card.learningStep + 1] * 60 * 1000);
                    }
                    
                    timeEasy = formatNextReviewTime(defaultStudySettings.easyInterval * 24 * 60 * 60 * 1000);
                } else {
                    timeHard = formatNextReviewTime(card.interval * 1.2 * 24 * 60 * 60 * 1000);
                    timeGood = formatNextReviewTime(card.interval * card.easeFactor * 24 * 60 * 60 * 1000);
                    timeEasy = formatNextReviewTime(card.interval * card.easeFactor * defaultStudySettings.easyBonus * 24 * 60 * 60 * 1000);
                }
                
                controls.innerHTML = `
                    <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-danger" onclick="rateCard('again')" style="min-width: 100px;">
                            <div>ã‚‚ã†ä¸€åº¦</div>
                            <div style="font-size: 12px; margin-top: 5px;">${timeAgain}</div>
                        </button>
                        <button class="btn btn-warning" onclick="rateCard('hard')" style="min-width: 100px;">
                            <div>é›£ã—ã„</div>
                            <div style="font-size: 12px; margin-top: 5px;">${timeHard}</div>
                        </button>
                        <button class="btn btn-success" onclick="rateCard('good')" style="min-width: 100px;">
                            <div>æ™®é€š</div>
                            <div style="font-size: 12px; margin-top: 5px;">${timeGood}</div>
                        </button>
                        <button class="btn" onclick="rateCard('easy')" style="min-width: 100px; background: #3498db;">
                            <div>ç°¡å˜</div>
                            <div style="font-size: 12px; margin-top: 5px;">${timeEasy}</div>
                        </button>
                    </div>
                `;
            }
        }
        
        // v10.03: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯è¡¨ç¤ºæ©Ÿèƒ½
        function revealCloze(index) {
            const clozeElement = document.getElementById(`cloze-${index}`);
            if (clozeElement && clozeElement.classList.contains('cloze-clickable')) {
                const answer = clozeElement.getAttribute('data-answer');
                clozeElement.textContent = answer;
                clozeElement.classList.remove('cloze-clickable');
                clozeElement.classList.add('cloze-revealed');
                clozeElement.style.backgroundColor = 'rgba(102, 126, 234, 0.3)';
                clozeElement.style.cursor = 'default';
                clozeElement.onclick = null;
            }
        }
        
        // v10.03: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®è§£ç­”ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½
        function checkTypingAnswer() {
            console.log('checkTypingAnswer called');
            
            try {
                const input = document.getElementById('studyTypingInput');
                const result = document.getElementById('studyTypingResult');
                
                console.log('Input element:', input);
                console.log('Result element:', result);
                
                if (!input || !result) {
                    console.error('Input or result element not found');
                    alert('ã‚¨ãƒ©ãƒ¼: å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                const userAnswer = input.value.trim();
                console.log('User answer:', userAnswer);
                
                if (!userAnswer) {
                    alert('ç­”ãˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return;
                }
                
                if (!studySession || !studySession.cards) {
                    console.error('studySession not initialized');
                    alert('ã‚¨ãƒ©ãƒ¼: å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const card = studySession.cards[studySession.currentCardIndex];
                console.log('Current card:', card);
                
                if (!card) {
                    console.error('Card not found');
                    alert('ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // v10.03.3: answerãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
                const correctAnswer = card.answer || '';
                if (!correctAnswer) {
                    console.error('Card answer is undefined or empty');
                    alert('ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¼ãƒ‰ã®æ­£è§£ãƒ‡ãƒ¼ã‚¿ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const caseSensitive = card.caseSensitive || false;
                
                console.log('Correct answer:', correctAnswer);
                console.log('Case sensitive:', caseSensitive);
                
                // æ­£èª¤åˆ¤å®š
                let isCorrect = false;
                if (caseSensitive) {
                    isCorrect = userAnswer === correctAnswer;
                } else {
                    // å¤§æ–‡å­—å°æ–‡å­—ãƒ»å…¨è§’åŠè§’ã‚’æ­£è¦åŒ–
                    const normalize = (str) => {
                        if (!str) return '';
                        return str.replace(/[A-Z]/g, c => c.toLowerCase())
                                  .replace(/[ï¼¡-ï¼º]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0).toLowerCase())
                                  .replace(/[ï½-ï½š]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0))
                                  .replace(/[ï¼-ï¼™]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0))
                                  .replace(/\s+/g, '');
                    };
                    const normalizedUser = normalize(userAnswer);
                    const normalizedCorrect = normalize(correctAnswer);
                    console.log('Normalized user:', normalizedUser);
                    console.log('Normalized correct:', normalizedCorrect);
                    isCorrect = normalizedUser === normalizedCorrect;
                }
                
                console.log('Is correct:', isCorrect);
                
                // v10.03.3: åˆ¤å®šçµæœã‚’ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ä¿å­˜ï¼ˆæ­£ç­”ç‡è¨ˆç®—ç”¨ï¼‰
                studySession.lastTypingResult = isCorrect;
                
                // çµæœè¡¨ç¤º
                input.disabled = true;
                if (isCorrect) {
                    input.className = 'typing-input correct';
                    result.innerHTML = `
                        <div style="color: #2ecc71; font-size: 18px; font-weight: bold;">
                            âœ… æ­£è§£ï¼
                        </div>
                    `;
                } else {
                    input.className = 'typing-input incorrect';
                    result.innerHTML = `
                        <div style="color: #e74c3c; font-size: 18px; font-weight: bold; margin-bottom: 10px;">
                            âŒ ä¸æ­£è§£
                        </div>
                        <div style="font-size: 16px; color: rgba(255,255,255,0.9);">
                            <strong>æ­£è§£:</strong> ${correctAnswer}
                        </div>
                    `;
                }
                
                // v10.03.3: 4ã¤ã®ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè©•ä¾¡ã‚’é¸æŠï¼‰
                // cardã¯æ—¢ã«ä¸Šã§å®£è¨€æ¸ˆã¿
                const settings = getStudySettings(card.deckId);
                
                // æ¬¡å›å¾©ç¿’æ™‚é–“ã‚’è¨ˆç®—ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
                let timeAgain = '1åˆ†';
                let timeHard = '10åˆ†';
                let timeGood = '10åˆ†';
                let timeEasy = '4æ—¥';
                
                if (card.state === 'new' || card.state === 'learning') {
                    timeAgain = `${settings.learningSteps[0]}åˆ†`;
                    timeHard = card.learningStep < settings.learningSteps.length ? 
                              `${settings.learningSteps[card.learningStep]}åˆ†` : `${settings.graduatingInterval}æ—¥`;
                    timeGood = card.learningStep + 1 < settings.learningSteps.length ?
                              `${settings.learningSteps[card.learningStep + 1]}åˆ†` : `${settings.graduatingInterval}æ—¥`;
                    timeEasy = `${settings.easyInterval}æ—¥`;
                } else {
                    timeAgain = `${settings.learningSteps[0]}åˆ†`;
                    timeHard = `${Math.round(card.interval * 1.2)}æ—¥`;
                    timeGood = `${Math.round(card.interval * card.easeFactor)}æ—¥`;
                    timeEasy = `${Math.round(card.interval * card.easeFactor * settings.easyBonus)}æ—¥`;
                }
                
                const controls = document.getElementById('studyControls');
                controls.innerHTML = `
                    <div style="text-align: center; margin-top: 20px;">
                        <div style="margin-bottom: 15px; color: rgba(255,255,255,0.8);">
                            å­¦ç¿’ã®é›£æ˜“åº¦ã‚’è©•ä¾¡ã—ã¦ãã ã•ã„
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                            <button class="btn" onclick="rateTypingCardWithJudgment('again')" style="min-width: 100px; background: #e74c3c;">
                                <div>ã‚‚ã†ä¸€åº¦</div>
                                <div style="font-size: 12px; margin-top: 5px;">${timeAgain}</div>
                            </button>
                            <button class="btn" onclick="rateTypingCardWithJudgment('hard')" style="min-width: 100px; background: #e67e22;">
                                <div>é›£ã—ã„</div>
                                <div style="font-size: 12px; margin-top: 5px;">${timeHard}</div>
                            </button>
                            <button class="btn" onclick="rateTypingCardWithJudgment('good')" style="min-width: 100px; background: #2ecc71;">
                                <div>æ™®é€š</div>
                                <div style="font-size: 12px; margin-top: 5px;">${timeGood}</div>
                            </button>
                            <button class="btn" onclick="rateTypingCardWithJudgment('easy')" style="min-width: 100px; background: #3498db;">
                                <div>ç°¡å˜</div>
                                <div style="font-size: 12px; margin-top: 5px;">${timeEasy}</div>
                            </button>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('checkTypingAnswer error:', error);
                alert('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        // v10.03.3: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®è©•ä¾¡ï¼ˆåˆ¤å®šçµæœã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼è©•ä¾¡ã‚’åˆ†é›¢ï¼‰
        async function rateTypingCardWithJudgment(userRating) {
            const card = studySession.cards[studySession.currentCardIndex];
            
            // åˆ¤å®šçµæœã‚’å–å¾—ï¼ˆæ­£ç­”ç‡è¨ˆç®—ç”¨ï¼‰
            const wasCorrect = studySession.lastTypingResult || false;
            
            // æ­£ç­”ç‡ã®è¨˜éŒ²ï¼šæ­£è§£ãªã‚‰repetitions++ã€ä¸æ­£è§£ãªã‚‰lapses++
            // ã“ã‚Œã¯rateCardé–¢æ•°å†…ã§å‡¦ç†ã•ã‚Œã‚‹
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠã—ãŸè©•ä¾¡ã§å­¦ç¿’é–“éš”ã‚’æ±ºå®š
            await rateCard(userRating);
        }
        
        // v8.00: ç­”ãˆã‚’è¡¨ç¤º
        function showStudyAnswer() {
            studySession.showingAnswer = true;
            displayStudyCard();
        }
        
        // v8.00: ã‚«ãƒ¼ãƒ‰ã‚’è©•ä¾¡
        async function rateCard(rating) {
            const card = studySession.cards[studySession.currentCardIndex];
            
            // v10.03.3: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®æ­£ç­”ç‡è¨˜éŒ²ï¼ˆå°‚ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
            if (card.type === 'typing' && studySession.lastTypingResult !== undefined) {
                // åˆ¤å®šçµæœã«åŸºã¥ã„ã¦æ­£ç­”ç‡ã‚’è¨˜éŒ²ï¼ˆSM-2ã¨ã¯ç‹¬ç«‹ï¼‰
                if (!card.typingCorrectCount) card.typingCorrectCount = 0;
                if (!card.typingTotalCount) card.typingTotalCount = 0;
                
                card.typingTotalCount++;
                if (studySession.lastTypingResult) {
                    card.typingCorrectCount++;
                    console.log('ã‚¿ã‚¤ãƒ”ãƒ³ã‚°åˆ¤å®š: æ­£è§£');
                } else {
                    console.log('ã‚¿ã‚¤ãƒ”ãƒ³ã‚°åˆ¤å®š: ä¸æ­£è§£');
                }
                
                console.log(`ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ­£ç­”ç‡: ${card.typingCorrectCount}/${card.typingTotalCount} = ${Math.round(card.typingCorrectCount/card.typingTotalCount*100)}%`);
                
                // åˆ¤å®šçµæœã‚’ã‚¯ãƒªã‚¢
                studySession.lastTypingResult = undefined;
            }
            
            // v8.02.3: è©•ä¾¡ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨˜éŒ²
            if (rating === 'again') studySession.sessionRatings.again++;
            else if (rating === 'hard') studySession.sessionRatings.hard++;
            else if (rating === 'good') studySession.sessionRatings.good++;
            else if (rating === 'easy') studySession.sessionRatings.easy++;
            
            console.log('è©•ä¾¡ã‚«ã‚¦ãƒ³ãƒˆ:', studySession.sessionRatings);
            
            // v8.02.2: ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºæ™‚é–“ã‚’è¨ˆç®—ãƒ»ç´¯ç©ï¼ˆAnkiå¼ï¼‰
            if (studySession.currentCardStartTime) {
                const cardEndTime = Date.now();
                const cardDuration = cardEndTime - studySession.currentCardStartTime;
                
                // ä¸Šé™é©ç”¨ï¼ˆ60ç§’ï¼‰
                const cappedDuration = Math.min(cardDuration, studySession.maxCardDuration);
                
                // ç´¯ç©æ™‚é–“ã«åŠ ç®—
                studySession.totalStudyDuration += cappedDuration;
                
                console.log('ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºæ™‚é–“:', {
                    actual: Math.round(cardDuration / 1000) + 'ç§’',
                    capped: Math.round(cappedDuration / 1000) + 'ç§’',
                    total: Math.round(studySession.totalStudyDuration / 1000) + 'ç§’'
                });
            }
            
            // Ankiæ”¹è‰¯ç‰ˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§æ¬¡å›å¾©ç¿’æ—¥ã‚’è¨ˆç®—
            // v8.02.4: ãƒ‡ãƒƒã‚­ã®è¨­å®šã‚’ä½¿ç”¨
            const settings = getStudySettings(card.deckId);
            calculateNextReview(card, rating, settings);
            
            console.log('è©•ä¾¡:', rating);
            console.log('æ›´æ–°å¾Œ:', {
                state: card.state,
                interval: card.interval,
                easeFactor: card.easeFactor,
                nextReview: new Date(card.nextReview)
            });
            
            // Firestoreã«ä¿å­˜
            try {
                // v8.02.3: ã‚«ãƒ¼ãƒ‰æƒ…å ±ã®ä¿å­˜
                // v10.03.3: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®æ­£ç­”ç‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
                const updateData = {
                    state: card.state,
                    easeFactor: card.easeFactor,
                    interval: card.interval,
                    learningStep: card.learningStep,
                    repetitions: card.repetitions,
                    nextReview: card.nextReview,
                    lastReviewed: card.lastReviewed,
                    lapses: card.lapses
                };
                
                // ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®å ´åˆã€æ­£ç­”ç‡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚ä¿å­˜
                if (card.type === 'typing') {
                    updateData.typingCorrectCount = card.typingCorrectCount || 0;
                    updateData.typingTotalCount = card.typingTotalCount || 0;
                }
                
                if (incrementWriteCounter()) {
                    await db.collection('flashcards').doc(card.id).update(updateData);
                }
                
                // v8.02.3: ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±ã®ä¿å­˜ï¼ˆã‚«ãƒ¼ãƒ‰ã”ã¨ï¼‰
                if (studySession.sessionStart && incrementWriteCounter()) {
                    const sessionId = `${studySession.sessionStart}_${studySession.deckId}`;
                    const totalRatings = studySession.sessionRatings.again + 
                                        studySession.sessionRatings.hard + 
                                        studySession.sessionRatings.good + 
                                        studySession.sessionRatings.easy;
                    
                    await db.collection('studySessions').doc(sessionId).set({
                        sessionId: sessionId,
                        deckId: studySession.deckId,
                        startTime: studySession.sessionStart,
                        lastUpdateTime: Date.now(),
                        duration: studySession.totalStudyDuration,
                        cardsStudied: totalRatings,
                        ratings: {
                            again: studySession.sessionRatings.again,
                            hard: studySession.sessionRatings.hard,
                            good: studySession.sessionRatings.good,
                            easy: studySession.sessionRatings.easy
                        },
                        isComplete: false,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            } catch (error) {
                console.error('ã‚«ãƒ¼ãƒ‰æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                if (error.code === 'resource-exhausted') {
                    showWriteLimitWarning(FIRESTORE_DAILY_LIMIT);
                }
            }
            
            // v8.01: Learning/RelearningçŠ¶æ…‹ã®ã‚«ãƒ¼ãƒ‰ã¯å¾…æ©Ÿã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
            if (card.state === 'learning' || card.state === 'relearning') {
                console.log('â†’ å¾…æ©Ÿã‚­ãƒ¥ãƒ¼ã«è¿½åŠ :', card.id);
                studySession.waitingCards.push(card);
            }
            
            // ç¾åœ¨ã®ã‚«ãƒ¼ãƒ‰ã‚’é…åˆ—ã‹ã‚‰å‰Šé™¤
            studySession.cards.splice(studySession.currentCardIndex, 1);
            
            // v8.01: é€šå¸¸ã‚«ãƒ¼ãƒ‰ãŒå…¨ã¦çµ‚äº†ã—ãŸã‹ç¢ºèª
            if (studySession.cards.length === 0) {
                if (studySession.waitingCards.length > 0) {
                    // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆ
                    showWaitingCardsPrompt();
                    return;
                } else {
                    // å®Œå…¨ã«çµ‚äº†
                    showStudyComplete();
                    return;
                }
            }
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç¯„å›²å¤–ãªã‚‰èª¿æ•´
            if (studySession.currentCardIndex >= studySession.cards.length) {
                studySession.currentCardIndex = 0;
            }
            
            studySession.showingAnswer = false;
            
            // çµ±è¨ˆã‚’æ›´æ–°
            updateStudyStatsV2();
            
            // ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
            displayStudyCard();
        }
        
        // v8.01: å­¦ç¿’å®Œå…¨å®Œäº†ç”»é¢ã‚’è¡¨ç¤º
        function showStudyComplete() {
            console.log('=== å­¦ç¿’å®Œäº† ===');
            
            document.getElementById('studyCardDisplay').style.display = 'none';
            
            const completeDiv = document.getElementById('studyComplete');
            completeDiv.innerHTML = `
                <h3>ğŸ‰ å­¦ç¿’å®Œäº†ï¼</h3>
                <p style="margin: 20px 0; font-size: 18px;">
                    ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼<br>
                    æœ¬æ—¥ã®å­¦ç¿’ã¯çµ‚äº†ã§ã™ã€‚
                </p>
                <button class="btn" onclick="endStudySession()">ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹</button>
            `;
            completeDiv.style.display = 'block';
        }
        
        // v8.01: å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ç¢ºèªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¡¨ç¤º
        function showWaitingCardsPrompt() {
            console.log('å¾…æ©Ÿã‚«ãƒ¼ãƒ‰æ•°:', studySession.waitingCards.length);
            
            // ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’éè¡¨ç¤º
            document.getElementById('studyCardDisplay').style.display = 'none';
            
            // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            const completeDiv = document.getElementById('studyComplete');
            completeDiv.innerHTML = `
                <h3>æ–°è¦ã‚«ãƒ¼ãƒ‰ãƒ»å¾©ç¿’ã‚«ãƒ¼ãƒ‰ãŒçµ‚äº†ã—ã¾ã—ãŸ</h3>
                <p style="margin: 20px 0;">
                    <strong style="color: #f39c12; font-size: 20px;">â³ å¾…æ©Ÿä¸­ã®ã‚«ãƒ¼ãƒ‰: ${studySession.waitingCards.length}æš</strong>
                </p>
                <p style="margin: 20px 0; color: #666;">
                    å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—ä¸­ã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚<br>
                    æ™‚é–“çµŒéå‰ã§ã™ãŒã€ç¶šã‘ã¦å­¦ç¿’ã—ã¾ã™ã‹ï¼Ÿ
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="startWaitingCardsStudy()">å­¦ç¿’ã™ã‚‹</button>
                    <button class="btn btn-secondary" onclick="endStudySession()">å­¦ç¿’ã‚’çµ‚äº†</button>
                </div>
            `;
            completeDiv.style.display = 'block';
        }
        
        // v8.01: å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã®å­¦ç¿’ã‚’é–‹å§‹
        function startWaitingCardsStudy() {
            console.log('=== å¾…æ©Ÿã‚«ãƒ¼ãƒ‰å­¦ç¿’é–‹å§‹ ===');
            
            // å¾…æ©Ÿã‚«ãƒ¼ãƒ‰ã‚’é€šå¸¸ã‚«ãƒ¼ãƒ‰ã«ç§»å‹•
            studySession.cards = studySession.waitingCards;
            studySession.waitingCards = [];
            
            // æ™‚é–“ã§ã‚½ãƒ¼ãƒˆï¼ˆæ—©ã„ã‚‚ã®ã‹ã‚‰ï¼‰
            studySession.cards.sort((a, b) => a.nextReview - b.nextReview);
            
            console.log('å¾…æ©Ÿã‚«ãƒ¼ãƒ‰å­¦ç¿’å¯¾è±¡:', studySession.cards.length);
            
            // UIã‚’åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('studyComplete').style.display = 'none';
            document.getElementById('studyCardDisplay').style.display = 'block';
            
            // æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
            studySession.currentCardIndex = 0;
            studySession.showingAnswer = false;
            
            // çµ±è¨ˆã‚’æ›´æ–°
            updateStudyStatsV2();
            
            displayStudyCard();
        }
        
        // v8.00: å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†
        async function endStudySession() {
            // v8.02.3: å­¦ç¿’å±¥æ­´ã®æœ€çµ‚æ›´æ–°
            if (studySession.sessionStart) {
                const sessionEnd = Date.now();
                const totalRatings = studySession.sessionRatings.again + 
                                    studySession.sessionRatings.hard + 
                                    studySession.sessionRatings.good + 
                                    studySession.sessionRatings.easy;
                
                if (totalRatings > 0) {
                    try {
                        // v8.02.3: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å®Œäº†çŠ¶æ…‹ã«æ›´æ–°
                        const sessionId = `${studySession.sessionStart}_${studySession.deckId}`;
                        const studyDuration = studySession.totalStudyDuration;
                        
                        if (incrementWriteCounter()) {
                            await db.collection('studySessions').doc(sessionId).set({
                                sessionId: sessionId,
                                deckId: studySession.deckId,
                                startTime: studySession.sessionStart,
                                endTime: sessionEnd,
                                duration: studyDuration,
                                cardsStudied: totalRatings,
                                ratings: {
                                    again: studySession.sessionRatings.again,
                                    hard: studySession.sessionRatings.hard,
                                    good: studySession.sessionRatings.good,
                                    easy: studySession.sessionRatings.easy
                                },
                                isComplete: true, // v8.02.3: å®Œäº†ãƒãƒ¼ã‚¯
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        console.log('å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†ï¼ˆAnkiå¼ï¼‰:', {
                            duration: Math.round(studyDuration / 1000 / 60) + 'åˆ†',
                            cardsStudied: totalRatings,
                            actualDuration: Math.round(studyDuration / 1000) + 'ç§’'
                        });
                    } catch (error) {
                        console.error('å­¦ç¿’å±¥æ­´ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                        if (error.code === 'resource-exhausted') {
                            showWriteLimitWarning(FIRESTORE_DAILY_LIMIT);
                        }
                    }
                }
            }
            
            document.getElementById('studyDeckSelector').style.display = 'block';
            document.getElementById('studyCardDisplay').style.display = 'none';
            document.getElementById('studyComplete').style.display = 'none';
            
            studySession = {
                deckId: null,
                cards: [],
                waitingCards: [], // v8.01
                currentCardIndex: 0,
                showingAnswer: false,
                stats: {
                    new: 0,
                    learning: 0,
                    review: 0,
                    relearning: 0
                },
                settings: { // v8.01
                    newCardsPerDay: 20,
                    reviewCardsPerDay: 200,
                    studyMode: 'mixed',
                    includeSubdecks: true,
                    newCardOrder: 'added', // v8.01.1
                    reviewCardOrder: 'due', // v8.01.1
                    mixNewAndReview: false // v8.01.2
                },
                // v8.02.3
                sessionStart: null,
                sessionRatings: {
                    again: 0,
                    hard: 0,
                    good: 0,
                    easy: 0
                },
                // v8.02.2: Ankiå¼æ™‚é–“è¨ˆæ¸¬
                currentCardStartTime: null,
                totalStudyDuration: 0,
                maxCardDuration: 60000
            };
        }

        // v5.01: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ‡ã‚Šæ›¿ãˆ
        function switchCardType(type) {
            currentCardType = type;
            
            // ã‚¿ãƒ–ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.card-type-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // å…¥åŠ›ã‚¨ãƒªã‚¢ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('basicCardInputs').style.display = 'none';
            document.getElementById('clozeCardInputs').style.display = 'none';
            document.getElementById('typingCardInputs').style.display = 'none';
            
            if (type === 'basic') {
                document.getElementById('basicCardInputs').style.display = 'block';
            } else if (type === 'cloze') {
                document.getElementById('clozeCardInputs').style.display = 'block';
                updateClozePreview();
            } else if (type === 'typing') {
                document.getElementById('typingCardInputs').style.display = 'block';
            }
        }

        // v5.01: ç©´åŸ‹ã‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
        function updateClozePreview() {
            const text = document.getElementById('clozeText').value;
            const preview = document.getElementById('clozePreview');
            
            if (!text.trim()) {
                preview.innerHTML = 'ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                return;
            }
            
            // {{c1::ç­”ãˆ}}å½¢å¼ã‚’æ¤œå‡ºã—ã¦è¡¨ç¤º
            const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
            let hasCloze = false;
            const displayText = text.replace(clozeRegex, (match, num, answer) => {
                hasCloze = true;
                return `<span class="cloze-blank">[ç©´${num}]</span>`;
            });
            
            if (hasCloze) {
                preview.innerHTML = displayText;
            } else {
                preview.innerHTML = text + '<br><span style="color: #999; font-size: 14px;">ï¼ˆç¯„å›²ã‚’é¸æŠã—ã¦ã€Œé¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰</span>';
            }
        }

        // v5.01: é¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«å¤‰æ›
        function insertCloze() {
            const textarea = document.getElementById('clozeText');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            if (start === end) {
                alert('ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const selectedText = text.substring(start, end);
            
            // æ—¢å­˜ã®ç©´åŸ‹ã‚ç•ªå·ã‚’å–å¾—
            const existingClozes = text.match(/\{\{c(\d+)::/g);
            let maxNum = 0;
            if (existingClozes) {
                existingClozes.forEach(match => {
                    const num = parseInt(match.match(/\d+/)[0]);
                    if (num > maxNum) maxNum = num;
                });
            }
            clozeCounter = maxNum + 1;
            
            const clozeTag = `{{c${clozeCounter}::${selectedText}}}`;
            const newText = text.substring(0, start) + clozeTag + text.substring(end);
            
            textarea.value = newText;
            clozeCounter++;
            
            updateClozePreview();
        }

        // v5.01: ç©´åŸ‹ã‚ã‚’å‰Šé™¤ï¼ˆæœ€å¾Œã®ç©´åŸ‹ã‚ã‚’å‰Šé™¤ï¼‰
        function removeCloze() {
            const textarea = document.getElementById('clozeText');
            let text = textarea.value;
            
            // æœ€å¾Œã®{{cN::xxx}}ã‚’è¦‹ã¤ã‘ã¦å‰Šé™¤
            const clozeRegex = /\{\{c\d+::([^}]+)\}\}/g;
            const matches = [...text.matchAll(clozeRegex)];
            
            if (matches.length === 0) {
                alert('å‰Šé™¤ã™ã‚‹ç©´åŸ‹ã‚ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const lastMatch = matches[matches.length - 1];
            const answer = lastMatch[1];
            text = text.substring(0, lastMatch.index) + answer + text.substring(lastMatch.index + lastMatch[0].length);
            
            textarea.value = text;
            clozeCounter = Math.max(1, clozeCounter - 1);
            
            updateClozePreview();
        }

        // v6.00: ã‚«ãƒ¼ãƒ‰è¿½åŠ ï¼ˆãƒ‡ãƒƒã‚­å¯¾å¿œï¼‰
        async function addCard() {
            const deckId = document.getElementById('deckId').value;
            
            // v6.00: ãƒ‡ãƒƒã‚­ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            if (!deckId) {
                alert('ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            updateSyncStatus('syncing');
            
            try {
                if (currentCardType === 'basic') {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰
                    const question = document.getElementById('question').value.trim();
                    const answer = document.getElementById('answer').value.trim();
                    const enableReverse = document.getElementById('enableReverse').checked;
                    
                    // v10.01: ã‚¿ã‚°å–å¾—
                    const tagsInput = document.getElementById('cardTags').value.trim();
                    const tags = tagsInput ? tagsInput.split(/\s+/).filter(t => t.length > 0) : [];
                    
                    if (!question || !answer) {
                        alert('å•é¡Œã¨ç­”ãˆã®ä¸¡æ–¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    // v16.02.00: é€†æ–¹å‘onã®å ´åˆã¯2æšåˆ†ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    const requiredWrites = enableReverse ? 2 : 1;
                    for (let i = 0; i < requiredWrites; i++) {
                        if (!incrementWriteCounter()) {
                            alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                            updateSyncStatus('synced');
                            return;
                        }
                    }
                    
                    // v16.02.00: å…ƒã®ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆ
                    const originalCardRef = await db.collection('flashcards').add({
                        type: 'basic',
                        deckId: deckId,
                        question: question,
                        answer: answer,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        order: cards.length, // v10.02: é †åºç•ªå·
                        state: 'new',
                        easeFactor: getStudySettings(deckId).startingEase,
                        interval: 0,
                        learningStep: 0,
                        repetitions: 0,
                        nextReview: Date.now(),
                        lastReviewed: null,
                        lapses: 0,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // v16.02.00: é€†æ–¹å‘onã®å ´åˆã¯é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚‚ä½œæˆ
                    if (enableReverse) {
                        const reverseCardRef = await db.collection('flashcards').add({
                            type: 'basic',
                            deckId: deckId,
                            question: answer,  // å•é¡Œã¨ç­”ãˆã‚’å…¥ã‚Œæ›¿ãˆ
                            answer: question,
                            tags: tags,
                            order: cards.length + 1,
                            state: 'new',
                            easeFactor: getStudySettings(deckId).startingEase,
                            interval: 0,
                            learningStep: 0,
                            repetitions: 0,
                            nextReview: Date.now(),
                            lastReviewed: null,
                            lapses: 0,
                            reverseOf: originalCardRef.id,  // å…ƒã‚«ãƒ¼ãƒ‰ã¸ã®å‚ç…§
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        // å…ƒã®ã‚«ãƒ¼ãƒ‰ã«é€†è»¢ã‚«ãƒ¼ãƒ‰ã®IDã‚’è¨˜éŒ²
                        await originalCardRef.update({
                            reverseCardId: reverseCardRef.id
                        });
                    }
                    
                    document.getElementById('question').value = '';
                    document.getElementById('answer').value = '';
                    document.getElementById('enableReverse').checked = false;
                    document.getElementById('cardTags').value = ''; // v10.01: ã‚¿ã‚°å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
                    
                } else if (currentCardType === 'cloze') {
                    // v5.01: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰
                    const text = document.getElementById('clozeText').value.trim();
                    
                    // v10.01: ã‚¿ã‚°å–å¾—
                    const tagsInput = document.getElementById('cardTags').value.trim();
                    const tags = tagsInput ? tagsInput.split(/\s+/).filter(t => t.length > 0) : [];
                    
                    if (!text) {
                        alert('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // ç©´åŸ‹ã‚ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    const clozes = [];
                    let match;
                    
                    while ((match = clozeRegex.exec(text)) !== null) {
                        clozes.push({
                            id: `c${match[1]}`,
                            answer: match[2],
                            position: [match.index, match.index + match[0].length]
                        });
                    }
                    
                    if (clozes.length === 0) {
                        alert('ç©´åŸ‹ã‚ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼ˆç¯„å›²ã‚’é¸æŠã—ã¦ã€Œé¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«ã€ãƒœã‚¿ãƒ³ï¼‰');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    await db.collection('flashcards').add({
                        type: 'cloze',
                        deckId: deckId,
                        text: text,
                        clozes: clozes,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        order: cards.length, // v10.02: é †åºç•ªå·
                        state: 'new',
                        easeFactor: getStudySettings(deckId).startingEase,
                        interval: 0,
                        learningStep: 0,
                        repetitions: 0,
                        nextReview: Date.now(),
                        lastReviewed: null,
                        lapses: 0,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    document.getElementById('clozeText').value = '';
                    document.getElementById('cardTags').value = ''; // v10.01: ã‚¿ã‚°å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
                    clozeCounter = 1;
                    updateClozePreview();
                    
                } else if (currentCardType === 'typing') {
                    // v5.02: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰
                    const question = document.getElementById('typingQuestion').value.trim();
                    const answer = document.getElementById('typingAnswer').value.trim();
                    const caseSensitive = document.getElementById('typingCaseSensitive').checked;
                    
                    // v10.01: ã‚¿ã‚°å–å¾—
                    const tagsInput = document.getElementById('cardTags').value.trim();
                    const tags = tagsInput ? tagsInput.split(/\s+/).filter(t => t.length > 0) : [];
                    
                    if (!question || !answer) {
                        alert('å•é¡Œã¨æ­£è§£ã®ä¸¡æ–¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    await db.collection('flashcards').add({
                        type: 'typing',
                        deckId: deckId,
                        question: question,
                        answer: answer,
                        caseSensitive: caseSensitive,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        order: cards.length, // v10.02: é †åºç•ªå·
                        state: 'new',
                        easeFactor: getStudySettings(deckId).startingEase,
                        interval: 0,
                        learningStep: 0,
                        repetitions: 0,
                        nextReview: Date.now(),
                        lastReviewed: null,
                        lapses: 0,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    document.getElementById('typingQuestion').value = '';
                    document.getElementById('typingAnswer').value = '';
                    document.getElementById('typingCaseSensitive').checked = false;
                    document.getElementById('cardTags').value = ''; // v10.01: ã‚¿ã‚°å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
                }
                
                // v6.00.2: é¸æŠã—ãŸãƒ‡ãƒƒã‚­ã‚’è¨˜æ†¶
                localStorage.setItem('lastSelectedDeckId', deckId);
            } catch (error) {
                console.error('Error adding card:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ');
                updateSyncStatus('error');
            }
        }

        // v6.00: ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºï¼ˆãƒ‡ãƒƒã‚­åè¡¨ç¤ºï¼‰
        function displayCard() {
            const display = document.getElementById('cardDisplay');
            const controls = document.getElementById('cardControls');
            
            // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            const filteredCards = getFilteredCards();
            
            if (filteredCards.length === 0) {
                display.innerHTML = `
                    <div class="empty-state">
                        <h2>ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“</h2>
                        <p>ã€Œã‚«ãƒ¼ãƒ‰ä½œæˆã€ã‚¿ãƒ–ã‹ã‚‰æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ãã ã•ã„</p>
                    </div>
                `;
                controls.innerHTML = '';
                return;
            }
            
            // v6.00.1: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç¯„å›²å¤–ã®å ´åˆã¯0ã«ãƒªã‚»ãƒƒãƒˆ
            if (currentIndex >= filteredCards.length) {
                currentIndex = 0;
            }
            
            const card = filteredCards[currentIndex];
            
            // v6.00: ãƒ‡ãƒƒã‚­åã‚’å–å¾—ï¼ˆäº’æ›æ€§ã®ãŸã‚categoryã‚‚ã‚µãƒãƒ¼ãƒˆï¼‰
            const deckName = card.deckId ? getDeckNameById(card.deckId) : (card.category || '');
            
            // v5.02: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
            if (card.type === 'typing') {
                if (showingQuestion) {
                    const questionWithBreaks = card.question.replace(/\n/g, '<br>');
                    
                    display.innerHTML = `
                        <div class="card" style="cursor: default;">
                            <div class="card-category">${deckName}</div>
                            <div class="card-type-badge">âŒ¨ï¸ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</div>
                            <div class="card-content" style="font-size: 20px; line-height: 1.8;">
                                ${questionWithBreaks}
                            </div>
                        </div>
                        <div class="typing-input-container">
                            <input type="text" class="typing-input" id="typingInput" placeholder="ç­”ãˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" onkeypress="if(event.key==='Enter') checkTypingAnswerPreview()">
                            <div id="typingResult"></div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div class="card-controls">
                            <div class="nav-buttons">
                                <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                                <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                                <button class="btn" onclick="checkTypingAnswerPreview()">åˆ¤å®š</button>
                                <button class="btn" onclick="flipCard()">ç­”ãˆ</button>
                            </div>
                            <div class="card-info">
                                ${currentIndex + 1} / ${filteredCards.length}
                            </div>
                            <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                        </div>
                    `;
                    
                    setTimeout(() => {
                        const input = document.getElementById('typingInput');
                        if (input) input.focus();
                    }, 100);
                } else {
                    const questionWithBreaks = card.question.replace(/\n/g, '<br>');
                    const answer = card.answer || (card.answers && card.answers[0]) || '';
                    display.innerHTML = `
                        <div class="card" onclick="flipCard()">
                            <div class="card-category">${deckName}</div>
                            <div class="card-type-badge">âŒ¨ï¸ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</div>
                            <div class="card-content" style="font-size: 20px; line-height: 1.8;">
                                <div style="margin-bottom: 20px;">${questionWithBreaks}</div>
                                <div style="font-size: 18px; color: rgba(255,255,255,0.9);">
                                    <strong>æ­£è§£:</strong> ${answer}
                                </div>
                            </div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div class="card-controls">
                            <div class="nav-buttons">
                                <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                                <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                            </div>
                            <div class="card-info">
                                ${currentIndex + 1} / ${filteredCards.length}
                            </div>
                            <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                        </div>
                    `;
                }
                return;
            }
            
            // v5.01: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
            if (card.type === 'cloze') {
                if (showingQuestion) {
                    currentClozeAnswers = {};
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    const displayText = card.text.replace(clozeRegex, (match, num, answer) => {
                        return `<span class="cloze-answer-hidden" onclick="showClozeAnswer('c${num}', '${answer.replace(/'/g, "\\'")}')"> ??? </span>`;
                    });
                    
                    display.innerHTML = `
                        <div class="card" style="cursor: default;">
                            <div class="card-category">${deckName}</div>
                            <div class="card-type-badge">ğŸ“ ç©´åŸ‹ã‚</div>
                            <div class="card-content" style="font-size: 20px; line-height: 1.8;">
                                ${displayText}
                            </div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div class="card-controls">
                            <div class="nav-buttons">
                                <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                                <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                                <button class="btn" onclick="flipCard()">ç­”ãˆ</button>
                            </div>
                            <div class="card-info">
                                ${currentIndex + 1} / ${filteredCards.length}
                            </div>
                            <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                        </div>
                    `;
                } else {
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    const displayText = card.text.replace(clozeRegex, (match, num, answer) => {
                        return `<span class="cloze-answer-shown">${answer}</span>`;
                    });
                    
                    display.innerHTML = `
                        <div class="card" onclick="flipCard()">
                            <div class="card-category">${deckName}</div>
                            <div class="card-type-badge">ğŸ“ ç©´åŸ‹ã‚</div>
                            <div class="card-content" style="font-size: 20px; line-height: 1.8;">
                                ${displayText}
                            </div>
                        </div>
                    `;
                    
                    controls.innerHTML = `
                        <div class="card-controls">
                            <div class="nav-buttons">
                                <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                                <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                            </div>
                            <div class="card-info">
                                ${currentIndex + 1} / ${filteredCards.length}
                            </div>
                            <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                        </div>
                    `;
                }
                return;
            }
            
            // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ãƒ»é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å‡¦ç† - v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã¯æ—¢ã«å•é¡Œã¨ç­”ãˆãŒå…¥ã‚Œæ›¿ã‚ã£ã¦ã„ã‚‹ã®ã§ãã®ã¾ã¾è¡¨ç¤º
            let content;
            if (showingQuestion) {
                content = card.question;
            } else {
                content = card.answer;
            }
            
            display.innerHTML = `
                <div class="card" onclick="flipCard()" style="position: relative;">
                    <div class="card-category">${deckName}</div>
                    ${card.reverseOf ? `<div class="card-direction">â‡† é€†è»¢</div>` : ''}
                    <div class="card-content">
                        ${content}
                    </div>
                </div>
            `;
            
            controls.innerHTML = `
                <div class="card-controls">
                    <div class="nav-buttons">
                        <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                        <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                    </div>
                    <div class="card-info">
                        ${currentIndex + 1} / ${filteredCards.length}
                    </div>
                    <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                </div>
            `;
        }

        // v5.01: ç©´åŸ‹ã‚ã®ç­”ãˆã‚’å€‹åˆ¥ã«è¡¨ç¤º
        function showClozeAnswer(id, answer) {
            currentClozeAnswers[id] = answer;
            
            // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            const filteredCards = getFilteredCards();
            const card = filteredCards[currentIndex];
            const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
            const displayText = card.text.replace(clozeRegex, (match, num, ans) => {
                const clozeId = `c${num}`;
                if (currentClozeAnswers[clozeId]) {
                    return `<span class="cloze-answer-shown">${currentClozeAnswers[clozeId]}</span>`;
                } else {
                    return `<span class="cloze-answer-hidden" onclick="showClozeAnswer('${clozeId}', '${ans.replace(/'/g, "\\'")}')"> ??? </span>`;
                }
            });
            
            const display = document.getElementById('cardDisplay');
            const controls = document.getElementById('cardControls');
            
            const deckName = card.deckId ? getDeckNameById(card.deckId) : (card.category || '');
            
            display.innerHTML = `
                <div class="card" style="cursor: default;">
                    <div class="card-category">${deckName}</div>
                    <div class="card-type-badge">ğŸ“ ç©´åŸ‹ã‚</div>
                    <div class="card-content" style="font-size: 20px; line-height: 1.8;">
                        ${displayText}
                    </div>
                </div>
            `;
            
            controls.innerHTML = `
                <div class="card-controls">
                    <div class="nav-buttons">
                        <button class="btn" onclick="previousCard()">â† å‰ã¸</button>
                        <button class="btn" onclick="nextCard()">æ¬¡ã¸ â†’</button>
                        <button class="btn" onclick="flipCard()">ç­”ãˆ</button>
                    </div>
                    <div class="card-info">
                        ${currentIndex + 1} / ${filteredCards.length}
                    </div>
                    <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                </div>
            `;
        }

        // v5.02.1: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ã®å…¥åŠ›åˆ¤å®š
        function checkTypingAnswerPreview() {
            // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            const filteredCards = getFilteredCards();
            const card = filteredCards[currentIndex];
            if (card.type !== 'typing') return;
            
            const input = document.getElementById('typingInput');
            const result = document.getElementById('typingResult');
            
            if (!input || !result) return;
            
            const userAnswer = input.value.trim();
            
            if (!userAnswer) {
                alert('ç­”ãˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const correctAnswer = card.answer || (card.answers && card.answers[0]) || '';
            
            function normalizeText(text, caseSensitive) {
                text = text.trim();
                text = text.replace(/ã€€/g, ' ');
                text = text.replace(/\s+/g, ' ');
                
                if (!caseSensitive) {
                    text = text.replace(/[ï¼¡-ï¼ºï½-ï½šï¼-ï¼™]/g, (s) => {
                        return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
                    });
                    text = text.toLowerCase();
                }
                
                return text;
            }
            
            const normalizedUser = normalizeText(userAnswer, card.caseSensitive);
            const normalizedCorrect = normalizeText(correctAnswer, card.caseSensitive);
            
            const isCorrect = normalizedUser === normalizedCorrect;
            const lengthMatch = normalizedUser.length === normalizedCorrect.length;
            
            let characterDisplay = '';
            const maxLen = Math.max(normalizedUser.length, normalizedCorrect.length);
            
            for (let i = 0; i < maxLen; i++) {
                const userChar = normalizedUser[i] || '';
                const correctChar = normalizedCorrect[i] || '';
                
                const displayChar = userChar === ' ' ? 'â£' : userChar;
                
                if (userChar === correctChar && userChar !== '') {
                    characterDisplay += `<span class="char-correct">${displayChar}</span>`;
                } else if (userChar !== '') {
                    characterDisplay += `<span class="char-incorrect">${displayChar}</span>`;
                }
            }
            
            let resultHTML = '';
            
            if (isCorrect) {
                input.className = 'typing-input correct';
                
                let correctDisplay = '';
                for (let i = 0; i < normalizedUser.length; i++) {
                    const displayChar = normalizedUser[i] === ' ' ? 'â£' : normalizedUser[i];
                    correctDisplay += `<span class="char-correct">${displayChar}</span>`;
                }
                
                resultHTML = `
                    <div class="typing-character-result">
                        <div class="typing-character-result-label">ã‚ãªãŸã®å…¥åŠ›ï¼š</div>
                        <div class="typing-character-display">${correctDisplay}</div>
                    </div>
                `;
            } else {
                input.className = 'typing-input incorrect';
                
                if (!lengthMatch) {
                    resultHTML += '<div class="length-warning">âš ï¸ æ–‡å­—æ•°ãŒç•°ãªã‚Šã¾ã™</div>';
                }
                
                resultHTML += `
                    <div class="typing-character-result">
                        <div class="typing-character-result-label">ã‚ãªãŸã®å…¥åŠ›ï¼š</div>
                        <div class="typing-character-display">${characterDisplay}</div>
                    </div>
                `;
            }
            
            result.innerHTML = resultHTML;
            
            input.focus();
        }

        // v6.00: ã‚«ãƒ¼ãƒ‰ä¸€è¦§è¡¨ç¤ºï¼ˆãƒ‡ãƒƒã‚­åè¡¨ç¤ºï¼‰
        // v10.02.1: çµ±è¨ˆæƒ…å ±ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«åŒ–ï¼‰
        // v12.01.2: æ¬¡å›å¾©ç¿’äºˆå®šæ—¥ã¨é›£æ˜“åº¦ä¿‚æ•°ã‚’è¿½åŠ 
        function generateCardStats(card) {
                let stats = [];
                
                // ä½œæˆæ—¥
                if (card.createdAt) {
                    let date;
                    if (card.createdAt.toDate && typeof card.createdAt.toDate === 'function') {
                        // Firestoreã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—å‹
                        date = card.createdAt.toDate();
                    } else if (card.createdAt.seconds) {
                        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆç§’ã¨ãƒŠãƒç§’ï¼‰
                        date = new Date(card.createdAt.seconds * 1000);
                    } else if (typeof card.createdAt === 'number') {
                        // ãƒŸãƒªç§’ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
                        date = new Date(card.createdAt);
                    } else if (typeof card.createdAt === 'string') {
                        // ISOæ–‡å­—åˆ—
                        date = new Date(card.createdAt);
                    }
                    
                    if (date && !isNaN(date.getTime())) {
                        const dateStr = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
                        stats.push(`ğŸ“… ${dateStr}`);
                    }
                }
                
                // æœ€çµ‚å­¦ç¿’æ—¥
                if (card.lastReviewed) {
                    const date = new Date(card.lastReviewed);
                    const dateStr = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
                    stats.push(`ğŸ“– ${dateStr}`);
                } else {
                    stats.push(`ğŸ“– æœªå­¦ç¿’`);
                }
                
                // v10.03.3: å­¦ç¿’å›æ•°ï¼ˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã¯æ­£ç­”ç‡ã‚‚è¡¨ç¤ºï¼‰
                const reps = card.repetitions || 0;
                const lapses = card.lapses || 0;
                const total = reps + lapses;
                
                if (total > 0) {
                    if (card.type === 'typing') {
                        // v10.03.3: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã¯å°‚ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰æ­£ç­”ç‡ã‚’è¨ˆç®—
                        const typingTotal = card.typingTotalCount || 0;
                        const typingCorrect = card.typingCorrectCount || 0;
                        
                        if (typingTotal > 0) {
                            const accuracy = Math.round((typingCorrect / typingTotal) * 100);
                            stats.push(`ğŸ”„ å­¦ç¿’${typingTotal}å›ï¼ˆæ­£ç­”ç‡${accuracy}%ï¼šæ­£è§£${typingCorrect}/ç·æ•°${typingTotal}ï¼‰`);
                        } else {
                            // æ—§ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯repetitions/lapsesã‚’ä½¿ç”¨
                            const accuracy = Math.round((reps / total) * 100);
                            stats.push(`ğŸ”„ å­¦ç¿’${total}å›ï¼ˆæ­£ç­”ç‡${accuracy}%ï¼šæ­£è§£${reps}/ç·æ•°${total}ï¼‰`);
                        }
                    } else {
                        // åŸºæœ¬ãƒ»ç©´åŸ‹ã‚ï¼šå­¦ç¿’å›æ•°ã®ã¿
                        stats.push(`ğŸ”„ å­¦ç¿’${total}å›`);
                    }
                }
                
                // v12.01.2: æ¬¡å›å¾©ç¿’äºˆå®šæ—¥
                if (card.nextReview) {
                    const date = new Date(card.nextReview);
                    const dateStr = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
                    stats.push(`â° æ¬¡å›: ${dateStr}`);
                } else if (total > 0) {
                    stats.push(`â° æ¬¡å›: -`);
                }
                
                // v12.01.2: é›£æ˜“åº¦ä¿‚æ•°
                if (card.easeFactor) {
                    stats.push(`ğŸ“Š é›£æ˜“åº¦: ${card.easeFactor.toFixed(2)}`);
                }
                
                return stats.join(' ');
        }
        

        // v12.01.6: è¡¨ç¤ºä»¶æ•°å¤‰æ›´
        function changeCardsPerPage() {
            const select = document.getElementById('cardsPerPageSelect');
            cardsPerPage = parseInt(select.value);
            
            // localStorageã«ä¿å­˜
            localStorage.setItem('cardsPerPage', cardsPerPage);
            
            // 1ãƒšãƒ¼ã‚¸ç›®ã«æˆ»ã‚‹
            currentCardPage = 1;
            
            // å†è¡¨ç¤º
            displayCardListWithPagination();
        }
        
        // v12.01.6: åˆæœŸåŒ–æ™‚ã«è¡¨ç¤ºä»¶æ•°ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®å€¤ã‚’è¨­å®š
        // v12.01.7: åˆæœŸåŒ–ã‚’å¼·åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            // localStorageã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ50ï¼‰
            const savedPerPage = localStorage.getItem('cardsPerPage');
            if (savedPerPage) {
                cardsPerPage = parseInt(savedPerPage);
            } else {
                cardsPerPage = 50;
                localStorage.setItem('cardsPerPage', '50');
            }
            
            // ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã«åæ˜ 
            const select = document.getElementById('cardsPerPageSelect');
            if (select) {
                select.value = cardsPerPage.toString();
            }
        });

        function displayCardList() {
            const listEl = document.getElementById('cardList');
            
            if (cards.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <h2>ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“</h2>
                        <p>ã€Œã‚«ãƒ¼ãƒ‰ä½œæˆã€ã‚¿ãƒ–ã‹ã‚‰æ–°ã—ã„ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã—ã¦ãã ã•ã„</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            cards.forEach(card => {
                const deckName = card.deckId ? getDeckNameById(card.deckId) : (card.category || '');
                const statsHtml = generateCardStats(card);
                
                if (card.type === 'typing') {
                    const answer = card.answer || (card.answers && card.answers.join(', ')) || '';
                    // v10.01: ã‚¿ã‚°è¡¨ç¤º
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}" 
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°: ${card.question}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    <span class="card-item-typing-badge">âŒ¨ï¸ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</span>
                                </div>
                            </div>
                            <div class="card-item-content">
                                æ­£è§£: ${answer}
                                ${card.caseSensitive ? ' <span style="color: #e67e22;">(å¤§æ–‡å­—å°æ–‡å­—ãƒ»å…¨è§’åŠè§’åŒºåˆ¥)</span>' : ''}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                } else if (card.type === 'cloze') {
                    const clozeRegex = /\{\{c\d+::([^}]+)\}\}/g;
                    const displayText = card.text.replace(clozeRegex, (match, answer) => {
                        return `<span class="cloze-blank">[${answer}]</span>`;
                    });
                    
                    // v10.01: ã‚¿ã‚°è¡¨ç¤º
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}"
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">ç©´åŸ‹ã‚: ${card.text.substring(0, 50)}${card.text.length > 50 ? '...' : ''}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    <span class="card-item-cloze-badge">ğŸ“ ç©´åŸ‹ã‚</span>
                                </div>
                            </div>
                            <div class="card-item-content">
                                ${displayText}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                } else {
                    // v10.01: ã‚¿ã‚°è¡¨ç¤º
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}"
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">å•é¡Œ: ${card.question}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    ${card.reverseOf ? '<span class="card-item-reverse-badge">â‡† é€†è»¢</span>' : ''}
                                </div>
                            </div>
                            <div class="card-item-content">
                                ç­”ãˆ: ${card.answer}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                }
            });
            
            listEl.innerHTML = html;
            
            // v10.00: é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
            updateSelectedCards();
        }
        
        // v12.01.5: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼‹ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œã®ã‚«ãƒ¼ãƒ‰ä¸€è¦§è¡¨ç¤º
        function displayCardListWithPagination() {
            const listEl = document.getElementById('cardList');
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ¡ä»¶ã‚’å–å¾—
            const searchText = document.getElementById('searchInput').value.toLowerCase();
            const deckFilter = document.getElementById('deckFilter').value;
            const cardTypeFilter = document.getElementById('cardTypeFilter').value;
            const cardStateFilter = document.getElementById('cardStateFilter').value;
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†
            let filteredCards = cards.filter(card => {
                // æ¤œç´¢ãƒ†ã‚­ã‚¹ãƒˆ
                let matchesSearch = true;
                if (searchText) {
                    const tags = card.tags || [];
                    const tagsText = tags.join(' ').toLowerCase();
                    
                    if (card.type === 'typing') {
                        const answer = card.answer || (card.answers && card.answers.join(' ')) || '';
                        matchesSearch = card.question.toLowerCase().includes(searchText) ||
                                      answer.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    } else if (card.type === 'cloze') {
                        matchesSearch = card.text.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    } else {
                        matchesSearch = card.question.toLowerCase().includes(searchText) || 
                                      card.answer.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    }
                }
                
                // ãƒ‡ãƒƒã‚­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesDeck = true;
                if (deckFilter === '__uncategorized__') {
                    // æœªåˆ†é¡ã‚«ãƒ¼ãƒ‰: deckIdãŒç©ºã€nullã€undefinedã€ã¾ãŸã¯å­˜åœ¨ã—ãªã„ãƒ‡ãƒƒã‚­ID
                    if (!card.deckId) {
                        matchesDeck = true;
                    } else {
                        const deckExists = decks.some(d => d.id === card.deckId);
                        matchesDeck = !deckExists;
                    }
                } else if (deckFilter) {
                    matchesDeck = card.deckId === deckFilter;
                }
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesType = true;
                if (cardTypeFilter) {
                    matchesType = card.type === cardTypeFilter;
                }
                
                // å­¦ç¿’çŠ¶æ…‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesState = true;
                if (cardStateFilter) {
                    const state = card.state || 'new';
                    if (cardStateFilter === 'new') {
                        matchesState = state === 'new';
                    } else if (cardStateFilter === 'learning') {
                        matchesState = state === 'learning';
                    } else if (cardStateFilter === 'review') {
                        matchesState = state === 'review' || state === 'relearning';
                    }
                }
                
                return matchesSearch && matchesDeck && matchesType && matchesState;
            });
            
            if (filteredCards.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <h2>ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“</h2>
                        <p>æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</p>
                    </div>
                `;
                return;
            }
            
            // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
            totalFilteredCards = filteredCards.length;
            const totalPages = Math.ceil(totalFilteredCards / cardsPerPage);
            
            // ãƒšãƒ¼ã‚¸ç•ªå·ãŒç¯„å›²å¤–ã®å ´åˆã¯ä¿®æ­£
            if (currentCardPage > totalPages) {
                currentCardPage = totalPages;
            }
            if (currentCardPage < 1) {
                currentCardPage = 1;
            }
            
            // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
            const startIndex = (currentCardPage - 1) * cardsPerPage;
            const endIndex = Math.min(startIndex + cardsPerPage, totalFilteredCards);
            const paginatedCards = filteredCards.slice(startIndex, endIndex);
            
            // ã‚«ãƒ¼ãƒ‰ä¸€è¦§ã‚’ç”Ÿæˆ
            let html = '';
            paginatedCards.forEach(card => {
                const deckName = card.deckId ? getDeckNameById(card.deckId) : (card.category || '');
                const statsHtml = generateCardStats(card);
                
                if (card.type === 'typing') {
                    const answer = card.answer || (card.answers && card.answers.join(', ')) || '';
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}" 
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°: ${card.question}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    <span class="card-item-typing-badge">âŒ¨ï¸ ã‚¿ã‚¤ãƒ”ãƒ³ã‚°</span>
                                </div>
                            </div>
                            <div class="card-item-content">
                                æ­£è§£: ${answer}
                                ${card.caseSensitive ? ' <span style="color: #e67e22;">(å¤§æ–‡å­—å°æ–‡å­—ãƒ»å…¨è§’åŠè§’åŒºåˆ¥)</span>' : ''}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                } else if (card.type === 'cloze') {
                    const clozeRegex = /\{\{c\d+::([^}]+)\}\}/g;
                    const displayText = card.text.replace(clozeRegex, (match, answer) => {
                        return `<span class="cloze-blank">[${answer}]</span>`;
                    });
                    
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}"
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">ç©´åŸ‹ã‚: ${card.text.substring(0, 50)}${card.text.length > 50 ? '...' : ''}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    <span class="card-item-cloze-badge">ğŸ“ ç©´åŸ‹ã‚</span>
                                </div>
                            </div>
                            <div class="card-item-content">
                                ${displayText}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                } else {
                    const tags = card.tags || [];
                    const tagsHtml = tags.length > 0 ? `<div style="margin-top: 8px;"><span style="color: #667eea; font-size: 12px;">ğŸ·ï¸ ${tags.join(' ')}</span></div>` : '';
                    
                    html += `
                        <div class="card-item" draggable="true" data-card-id="${card.id}"
                             ondragstart="handleDragStart(event)" 
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event)"
                             ondrop="handleDrop(event)"
                             ondragleave="handleDragLeave(event)">
                            <div class="card-item-header">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span class="drag-handle">â˜°</span>
                                    <input type="checkbox" class="card-checkbox" data-card-id="${card.id}" onchange="updateSelectedCards()" style="width: 20px; height: 20px; cursor: pointer;">
                                    <span class="card-item-title">å•é¡Œ: ${card.question}</span>
                                </div>
                                <div>
                                    <span class="card-item-category">${deckName}</span>
                                    ${card.reverseOf ? '<span class="card-item-reverse-badge">â‡† é€†è»¢</span>' : ''}
                                </div>
                            </div>
                            <div class="card-item-content">
                                ç­”ãˆ: ${card.answer}
                                ${tagsHtml}
                            </div>
                            <div class="card-item-actions">
                                <button class="btn" onclick="editCard('${card.id}')">ç·¨é›†</button>
                                <button class="btn" onclick="duplicateCard('${card.id}')" style="background: #3498db; color: white;">è¤‡è£½</button>
                                <button class="btn btn-danger" onclick="deleteCard('${card.id}')">å‰Šé™¤</button>
                                <span class="card-stats">${statsHtml}</span>
                            </div>
                        </div>
                    `;
                }
            });
            
            // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç”¨HTML
            const paginationHtml = renderPagination(filteredCards);
            
            listEl.innerHTML = html + paginationHtml;
            
            // é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
            updateSelectedCards();
            
            // ãƒšãƒ¼ã‚¸å¤‰æ›´æ™‚ã¯ãƒˆãƒƒãƒ—ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            if (listEl.parentElement) {
                listEl.parentElement.scrollTop = 0;
            }
        }

        // v10.01: ã‚«ãƒ¼ãƒ‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆã‚¿ã‚°æ¤œç´¢ã€ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã€å­¦ç¿’çŠ¶æ…‹å¯¾å¿œï¼‰
        function filterCards() {
            // v12.01.5: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ
            // v14.01.11: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’åæ˜ 
            const deckFilter = document.getElementById('deckFilter').value;
            currentDeckFilter = deckFilter;
            
            // ãƒšãƒ¼ã‚¸ã‚’ãƒªã‚»ãƒƒãƒˆ
            currentCardPage = 1;
            
            // æ–°ã—ã„è¡¨ç¤ºé–¢æ•°ã‚’å‘¼ã³å‡ºã—
            displayCardListWithPagination();
            
            // v6.00.1: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã‚’æ›´æ–°ï¼ˆv14.01.11: å…¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ï¼‰
            currentIndex = 0;
            showingQuestion = true;
            displayCard();
        }

        // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—
        // v14.01.11: ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ»å­¦ç¿’çŠ¶æ…‹ãƒ»æ¤œç´¢ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¯¾å¿œ
        function getFilteredCards() {
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ¡ä»¶ã‚’å–å¾—
            const searchText = document.getElementById('searchInput').value.toLowerCase();
            const deckFilter = document.getElementById('deckFilter').value;
            const cardTypeFilter = document.getElementById('cardTypeFilter').value;
            const cardStateFilter = document.getElementById('cardStateFilter').value;
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†
            return cards.filter(card => {
                // æ¤œç´¢ãƒ†ã‚­ã‚¹ãƒˆ
                let matchesSearch = true;
                if (searchText) {
                    const tags = card.tags || [];
                    const tagsText = tags.join(' ').toLowerCase();
                    
                    if (card.type === 'typing') {
                        const answer = card.answer || (card.answers && card.answers.join(' ')) || '';
                        matchesSearch = card.question.toLowerCase().includes(searchText) ||
                                      answer.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    } else if (card.type === 'cloze') {
                        matchesSearch = card.text.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    } else {
                        matchesSearch = card.question.toLowerCase().includes(searchText) || 
                                      card.answer.toLowerCase().includes(searchText) ||
                                      tagsText.includes(searchText);
                    }
                }
                
                // ãƒ‡ãƒƒã‚­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesDeck = true;
                if (deckFilter === '__uncategorized__') {
                    // æœªåˆ†é¡ã‚«ãƒ¼ãƒ‰: deckIdãŒç©ºã€nullã€undefinedã€ã¾ãŸã¯å­˜åœ¨ã—ãªã„ãƒ‡ãƒƒã‚­ID
                    if (!card.deckId) {
                        matchesDeck = true;
                    } else {
                        const deckExists = decks.some(d => d.id === card.deckId);
                        matchesDeck = !deckExists;
                    }
                } else if (deckFilter) {
                    matchesDeck = card.deckId === deckFilter;
                }
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesType = true;
                if (cardTypeFilter) {
                    matchesType = card.type === cardTypeFilter;
                }
                
                // å­¦ç¿’çŠ¶æ…‹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
                let matchesState = true;
                if (cardStateFilter) {
                    const state = card.state || 'new';
                    if (cardStateFilter === 'new') {
                        matchesState = state === 'new';
                    } else if (cardStateFilter === 'learning') {
                        matchesState = state === 'learning';
                    } else if (cardStateFilter === 'review') {
                        matchesState = state === 'review' || state === 'relearning';
                    }
                }
                
                return matchesSearch && matchesDeck && matchesType && matchesState;
            });
        }

        // v10.02: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        let draggedCardId = null;
        
        function handleDragStart(event) {
            draggedCardId = event.target.dataset.cardId;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            document.querySelectorAll('.card-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }
        
        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const target = event.target.closest('.card-item');
            if (target && target.dataset.cardId !== draggedCardId) {
                target.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(event) {
            const target = event.target.closest('.card-item');
            if (target) {
                target.classList.remove('drag-over');
            }
        }
        
        async function handleDrop(event) {
            event.preventDefault();
            
            const targetCardId = event.target.closest('.card-item').dataset.cardId;
            
            if (draggedCardId === targetCardId) {
                return;
            }
            
            // ã‚«ãƒ¼ãƒ‰ã®é †åºã‚’å…¥ã‚Œæ›¿ãˆ
            const draggedIndex = cards.findIndex(c => c.id === draggedCardId);
            const targetIndex = cards.findIndex(c => c.id === targetCardId);
            
            if (draggedIndex === -1 || targetIndex === -1) {
                return;
            }
            
            // é…åˆ—å†…ã§å…¥ã‚Œæ›¿ãˆ
            const draggedCard = cards[draggedIndex];
            cards.splice(draggedIndex, 1);
            cards.splice(targetIndex, 0, draggedCard);
            
            // Firestoreã®orderå€¤ã‚’æ›´æ–°
            updateSyncStatus('syncing');
            try {
                const batch = [];
                for (let i = 0; i < cards.length; i++) {
                    if (incrementWriteCounter()) {
                        batch.push(
                            db.collection('flashcards').doc(cards[i].id).update({
                                order: i
                            })
                        );
                    }
                    
                    if (batch.length >= 10) {
                        await Promise.all(batch);
                        batch.length = 0;
                    }
                }
                
                if (batch.length > 0) {
                    await Promise.all(batch);
                }
                
                // UIã‚’å†æç”»
                displayCardListWithPagination();
                updateSyncStatus('synced');
            } catch (error) {
                console.error('é †åºæ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                updateSyncStatus('error');
            }
        }
        
        // v10.02: ã‚«ãƒ¼ãƒ‰ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½
        function sortCards() {
            const sortBy = document.getElementById('sortBy').value;
            const sortOrder = document.getElementById('sortOrder').value;
            
            // ã‚½ãƒ¼ãƒˆå‰ã®cardsã‚’ã‚³ãƒ”ãƒ¼
            let sortedCards = [...cards];
            
            switch (sortBy) {
                case 'manual':
                    sortedCards.sort((a, b) => {
                        const orderA = a.order !== undefined ? a.order : 999999;
                        const orderB = b.order !== undefined ? b.order : 999999;
                        return sortOrder === 'asc' ? orderA - orderB : orderB - orderA;
                    });
                    break;
                    
                case 'createdDate':
                    sortedCards.sort((a, b) => {
                        const dateA = safeToMillis(a.createdAt) || 0;
                        const dateB = safeToMillis(b.createdAt) || 0;
                        return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
                    });
                    break;
                    
                case 'lastStudied':
                    sortedCards.sort((a, b) => {
                        const dateA = a.lastReviewed || 0;
                        const dateB = b.lastReviewed || 0;
                        return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
                    });
                    break;
                    
                case 'studyCount':
                    sortedCards.sort((a, b) => {
                        const repsA = a.repetitions || 0;
                        const repsB = b.repetitions || 0;
                        return sortOrder === 'asc' ? repsA - repsB : repsB - repsA;
                    });
                    break;
                    
                case 'cardType':
                    sortedCards.sort((a, b) => {
                        const typeOrder = { 'basic': 0, 'cloze': 1, 'typing': 2 };
                        const orderA = typeOrder[a.type] || 99;
                        const orderB = typeOrder[b.type] || 99;
                        return sortOrder === 'asc' ? orderA - orderB : orderB - orderA;
                    });
                    break;
                    
                case 'tags':
                    sortedCards.sort((a, b) => {
                        const tagsA = (a.tags || []).join(' ').toLowerCase();
                        const tagsB = (b.tags || []).join(' ').toLowerCase();
                        if (sortOrder === 'asc') {
                            return tagsA.localeCompare(tagsB);
                        } else {
                            return tagsB.localeCompare(tagsA);
                        }
                    });
                    break;
            }
            
            // ã‚½ãƒ¼ãƒˆçµæœã‚’cardsã«åæ˜ 
            cards = sortedCards;
            
            // UIã‚’å†æç”»
            // v12.01.7: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ
            currentCardPage = 1; // ã‚½ãƒ¼ãƒˆæ™‚ã¯1ãƒšãƒ¼ã‚¸ç›®ã«æˆ»ã‚‹
            displayCardListWithPagination();
        }

        // v10.00: é¸æŠã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰IDã‚’ç®¡ç†
        let selectedCardIds = [];
        
        // v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨å¤‰æ•°
        let csvDataForImport = null;
        let selectedDeckForCsvImport = null;

        // v10.00: é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
        // v10.00.2: é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ã§åˆ¤å®šï¼‰
        function updateSelectedCards() {
            selectedCardIds = [];
            document.querySelectorAll('.card-checkbox:checked').forEach(checkbox => {
                selectedCardIds.push(checkbox.dataset.cardId);
            });
            
            // é¸æŠæ•°ã‚’è¡¨ç¤º
            document.getElementById('selectedCardCount').textContent = `${selectedCardIds.length}æšé¸æŠä¸­`;
            
            // ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹ã‚’åˆ‡ã‚Šæ›¿ãˆ
            const hasSelection = selectedCardIds.length > 0;
            document.getElementById('bulkMoveBtn').disabled = !hasSelection;
            document.getElementById('bulkDeleteBtn').disabled = !hasSelection;
            document.getElementById('bulkExportBtn').disabled = !hasSelection;
            
            // v10.00.2: å…¨é¸æŠãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ãƒ‰ã®ã¿ã‚’åŸºæº–ï¼‰
            const allCheckboxes = Array.from(document.querySelectorAll('.card-checkbox'))
                .filter(cb => cb.closest('.card-item').style.display !== 'none');
            const checkedCheckboxes = allCheckboxes.filter(cb => cb.checked);
            const selectAllCheckbox = document.getElementById('selectAllCards');
            
            if (allCheckboxes.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (checkedCheckboxes.length === allCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else if (checkedCheckboxes.length > 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
        }

        // v10.00.2: å…¨é¸æŠ/å…¨è§£é™¤ï¼ˆindeterminateçŠ¶æ…‹ã®ã‚¯ãƒªãƒƒã‚¯ã§å…¨é¸æŠï¼‰
        function toggleSelectAllCards() {
            const selectAllCheckbox = document.getElementById('selectAllCards');
            const visibleCheckboxes = Array.from(document.querySelectorAll('.card-checkbox'))
                .filter(cb => cb.closest('.card-item').style.display !== 'none');
            
            // v10.00.2: indeterminateçŠ¶æ…‹ï¼ˆéƒ¨åˆ†é¸æŠï¼‰ã®å ´åˆã¯å…¨é¸æŠã«ã™ã‚‹
            if (selectAllCheckbox.indeterminate) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = true;
                visibleCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            } else {
                // é€šå¸¸ã®å…¨é¸æŠ/å…¨è§£é™¤
                const selectAll = selectAllCheckbox.checked;
                visibleCheckboxes.forEach(checkbox => {
                    checkbox.checked = selectAll;
                });
            }
            
            updateSelectedCards();
        }

        // v10.00: é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ‹¬ç§»å‹•
        // v10.00.1: é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ‹¬ç§»å‹•ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºï¼‰
        let selectedDeckForMove = null;
        
        async function bulkMoveCards() {
            if (selectedCardIds.length === 0) {
                alert('ç§»å‹•ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
            openDeckSelectorModal();
        }
        
        // v10.00.1: ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openDeckSelectorModal() {
            document.getElementById('moveCardCount').textContent = selectedCardIds.length;
            
            const listEl = document.getElementById('deckSelectorList');
            listEl.innerHTML = '';
            
            decks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'deck-selector-item';
                
                if (deck.level === 1) {
                    deckItem.classList.add('child-deck');
                } else if (deck.level >= 2) {
                    deckItem.classList.add('grandchild-deck');
                }
                
                const indent = 'ã€€'.repeat(deck.level || 0);
                deckItem.textContent = `${indent}${deck.name}`;
                deckItem.dataset.deckId = deck.id;
                
                deckItem.onclick = function() {
                    // ä»–ã®é¸æŠã‚’è§£é™¤
                    document.querySelectorAll('.deck-selector-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // ã“ã®é …ç›®ã‚’é¸æŠ
                    this.classList.add('selected');
                    selectedDeckForMove = deck.id;
                    
                    // ç§»å‹•ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                    document.getElementById('confirmMoveBtn').disabled = false;
                };
                
                listEl.appendChild(deckItem);
            });
            
            selectedDeckForMove = null;
            document.getElementById('confirmMoveBtn').disabled = true;
            document.getElementById('deckSelectorModal').style.display = 'block';
        }
        
        // v10.00.1: ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeDeckSelectorModal() {
            document.getElementById('deckSelectorModal').style.display = 'none';
            selectedDeckForMove = null;
        }
        
        // v10.00.1: ãƒ‡ãƒƒã‚­ç§»å‹•ã‚’ç¢ºå®š
        // v14.02.8.6: ã‚«ãƒ¼ãƒ‰ç§»å‹•ã®ãƒã‚°ä¿®æ­£ï¼ˆæˆåŠŸã‚«ã‚¦ãƒ³ãƒˆã€è©³ç´°ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ï¼‰
        // v14.02.8.7: è‡´å‘½çš„ãƒã‚°ä¿®æ­£ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹å‰ã«deckIdã‚’ä¿å­˜ï¼‰
        async function confirmDeckMove() {
            if (!selectedDeckForMove) return;
            
            const targetDeck = decks.find(d => d.id === selectedDeckForMove);
            if (!targetDeck) {
                alert('ç„¡åŠ¹ãªãƒ‡ãƒƒã‚­ã§ã™');
                return;
            }
            
            if (!confirm(`${selectedCardIds.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã€Œ${targetDeck.name}ã€ã«ç§»å‹•ã—ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            // é‡è¦: ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹å‰ã«deckIdã‚’ä¿å­˜ï¼ˆcloseDeckSelectorModalã§nullã«ãªã‚‹ãŸã‚ï¼‰
            const targetDeckId = selectedDeckForMove;
            
            closeDeckSelectorModal();
            updateSyncStatus('syncing');
            
            let successCount = 0;
            let failCount = 0;
            const errors = [];
            
            try {
                for (const cardId of selectedCardIds) {
                    if (!incrementWriteCounter()) {
                        alert(`æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚${successCount}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ç§»å‹•ã—ã¾ã—ãŸã€‚`);
                        break;
                    }
                    
                    try {
                        await db.collection('flashcards').doc(cardId).update({
                            deckId: targetDeckId
                        });
                        successCount++;
                    } catch (error) {
                        console.error(`ã‚«ãƒ¼ãƒ‰ID ${cardId} ã®ç§»å‹•ã‚¨ãƒ©ãƒ¼:`, error);
                        failCount++;
                        errors.push({cardId, error: error.message});
                    }
                }
                
                // çµæœãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆ
                let message = '';
                if (successCount > 0 && failCount === 0) {
                    message = `${successCount}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã€Œ${targetDeck.name}ã€ã«ç§»å‹•ã—ã¾ã—ãŸ`;
                } else if (successCount > 0 && failCount > 0) {
                    message = `${successCount}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ç§»å‹•ã—ã¾ã—ãŸ\n${failCount}æšã®ã‚«ãƒ¼ãƒ‰ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã§ã—ãŸ`;
                } else if (successCount === 0) {
                    message = `ã‚«ãƒ¼ãƒ‰ã®ç§»å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ\nè©³ç´°: ${errors[0]?.error || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`;
                }
                
                alert(message);
                
                // é¸æŠã‚’ã‚¯ãƒªã‚¢
                selectedCardIds = [];
                document.querySelectorAll('.card-checkbox').forEach(cb => cb.checked = false);
                updateSelectedCards();
                
                updateSyncStatus('synced');
                
            } catch (error) {
                console.error('ã‚«ãƒ¼ãƒ‰ç§»å‹•ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ã‚«ãƒ¼ãƒ‰ã®ç§»å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ\n${successCount}æšã¯ç§»å‹•æ¸ˆã¿\nã‚¨ãƒ©ãƒ¼: ${error.message}`);
                updateSyncStatus('error');
            }
        }

        // v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openCsvDeckSelectorModal() {
            const listEl = document.getElementById('csvDeckSelectorList');
            listEl.innerHTML = '';
            
            decks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'deck-selector-item';
                
                if (deck.level === 1) {
                    deckItem.classList.add('child-deck');
                } else if (deck.level >= 2) {
                    deckItem.classList.add('grandchild-deck');
                }
                
                const indent = 'ã€€'.repeat(deck.level || 0);
                deckItem.textContent = `${indent}${deck.name}`;
                deckItem.dataset.deckId = deck.id;
                
                deckItem.onclick = function() {
                    // ä»–ã®é¸æŠã‚’è§£é™¤
                    document.querySelectorAll('#csvDeckSelectorList .deck-selector-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // ã“ã®é …ç›®ã‚’é¸æŠ
                    this.classList.add('selected');
                    selectedDeckForCsvImport = deck.id;
                    
                    // æ–°è¦ãƒ‡ãƒƒã‚­åå…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢
                    document.getElementById('newDeckNameForImport').value = '';
                    
                    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                    document.getElementById('confirmCsvImportBtn').disabled = false;
                };
                
                listEl.appendChild(deckItem);
            });
            
            // æ–°è¦ãƒ‡ãƒƒã‚­åå…¥åŠ›æ¬„ã®ã‚¤ãƒ™ãƒ³ãƒˆ
            const newDeckInput = document.getElementById('newDeckNameForImport');
            newDeckInput.value = '';
            newDeckInput.oninput = function() {
                if (this.value.trim()) {
                    // æ—¢å­˜ãƒ‡ãƒƒã‚­ã®é¸æŠã‚’è§£é™¤
                    document.querySelectorAll('#csvDeckSelectorList .deck-selector-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    selectedDeckForCsvImport = 'new:' + this.value.trim();
                    document.getElementById('confirmCsvImportBtn').disabled = false;
                } else {
                    if (!document.querySelector('#csvDeckSelectorList .deck-selector-item.selected')) {
                        document.getElementById('confirmCsvImportBtn').disabled = true;
                    }
                }
            };
            
            selectedDeckForCsvImport = null;
            document.getElementById('confirmCsvImportBtn').disabled = true;
            document.getElementById('csvDeckSelectorModal').style.display = 'block';
        }
        
        // v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeCsvDeckSelectorModal() {
            document.getElementById('csvDeckSelectorModal').style.display = 'none';
            selectedDeckForCsvImport = null;
            csvDataForImport = null;
        }
        
        // v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ç¢ºå®š
        async function confirmCsvImport() {
            if (!selectedDeckForCsvImport) return;
            
            let targetDeckId = '';
            
            try {
                // æ–°è¦ãƒ‡ãƒƒã‚­ã®å ´åˆ
                if (selectedDeckForCsvImport.startsWith('new:')) {
                    const deckName = selectedDeckForCsvImport.substring(4);
                    
                    // åŒåã®ãƒ‡ãƒƒã‚­ãŒå­˜åœ¨ã—ãªã„ã‹ç¢ºèª
                    const existingDeck = await db.collection('decks').where('name', '==', deckName).limit(1).get();
                    if (!existingDeck.empty) {
                        alert(`ã€Œ${deckName}ã€ã¨ã„ã†åå‰ã®ãƒ‡ãƒƒã‚­ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚æ—¢å­˜ã®ãƒ‡ãƒƒã‚­ã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„ã€‚`);
                        return;
                    }
                    
                    // æ–°è¦ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ
                    const newDeckRef = await db.collection('decks').add({
                        name: deckName,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        order: Date.now()
                    });
                    targetDeckId = newDeckRef.id;
                    
                } else {
                    // æ—¢å­˜ãƒ‡ãƒƒã‚­ã‚’ä½¿ç”¨
                    targetDeckId = selectedDeckForCsvImport;
                }
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                document.getElementById('csvDeckSelectorModal').style.display = 'none';
                
                // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Ÿè¡Œ
                await executeImportWithDeck(targetDeckId);
                
            } catch (error) {
                console.error('ãƒ‡ãƒƒã‚­ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ‡ãƒƒã‚­ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        // v10.00: é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ‹¬å‰Šé™¤
        async function bulkDeleteCards() {
            if (selectedCardIds.length === 0) {
                alert('å‰Šé™¤ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!confirm(`${selectedCardIds.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
                return;
            }
            
            updateSyncStatus('syncing');
            
            try {
                for (const cardId of selectedCardIds) {
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¾ã—ãŸã€‚ä¸€éƒ¨ã®ã‚«ãƒ¼ãƒ‰ã®ã¿å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚');
                        break;
                    }
                    
                    await db.collection('flashcards').doc(cardId).delete();
                }
                
                alert(`${selectedCardIds.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
                
                // é¸æŠã‚’ã‚¯ãƒªã‚¢
                selectedCardIds = [];
                updateSelectedCards();
                
                // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´
                const filteredCards = getFilteredCards();
                if (currentIndex >= filteredCards.length && currentIndex > 0) {
                    currentIndex--;
                }
                showingQuestion = true;
                currentCardIsReversed = false;
                currentClozeAnswers = {};
                
            } catch (error) {
                console.error('ã‚«ãƒ¼ãƒ‰å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
                updateSyncStatus('error');
            }
        }

        // v10.00: é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ‹¬ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        // v10.00: é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ‹¬ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆJSONå½¢å¼ï¼‰
        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ï¼ˆease, interval, repetitionsç­‰ï¼‰ã‚’å«ã‚ãŸå®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
        // ã“ã®ã‚¢ãƒ—ãƒªã¸ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã§å­¦ç¿’é€²æ—ã‚’å¾©å…ƒå¯èƒ½
        function bulkExportCards() {
            if (selectedCardIds.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // é¸æŠã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const selectedCards = cards.filter(card => selectedCardIds.includes(card.id));
            
            // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            const exportData = {
                version: 'v10.02',
                exportDate: new Date().toISOString(),
                cardCount: selectedCards.length,
                description: 'MyAnkiAppå®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆå­¦ç¿’ãƒ‡ãƒ¼ã‚¿å«ã‚€ï¼‰',
                cards: selectedCards.map(card => {
                    // å­¦ç¿’å±¥æ­´ã‚‚å«ã‚ã‚‹
                    return {
                        type: card.type,
                        question: card.question,
                        answer: card.answer,
                        text: card.text,
                        answers: card.answers,
                        caseSensitive: card.caseSensitive,
                        reverseCardId: card.reverseCardId, // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ID
                        reverseOf: card.reverseOf, // v16.02.00: å…ƒã‚«ãƒ¼ãƒ‰ID
                        deckId: card.deckId,
                        category: card.category,
                        tags: card.tags || [], // v10.01: ã‚¿ã‚°è¿½åŠ 
                        order: card.order, // v10.02: é †åºç•ªå·
                        // å­¦ç¿’ãƒ‡ãƒ¼ã‚¿
                        ease: card.ease,
                        interval: card.interval,
                        repetitions: card.repetitions,
                        nextReview: card.nextReview,
                        learningStep: card.learningStep,
                        state: card.state
                    };
                })
            };
            
            // JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cards_backup_${selectedCards.length}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(`${selectedCards.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ\n\nâ€»å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å®Œå…¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã§ã™ï¼ˆJSONå½¢å¼ï¼‰`);
        }

        function flipCard() {
            showingQuestion = !showingQuestion;
            displayCard();
        }

        function nextCard() {
            // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
            const filteredCards = getFilteredCards();
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showingQuestion = true;
                currentCardIsReversed = false;
                currentClozeAnswers = {};
                displayCard();
            }
        }

        function previousCard() {
            if (currentIndex > 0) {
                currentIndex--;
                showingQuestion = true;
                currentCardIsReversed = false;
                currentClozeAnswers = {};
                displayCard();
            }
        }




        // v12.01: ã‚«ãƒ¼ãƒ‰è¤‡è£½æ©Ÿèƒ½
        // v12.01.3: ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³åã¨ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¤å®šã‚’ä¿®æ­£
        // v12.01.4: loadCardså‰Šé™¤ã€Firestoreã®è‡ªå‹•æ›´æ–°ã«ä»»ã›ã‚‹
        // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰å¯¾å¿œ
        async function duplicateCard(cardId) {
            const card = cards.find(c => c.id === cardId);
            if (!card) return;
            
            // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å ´åˆã¯å…ƒã‚«ãƒ¼ãƒ‰ã‚’è¤‡è£½
            if (card.reverseOf) {
                alert('ã“ã‚Œã¯é€†è»¢ã‚«ãƒ¼ãƒ‰ã§ã™ã€‚å…ƒã®ã‚«ãƒ¼ãƒ‰ã‚’è¤‡è£½ã—ã¾ã™ã€‚');
                duplicateCard(card.reverseOf);
                return;
            }
            
            // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            let confirmMsg = '';
            if (card.type === 'typing') {
                confirmMsg = `ã€Œ${card.question}ã€ã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ`;
            } else if (card.type === 'cloze') {
                confirmMsg = `ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ã€Œ${card.text.substring(0, 30)}...ã€ã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ`;
            } else {
                confirmMsg = `ã€Œ${card.question}ã€ã‚’è¤‡è£½ã—ã¾ã™ã‹ï¼Ÿ${card.reverseCardId ? '\nï¼ˆé€†è»¢ã‚«ãƒ¼ãƒ‰ã‚‚ä¸€ç·’ã«è¤‡è£½ã•ã‚Œã¾ã™ï¼‰' : ''}`;
            }
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            try {
                const newCard = {
                    type: card.type || 'basic',
                    deckId: card.deckId,
                    category: card.category || '',
                    tags: card.tags || [],
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
                if (card.type === 'typing') {
                    newCard.question = card.question + ' (ã‚³ãƒ”ãƒ¼)';
                    newCard.answer = card.answer;
                    newCard.answers = card.answers || [];
                    newCard.caseSensitive = card.caseSensitive || false;
                } else if (card.type === 'cloze') {
                    newCard.text = card.text + ' (ã‚³ãƒ”ãƒ¼)';
                } else {
                    // basic
                    newCard.question = card.question + ' (ã‚³ãƒ”ãƒ¼)';
                    newCard.answer = card.answer;
                }
                
                // Firestoreã«è¿½åŠ 
                const newCardRef = await db.collection('flashcards').add(newCard);
                
                // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚‚è¤‡è£½
                if (card.reverseCardId) {
                    const reverseCardRef = await db.collection('flashcards').add({
                        type: 'basic',
                        deckId: card.deckId,
                        question: card.answer,
                        answer: card.question + ' (ã‚³ãƒ”ãƒ¼)',
                        tags: card.tags || [],
                        reverseOf: newCardRef.id,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    await newCardRef.update({
                        reverseCardId: reverseCardRef.id
                    });
                }
                
                alert('ã‚«ãƒ¼ãƒ‰ã‚’è¤‡è£½ã—ã¾ã—ãŸ');
                
            } catch (error) {
                console.error('ã‚«ãƒ¼ãƒ‰è¤‡è£½ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®è¤‡è£½ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        async function deleteCard(cardId) {
            // v16.02.01: å‰Šé™¤ã™ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’å–å¾—ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¤‰æ›´
            const card = cards.find(c => c.id === cardId);
            
            let confirmMsg = '';
            if (card && card.reverseOf) {
                // é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å ´åˆ
                confirmMsg = 'ã“ã®é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nâ€»å…ƒã®ã‚«ãƒ¼ãƒ‰ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“';
            } else if (card && card.reverseCardId) {
                // å…ƒã‚«ãƒ¼ãƒ‰ï¼ˆé€†è»¢ã‚«ãƒ¼ãƒ‰ã‚ã‚Šï¼‰ã®å ´åˆ
                confirmMsg = 'ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nâ€»é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚‚åŒæ™‚ã«å‰Šé™¤ã•ã‚Œã¾ã™ï¼ˆè¨ˆ2æšï¼‰';
            } else {
                // é€šå¸¸ã®ã‚«ãƒ¼ãƒ‰
                confirmMsg = 'ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ';
            }
            
            if (confirm(confirmMsg)) {
                updateSyncStatus('syncing');
                try {
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆé€†è»¢ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆã¯2å›åˆ†ï¼‰
                    const requiredWrites = card && card.reverseCardId ? 2 : 1;
                    for (let i = 0; i < requiredWrites; i++) {
                        if (!incrementWriteCounter()) {
                            alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚');
                            updateSyncStatus('synced');
                            return;
                        }
                    }
                    
                    // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚‚å‰Šé™¤
                    if (card && card.reverseCardId) {
                        await db.collection('flashcards').doc(card.reverseCardId).delete();
                    }
                    
                    // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å ´åˆã¯å…ƒã‚«ãƒ¼ãƒ‰ã®å‚ç…§ã‚’æ›´æ–°
                    if (card && card.reverseOf) {
                        await db.collection('flashcards').doc(card.reverseOf).update({
                            reverseCardId: firebase.firestore.FieldValue.delete()
                        });
                    }
                    
                    await db.collection('flashcards').doc(cardId).delete();
                    
                    // v6.00.1: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨æ¸ˆã¿ã‚«ãƒ¼ãƒ‰æ•°ã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª¿æ•´
                    const filteredCards = getFilteredCards();
                    if (currentIndex >= filteredCards.length && currentIndex > 0) {
                        currentIndex--;
                    }
                    showingQuestion = true;
                    currentCardIsReversed = false;
                    currentClozeAnswers = {};
                } catch (error) {
                    console.error('Error deleting card:', error);
                    alert('ã‚«ãƒ¼ãƒ‰ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    updateSyncStatus('error');
                }
            }
        }

        // v6.00: ã‚«ãƒ¼ãƒ‰ç·¨é›†ï¼ˆãƒ‡ãƒƒã‚­å¯¾å¿œï¼‰
        function editCard(cardId) {
            const card = cards.find(c => c.id === cardId);
            if (!card) return;
            
            // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å ´åˆã¯å…ƒã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†
            if (card.reverseOf) {
                alert('ã“ã‚Œã¯é€†è»¢ã‚«ãƒ¼ãƒ‰ã§ã™ã€‚å…ƒã®ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã¦ãã ã•ã„ã€‚');
                // å…ƒã‚«ãƒ¼ãƒ‰ã‚’é–‹ã
                editCard(card.reverseOf);
                return;
            }
            
            document.getElementById('editDeckId').value = card.deckId || '';
            
            // v10.01: ã‚¿ã‚°ã‚’èª­ã¿è¾¼ã‚€
            const tags = card.tags || [];
            document.getElementById('editCardTags').value = tags.join(' ');
            
            document.getElementById('editBasicInputs').style.display = 'none';
            document.getElementById('editClozeInputs').style.display = 'none';
            document.getElementById('editTypingInputs').style.display = 'none';
            
            if (card.type === 'typing') {
                document.getElementById('editCardType').value = 'typing';
                document.getElementById('editTypingInputs').style.display = 'block';
                document.getElementById('editTypingQuestion').value = card.question;
                const answer = card.answer || (card.answers && card.answers[0]) || '';
                document.getElementById('editTypingAnswer').value = answer;
                document.getElementById('editTypingCaseSensitive').checked = card.caseSensitive || false;
            } else if (card.type === 'cloze') {
                document.getElementById('editCardType').value = 'cloze';
                document.getElementById('editClozeInputs').style.display = 'block';
                document.getElementById('editClozeText').value = card.text;
                updateEditClozePreview();
            } else {
                document.getElementById('editCardType').value = 'basic';
                document.getElementById('editBasicInputs').style.display = 'block';
                document.getElementById('editQuestion').value = card.question;
                document.getElementById('editAnswer').value = card.answer;
                // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®æœ‰ç„¡ã§åˆ¤å®š
                document.getElementById('editEnableReverse').checked = !!card.reverseCardId;
            }
            
            editingCardId = cardId;
            
            document.getElementById('cardEditModal').style.display = 'block';
        }
        
        function closeCardEditModal() {
            document.getElementById('cardEditModal').style.display = 'none';
            editingCardId = null;
        }

        function switchEditCardType() {
            const type = document.getElementById('editCardType').value;
            
            document.getElementById('editBasicInputs').style.display = 'none';
            document.getElementById('editClozeInputs').style.display = 'none';
            document.getElementById('editTypingInputs').style.display = 'none';
            
            if (type === 'basic') {
                const clozeText = document.getElementById('editClozeText').value;
                const typingQuestion = document.getElementById('editTypingQuestion').value;
                
                if (clozeText && clozeText.trim()) {
                    const plainText = clozeText.replace(/\{\{c\d+::([^}]+)\}\}/g, '$1');
                    document.getElementById('editQuestion').value = plainText;
                    document.getElementById('editAnswer').value = '';
                } else if (typingQuestion && typingQuestion.trim()) {
                    document.getElementById('editQuestion').value = typingQuestion;
                    const answers = document.getElementById('editTypingAnswer').value;
                    document.getElementById('editAnswer').value = answers || '';
                }
                
                document.getElementById('editBasicInputs').style.display = 'block';
                
            } else if (type === 'cloze') {
                const basicQuestion = document.getElementById('editQuestion').value;
                const typingQuestion = document.getElementById('editTypingQuestion').value;
                
                if (basicQuestion && basicQuestion.trim()) {
                    document.getElementById('editClozeText').value = basicQuestion;
                } else if (typingQuestion && typingQuestion.trim()) {
                    document.getElementById('editClozeText').value = typingQuestion;
                }
                
                document.getElementById('editClozeInputs').style.display = 'block';
                updateEditClozePreview();
                
            } else if (type === 'typing') {
                const basicQuestion = document.getElementById('editQuestion').value;
                const basicAnswer = document.getElementById('editAnswer').value;
                const clozeText = document.getElementById('editClozeText').value;
                
                if (basicQuestion && basicQuestion.trim()) {
                    document.getElementById('editTypingQuestion').value = basicQuestion;
                    document.getElementById('editTypingAnswer').value = basicAnswer || '';
                } else if (clozeText && clozeText.trim()) {
                    const plainText = clozeText.replace(/\{\{c\d+::([^}]+)\}\}/g, '$1');
                    document.getElementById('editTypingQuestion').value = plainText;
                    document.getElementById('editTypingAnswer').value = '';
                }
                
                document.getElementById('editTypingInputs').style.display = 'block';
            }
        }

        function updateEditClozePreview() {
            const text = document.getElementById('editClozeText').value;
            const preview = document.getElementById('editClozePreview');
            
            if (!text.trim()) {
                preview.innerHTML = 'ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                return;
            }
            
            const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
            let hasCloze = false;
            const displayText = text.replace(clozeRegex, (match, num, answer) => {
                hasCloze = true;
                return `<span class="cloze-blank">[ç©´${num}]</span>`;
            });
            
            if (hasCloze) {
                preview.innerHTML = displayText;
            } else {
                preview.innerHTML = text + '<br><span style="color: #999; font-size: 14px;">ï¼ˆç¯„å›²ã‚’é¸æŠã—ã¦ã€Œé¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰</span>';
            }
        }

        function insertEditCloze() {
            const textarea = document.getElementById('editClozeText');
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            if (start === end) {
                alert('ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const selectedText = text.substring(start, end);
            
            const existingClozes = text.match(/\{\{c(\d+)::/g);
            let maxNum = 0;
            if (existingClozes) {
                existingClozes.forEach(match => {
                    const num = parseInt(match.match(/\d+/)[0]);
                    if (num > maxNum) maxNum = num;
                });
            }
            const nextNum = maxNum + 1;
            
            const clozeTag = `{{c${nextNum}::${selectedText}}}`;
            const newText = text.substring(0, start) + clozeTag + text.substring(end);
            
            textarea.value = newText;
            
            updateEditClozePreview();
        }

        function removeEditCloze() {
            const textarea = document.getElementById('editClozeText');
            let text = textarea.value;
            
            const clozeRegex = /\{\{c\d+::([^}]+)\}\}/g;
            const matches = [...text.matchAll(clozeRegex)];
            
            if (matches.length === 0) {
                alert('å‰Šé™¤ã™ã‚‹ç©´åŸ‹ã‚ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            const lastMatch = matches[matches.length - 1];
            const answer = lastMatch[1];
            text = text.substring(0, lastMatch.index) + answer + text.substring(lastMatch.index + lastMatch[0].length);
            
            textarea.value = text;
            
            updateEditClozePreview();
        }

        // v6.00: ç·¨é›†ã—ãŸã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒƒã‚­å¯¾å¿œï¼‰
        async function saveEditedCard() {
            const deckId = document.getElementById('editDeckId').value;
            const cardType = document.getElementById('editCardType').value;
            
            // v10.01: ã‚¿ã‚°å–å¾—
            const tagsInput = document.getElementById('editCardTags').value.trim();
            const tags = tagsInput ? tagsInput.split(/\s+/).filter(t => t.length > 0) : [];
            
            if (!deckId) {
                alert('ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            updateSyncStatus('syncing');
            
            try {
                if (cardType === 'basic') {
                    const question = document.getElementById('editQuestion').value.trim();
                    const answer = document.getElementById('editAnswer').value.trim();
                    const enableReverse = document.getElementById('editEnableReverse').checked;
                    
                    if (!question || !answer) {
                        alert('å•é¡Œã¨ç­”ãˆã®ä¸¡æ–¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v16.02.00: å…ƒã®ã‚«ãƒ¼ãƒ‰æƒ…å ±ã‚’å–å¾—
                    const originalCard = cards.find(c => c.id === editingCardId);
                    const hadReverseCard = !!originalCard.reverseCardId;
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    let requiredWrites = 1; // å…ƒã‚«ãƒ¼ãƒ‰ã®æ›´æ–°
                    if (enableReverse && !hadReverseCard) {
                        requiredWrites += 2; // é€†è»¢ã‚«ãƒ¼ãƒ‰ä½œæˆï¼ˆadd + updateï¼‰
                    } else if (!enableReverse && hadReverseCard) {
                        requiredWrites += 1; // é€†è»¢ã‚«ãƒ¼ãƒ‰å‰Šé™¤
                    } else if (enableReverse && hadReverseCard) {
                        requiredWrites += 1; // é€†è»¢ã‚«ãƒ¼ãƒ‰æ›´æ–°
                    }
                    
                    for (let i = 0; i < requiredWrites; i++) {
                        if (!incrementWriteCounter()) {
                            alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                            updateSyncStatus('synced');
                            return;
                        }
                    }
                    
                    // v16.02.00: å…ƒã®ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°
                    await db.collection('flashcards').doc(editingCardId).update({
                        type: 'basic',
                        deckId: deckId,
                        question: question,
                        answer: answer,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        text: firebase.firestore.FieldValue.delete(),
                        clozes: firebase.firestore.FieldValue.delete()
                    });
                    
                    // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã®å‡¦ç†
                    if (enableReverse && !hadReverseCard) {
                        // é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚’æ–°è¦ä½œæˆ
                        const reverseCardRef = await db.collection('flashcards').add({
                            type: 'basic',
                            deckId: deckId,
                            question: answer,
                            answer: question,
                            tags: tags,
                            order: cards.length,
                            state: 'new',
                            easeFactor: getStudySettings(deckId).startingEase,
                            interval: 0,
                            learningStep: 0,
                            repetitions: 0,
                            nextReview: Date.now(),
                            lastReviewed: null,
                            lapses: 0,
                            reverseOf: editingCardId,
                            createdAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        
                        await db.collection('flashcards').doc(editingCardId).update({
                            reverseCardId: reverseCardRef.id
                        });
                    } else if (!enableReverse && hadReverseCard) {
                        // é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                        await db.collection('flashcards').doc(originalCard.reverseCardId).delete();
                        await db.collection('flashcards').doc(editingCardId).update({
                            reverseCardId: firebase.firestore.FieldValue.delete()
                        });
                    } else if (enableReverse && hadReverseCard) {
                        // é€†è»¢ã‚«ãƒ¼ãƒ‰ã‚’æ›´æ–°
                        await db.collection('flashcards').doc(originalCard.reverseCardId).update({
                            deckId: deckId,
                            question: answer,
                            answer: question,
                            tags: tags
                        });
                    }
                    
                } else if (cardType === 'cloze') {
                    const text = document.getElementById('editClozeText').value.trim();
                    
                    if (!text) {
                        alert('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    const clozeRegex = /\{\{c(\d+)::([^}]+)\}\}/g;
                    const clozes = [];
                    let match;
                    
                    while ((match = clozeRegex.exec(text)) !== null) {
                        clozes.push({
                            id: `c${match[1]}`,
                            answer: match[2],
                            position: [match.index, match.index + match[0].length]
                        });
                    }
                    
                    if (clozes.length === 0) {
                        alert('ç©´åŸ‹ã‚ã‚’ä½œæˆã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    await db.collection('flashcards').doc(editingCardId).update({
                        type: 'cloze',
                        deckId: deckId,
                        text: text,
                        clozes: clozes,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        question: firebase.firestore.FieldValue.delete(),
                        answer: firebase.firestore.FieldValue.delete(),
                        reverseCardId: firebase.firestore.FieldValue.delete(), // v16.02.00
                        reverseOf: firebase.firestore.FieldValue.delete(), // v16.02.00
                        answers: firebase.firestore.FieldValue.delete(),
                        caseSensitive: firebase.firestore.FieldValue.delete()
                    });
                    
                } else if (cardType === 'typing') {
                    const question = document.getElementById('editTypingQuestion').value.trim();
                    const answer = document.getElementById('editTypingAnswer').value.trim();
                    const caseSensitive = document.getElementById('editTypingCaseSensitive').checked;
                    
                    if (!question || !answer) {
                        alert('å•é¡Œã¨æ­£è§£ã®ä¸¡æ–¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚«ãƒ¼ãƒ‰ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        updateSyncStatus('synced');
                        return;
                    }
                    
                    await db.collection('flashcards').doc(editingCardId).update({
                        type: 'typing',
                        deckId: deckId,
                        question: question,
                        answer: answer,
                        caseSensitive: caseSensitive,
                        tags: tags, // v10.01: ã‚¿ã‚°è¿½åŠ 
                        text: firebase.firestore.FieldValue.delete(),
                        clozes: firebase.firestore.FieldValue.delete(),
                        answers: firebase.firestore.FieldValue.delete(),
                        reverseCardId: firebase.firestore.FieldValue.delete(), // v16.02.00
                        reverseOf: firebase.firestore.FieldValue.delete() // v16.02.00
                    });
                }
                
                closeCardEditModal();
            } catch (error) {
                console.error('Error updating card:', error);
                alert('ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
                updateSyncStatus('error');
            }
        }

        // CSVå‡ºåŠ›ï¼ˆãƒ‡ãƒƒã‚­åå¯¾å¿œï¼‰
        // v10.01: Ankiç”¨CSVå‡ºåŠ›ï¼ˆã‚¿ã‚°å½¢å¼ã«å¤‰æ›´ï¼‰
        // v14.01.7: RFC 4180æº–æ‹ ã®CSVå‡ºåŠ›ã€æ”¹è¡Œå¯¾å¿œ
        // v14.01.8: ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰å¯¾å¿œ
        // v14.01.9: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰å¯¾å¿œï¼ˆåŸºæœ¬ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦å‡ºåŠ›ï¼‰
        function escapeCSVField(field) {
            if (field == null) return '';
            const str = String(field);
            // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã€ã‚«ãƒ³ãƒã€æ”¹è¡Œã‚’å«ã‚€å ´åˆã¯ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã‚€
            if (str.includes('"') || str.includes(',') || str.includes('\n') || str.includes('\r')) {
                return '"' + str.replace(/"/g, '""') + '"';
            }
            return str;
        }
        
        function exportToAnki() {
            // v10.00.1: ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¯¾è±¡ã‚’æ±ºå®š
            // å„ªå…ˆé †ä½: 1.é¸æŠã‚«ãƒ¼ãƒ‰ â†’ 2.ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ â†’ 3.å…¨ã‚«ãƒ¼ãƒ‰
            let targetCards = [];
            let exportInfo = '';
            
            if (selectedCardIds.length > 0) {
                // é¸æŠã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆ
                targetCards = cards.filter(card => selectedCardIds.includes(card.id));
                exportInfo = `é¸æŠã•ã‚ŒãŸ${targetCards.length}æš`;
            } else if (currentDeckFilter) {
                // ãƒ‡ãƒƒã‚­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ
                targetCards = cards.filter(card => card.deckId === currentDeckFilter);
                const deckName = getDeckNameById(currentDeckFilter);
                exportInfo = `ã€Œ${deckName}ã€ã®${targetCards.length}æš`;
            } else {
                // å…¨ã‚«ãƒ¼ãƒ‰
                targetCards = cards;
                exportInfo = `å…¨${targetCards.length}æš`;
            }
            
            if (targetCards.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // BOMä»˜ãCSV
            let csv = '\ufeff';
            
            let basicCount = 0;
            let clozeCount = 0;
            let typingCount = 0;
            
            targetCards.forEach(card => {
                // v16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ï¼ˆreverseOfã‚’æŒã¤ã‚«ãƒ¼ãƒ‰ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
                if (card.reverseOf) {
                    return;
                }
                
                const tags = card.tags || [];
                const tagsStr = tags.join(' ');
                const deckName = card.deckId ? getDeckNameById(card.deckId) : '';
                
                if (card.type === 'cloze') {
                    // ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ï¼šclozeText,ãƒ‡ãƒƒã‚­å,ã‚¿ã‚°
                    const clozeText = escapeCSVField(card.clozeText || card.text);
                    const deck = escapeCSVField(deckName);
                    const tagField = escapeCSVField(tagsStr);
                    
                    csv += `${clozeText},${deck},${tagField}\n`;
                    clozeCount++;
                } else if (card.type === 'typing') {
                    // v14.01.9: ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã‚’åŸºæœ¬ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦å‡ºåŠ›
                    const question = escapeCSVField(card.typingQuestion || card.question);
                    const answer = escapeCSVField(card.typingAnswer || card.answer);
                    const deck = escapeCSVField(deckName);
                    const tagField = escapeCSVField(tagsStr);
                    
                    csv += `${question},${answer},${deck},${tagField}\n`;
                    typingCount++;
                } else {
                    // åŸºæœ¬ã‚«ãƒ¼ãƒ‰ï¼ˆv16.02.00: é€†è»¢ã‚«ãƒ¼ãƒ‰ã¯åˆ¥ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦æ—¢ã«å­˜åœ¨ã™ã‚‹ã®ã§ç‰¹åˆ¥ãªå‡¦ç†ã¯ä¸è¦ï¼‰
                    const question = escapeCSVField(card.question);
                    const answer = escapeCSVField(card.answer);
                    const deck = escapeCSVField(deckName);
                    const tagField = escapeCSVField(tagsStr);
                    
                    csv += `${question},${answer},${deck},${tagField}\n`;
                    basicCount++;
                }
            });
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', 'anki_cards.csv');
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            let message = `CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼\n\nå¯¾è±¡: ${exportInfo}\n\nå‡ºåŠ›:`;
            if (basicCount > 0) message += `\nåŸºæœ¬ã‚«ãƒ¼ãƒ‰: ${basicCount}æš`;
            if (clozeCount > 0) message += `\nç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰: ${clozeCount}æš`;
            if (typingCount > 0) {
                message += `\nã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰: ${typingCount}æš`;
                message += `\n\nâ€»ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒ‰ã¯åŸºæœ¬ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦å‡ºåŠ›ã•ã‚Œã¾ã—ãŸ`;
                message += `\nï¼ˆã‚¤ãƒ³ãƒãƒ¼ãƒˆæ™‚ã¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚°æƒ…å ±ãŒå¤±ã‚ã‚Œã¾ã™ï¼‰`;
            }
            
            alert(message);
        }

        // ========== PDFæ©Ÿèƒ½ï¼ˆå¤‰æ›´ãªã—ï¼‰ ==========
        
        const uploadArea = document.getElementById('pdfUploadArea');
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                loadPDFFromFile(files[0]);
            } else {
                alert('PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
            }
        });

        function handlePDFUploadClick() {
            if (useFileSystemAPI && window.showOpenFilePicker) {
                loadPDF(null);
            } else {
                document.getElementById('pdfFileInput').click();
            }
        }

        async function loadPDF(event) {
            if (useFileSystemAPI && window.showOpenFilePicker) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'PDF Files',
                            accept: { 'application/pdf': ['.pdf'] }
                        }],
                        multiple: false
                    });
                    
                    const file = await fileHandle.getFile();
                    await loadPDFFromFile(file, fileHandle);
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚¨ãƒ©ãƒ¼:', error);
                    }
                }
            } else if (event && event.target && event.target.files) {
                const file = event.target.files[0];
                if (file && file.type === 'application/pdf') {
                    await loadPDFFromFile(file, null);
                }
            }
        }

        async function loadPDFFromFile(file, fileHandle = null) {
            try {
                currentPDFFile = file;
                
                pdfHash = await calculateFileHash(file);
                console.log('PDF Hash:', pdfHash);
                
                // v14.00.12: PDFåˆ‡ã‚Šæ›¿ãˆæ™‚ã«å…¨ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (markerMode) toggleMarkerMode();
                if (editMode) toggleEditMode();
                if (deleteMode) toggleDeleteMode();
                
                // v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚‚çµ‚äº†
                if (previewMode) exitPreviewMode();
                
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument({
                    data: arrayBuffer,
                    disableFontFace: false,
                    useSystemFonts: false,
                    standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/',
                    cMapUrl: 'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
                    cMapPacked: true
                }).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                
                // v14.00: PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¨˜éŒ²
                currentPdfMetadata = {
                    fileName: file.name,
                    totalPages: totalPages,
                    fileSize: file.size,
                    lastUpdated: Date.now()
                };
                console.log('PDF Metadata:', currentPdfMetadata);
                
                document.getElementById('pdfUploadArea').style.display = 'none';
                document.getElementById('pdfViewerContainer').style.display = 'block';
                document.getElementById('pdfFilename').textContent = file.name;
                
                // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                document.getElementById('studyModeBtn').style.display = 'block';
                
                // v15.01.3: å…¨ç”»é¢è¡¨ç¤ºãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºã—ã€è¨­å®šã‚’èª­ã¿è¾¼ã‚€
                const fullscreenLabel = document.getElementById('fullscreenLabel');
                if (fullscreenLabel) {
                    fullscreenLabel.style.visibility = 'visible';
                }
                loadFullscreenSetting();
                
                // v7.01: çµ±è¨ˆãƒ‘ãƒãƒ«ã‚’è¡¨ç¤ºã—ã€çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
                const statsPanel = document.getElementById('studyStats');
                if (statsPanel) {
                    statsPanel.style.display = 'flex';
                    statsPanel.classList.add('inactive');
                }
                resetStudyTimer();
                
                await loadMarkersFromFirebase();
                
                // v7.02: å­¦ç¿’è¨˜éŒ²ã‚’èª­ã¿è¾¼ã¿
                await loadStudySessionFromFirebase();
                
                await renderPage(currentPage);
                
                // v7.01: åˆæœŸçµ±è¨ˆã‚’æ›´æ–°
                updateStudyStats();
                
            } catch (error) {
                console.error('PDFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        async function loadPDFFromArrayBuffer(arrayBuffer, fileName) {
            try {
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                pdfHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                // v14.00.10: PDFåˆ‡ã‚Šæ›¿ãˆæ™‚ã«å…¨ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (markerMode) toggleMarkerMode();
                if (editMode) toggleEditMode();
                if (deleteMode) toggleDeleteMode();
                
                // v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚‚çµ‚äº†
                if (previewMode) exitPreviewMode();
                
                pdfDoc = await pdfjsLib.getDocument({
                    data: arrayBuffer,
                    disableFontFace: false,
                    useSystemFonts: false,
                    standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/',
                    cMapUrl: 'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
                    cMapPacked: true
                }).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                currentPDFFile = { name: fileName };
                
                document.getElementById('pdfUploadArea').style.display = 'none';
                document.getElementById('pdfViewerContainer').style.display = 'block';
                document.getElementById('pdfFilename').textContent = fileName;
                
                // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                document.getElementById('studyModeBtn').style.display = 'block';
                
                // v7.01: çµ±è¨ˆãƒ‘ãƒãƒ«ã‚’è¡¨ç¤ºã—ã€çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
                const statsPanel = document.getElementById('studyStats');
                if (statsPanel) {
                    statsPanel.style.display = 'flex';
                    statsPanel.classList.add('inactive');
                }
                resetStudyTimer();
                
                await loadMarkersFromFirebase();
                
                // v7.02: å­¦ç¿’è¨˜éŒ²ã‚’èª­ã¿è¾¼ã¿
                await loadStudySessionFromFirebase();
                
                await renderPage(currentPage);
                
                // v7.01: åˆæœŸçµ±è¨ˆã‚’æ›´æ–°
                updateStudyStats();
                
                // v14.00.12: PDFèª­ã¿è¾¼ã¿å®Œäº†å¾Œã€ãƒãƒ¼ã‚«ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’ç¢ºå®Ÿã«OFFã«ã™ã‚‹
                if (markerMode) {
                    markerMode = false;
                    const markerModeBtn = document.getElementById('markerModeBtn');
                    if (markerModeBtn) {
                        markerModeBtn.textContent = 'ãƒãƒ¼ã‚«ãƒ¼OFF';
                        markerModeBtn.className = 'btn btn-mode-off';
                    }
                    const canvas = document.getElementById('markerCanvas');
                    if (canvas) {
                        canvas.style.cursor = 'default';
                    }
                }
                
            } catch (error) {
                console.error('PDFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        async function calculateFileHash(file) {
            const arrayBuffer = await file.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex;
        }

        async function renderPage(pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                
                let pdfCanvas = document.getElementById('pdfCanvas');
                const oldPdfCanvas = pdfCanvas;
                pdfCanvas = document.createElement('canvas');
                pdfCanvas.id = 'pdfCanvas';
                oldPdfCanvas.parentNode.replaceChild(pdfCanvas, oldPdfCanvas);
                
                const pdfCtx = pdfCanvas.getContext('2d');
                
                const viewport = page.getViewport({scale: scale});
                
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;
                
                const renderContext = {
                    canvasContext: pdfCtx,
                    viewport: viewport,
                    intent: 'display'
                };
                
                const renderTask = page.render(renderContext);
                await renderTask.promise;
                
                let markerCanvas = document.getElementById('markerCanvas');
                if (!markerCanvas) {
                    markerCanvas = document.createElement('canvas');
                    markerCanvas.id = 'markerCanvas';
                    document.getElementById('canvasWrapper').appendChild(markerCanvas);
                } else {
                    const oldMarkerCanvas = markerCanvas;
                    markerCanvas = document.createElement('canvas');
                    markerCanvas.id = 'markerCanvas';
                    oldMarkerCanvas.parentNode.replaceChild(markerCanvas, oldMarkerCanvas);
                }
                
                markerCanvas.width = viewport.width;
                markerCanvas.height = viewport.height;
                
                // v14.00.14: previewCanvasã‚‚å†ä½œæˆ
                let previewCanvas = document.getElementById('previewCanvas');
                if (!previewCanvas) {
                    previewCanvas = document.createElement('canvas');
                    previewCanvas.id = 'previewCanvas';
                    previewCanvas.style.position = 'absolute';
                    previewCanvas.style.top = '0';
                    previewCanvas.style.left = '0';
                    previewCanvas.style.pointerEvents = 'none';
                    previewCanvas.style.zIndex = '10';
                    previewCanvas.style.display = 'none';
                    document.getElementById('canvasWrapper').appendChild(previewCanvas);
                } else {
                    const oldPreviewCanvas = previewCanvas;
                    previewCanvas = document.createElement('canvas');
                    previewCanvas.id = 'previewCanvas';
                    previewCanvas.style.position = 'absolute';
                    previewCanvas.style.top = '0';
                    previewCanvas.style.left = '0';
                    previewCanvas.style.pointerEvents = 'none';
                    previewCanvas.style.zIndex = '10';
                    previewCanvas.style.display = previewMode ? 'block' : 'none';
                    oldPreviewCanvas.parentNode.replaceChild(previewCanvas, oldPreviewCanvas);
                }
                previewCanvas.width = viewport.width;
                previewCanvas.height = viewport.height;
                
                // v14.00.12: Canvaså†ä½œæˆæ™‚ã«ãƒãƒ¼ã‚«ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’åæ˜ 
                if (markerMode) {
                    markerCanvas.style.cursor = 'crosshair';
                } else {
                    markerCanvas.style.cursor = 'default';
                }
                
                setupMarkerEvents(markerCanvas);
                
                // v7.00.2: ãƒšãƒ¼ã‚¸é·ç§»æ™‚ã«ã‚¯ãƒªãƒƒã‚¯æ˜è»¢çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                sheetClickToggles = {};
                
                drawMarkers();
                
                // v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ—§ãƒãƒ¼ã‚«ãƒ¼ã‚‚å†æç”»
                if (previewMode) {
                    drawPreviewMarkers();
                }
                
                await renderTextLayer(page, viewport);
                
                offsetX = 0;
                offsetY = 0;
                updateCanvasPosition();
                
                document.getElementById('pageInfo').textContent = `${currentPage} / ${totalPages}`;
                document.getElementById('zoomInfo').textContent = `${Math.round(scale * 100)}%`;
                
                // v15.01.0: å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒšãƒ¼ã‚¸æƒ…å ±ã‚‚æ›´æ–°
                const fullscreenPageInfo = document.getElementById('fullscreenPageInfo');
                if (fullscreenPageInfo) {
                    fullscreenPageInfo.textContent = `${currentPage} / ${totalPages}`;
                }
                
            } catch (error) {
                console.error('ãƒšãƒ¼ã‚¸ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function renderTextLayer(page, viewport) {
            try {
                const textLayer = document.getElementById('textLayer');
                if (!textLayer) return;
                
                textLayer.innerHTML = '';
                textLayer.style.width = viewport.width + 'px';
                textLayer.style.height = viewport.height + 'px';
                
                textLayer.style.setProperty('--scale-factor', viewport.scale);
                
                const textContent = await page.getTextContent();
                
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: textLayer,
                    viewport: viewport,
                    textDivs: []
                });
                
            } catch (error) {
                console.error('ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        async function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                await renderPage(currentPage);
            }
        }

        async function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                await renderPage(currentPage);
            }
        }

        // v16.01.00: ãƒšãƒ¼ã‚¸ã‚¸ãƒ£ãƒ³ãƒ—æ©Ÿèƒ½
        function showPageJumpInput() {
            if (!pdfDoc) return;
            
            const pageInfo = document.getElementById('pageInfo');
            const fullscreenPageInfo = document.getElementById('fullscreenPageInfo');
            
            // å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            const isFullscreen = document.getElementById('fullscreenControls').style.display !== 'none';
            const targetElement = isFullscreen ? fullscreenPageInfo : pageInfo;
            
            if (!targetElement) return;
            
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½œæˆ
            const input = document.createElement('input');
            input.type = 'number';
            input.min = '1';
            input.max = totalPages.toString();
            input.value = currentPage.toString();
            input.style.width = '60px';
            input.style.textAlign = 'center';
            input.style.fontSize = isFullscreen ? '14px' : '16px';
            input.style.padding = '4px';
            input.style.border = '2px solid #2196f3';
            input.style.borderRadius = '4px';
            
            // å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿å­˜
            const originalText = targetElement.textContent;
            
            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ç½®ãæ›ãˆ
            targetElement.textContent = '';
            targetElement.appendChild(input);
            input.focus();
            input.select();
            
            // Enterã‚­ãƒ¼ã§ç§»å‹•
            input.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter') {
                    const pageNum = parseInt(input.value);
                    if (pageNum >= 1 && pageNum <= totalPages) {
                        currentPage = pageNum;
                        await renderPage(currentPage);
                    }
                    // å…ƒã®è¡¨ç¤ºã«æˆ»ã™
                    targetElement.textContent = `${currentPage} / ${totalPages}`;
                }
            });
            
            // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å¤±ã£ãŸã‚‰å…ƒã«æˆ»ã™
            input.addEventListener('blur', () => {
                targetElement.textContent = `${currentPage} / ${totalPages}`;
            });
            
            // Escapeã‚­ãƒ¼ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    targetElement.textContent = `${currentPage} / ${totalPages}`;
                }
            });
        }

        async function zoomIn() {
            const oldScale = scale;
            
            // v15.00.0: ç¾åœ¨ã®æ‹¡å¤§ç‡ã‚’0.5åˆ»ã¿ã«ä¸¸ã‚ã¦ã‹ã‚‰+0.5
            const roundedScale = Math.round(scale * 2) / 2;  // 0.5åˆ»ã¿ã«ä¸¸ã‚ã‚‹
            scale = roundedScale + 0.5;
            
            if (scale > 3.0) scale = 3.0;
            
            if (oldScale !== scale) {
                await renderPage(currentPage);
            }
        }

        async function zoomOut() {
            const oldScale = scale;
            
            // v15.00.0: ç¾åœ¨ã®æ‹¡å¤§ç‡ã‚’0.5åˆ»ã¿ã«ä¸¸ã‚ã¦ã‹ã‚‰-0.5
            const roundedScale = Math.round(scale * 2) / 2;  // 0.5åˆ»ã¿ã«ä¸¸ã‚ã‚‹
            scale = roundedScale - 0.5;
            
            if (scale < 0.5) scale = 0.5;
            
            if (oldScale !== scale) {
                await renderPage(currentPage);
            }
        }
        
        function selectMarkerColor(color) {
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ“ä½œä¸å¯
            if (studyMode) return;
            
            currentMarkerColor = color;
            
            document.querySelectorAll('.color-btn').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        function toggleMarkerMode() {
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ“ä½œä¸å¯
            if (studyMode) return;
            
            markerMode = !markerMode;
            const canvas = document.getElementById('markerCanvas');
            const btn = document.getElementById('markerModeBtn');
            
            if (markerMode) {
                btn.textContent = 'ãƒãƒ¼ã‚«ãƒ¼ON';
                btn.className = 'btn btn-mode-on';
                if (canvas) canvas.style.cursor = 'crosshair';
                
                if (editMode) toggleEditMode();
                if (deleteMode) toggleDeleteMode();
            } else {
                btn.textContent = 'ãƒãƒ¼ã‚«ãƒ¼OFF';
                btn.className = 'btn btn-mode-off';
                if (canvas) canvas.style.cursor = 'default';
            }
        }
        
        // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã®ãƒˆã‚°ãƒ«
        function toggleFixHeightMode() {
            fixHeightMode = document.getElementById('fixHeightCheckbox').checked;
            
            // é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã‚’ONã«ã—ãŸæ™‚ã€ç›´å‰ã®ãƒãƒ¼ã‚«ãƒ¼é«˜ã•ãŒãªã„å ´åˆã¯è­¦å‘Š
            if (fixHeightMode && lastMarkerHeight === 0) {
                alert('é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ã€ã¾ãšåŸºæº–ã¨ãªã‚‹ãƒãƒ¼ã‚«ãƒ¼ã‚’1ã¤ä½œæˆã—ã¦ãã ã•ã„ã€‚');
                document.getElementById('fixHeightCheckbox').checked = false;
                fixHeightMode = false;
            }
        }
        
        function toggleEditMode() {
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ“ä½œä¸å¯
            if (studyMode) return;
            
            editMode = !editMode;
            const canvas = document.getElementById('markerCanvas');
            const btn = document.getElementById('editModeBtn');
            
            if (editMode) {
                btn.textContent = 'ğŸ“ ä¿®æ­£ON';
                btn.className = 'btn btn-mode-on';
                if (canvas) {
                    canvas.classList.add('edit-mode');
                    canvas.style.cursor = 'move';
                }
                
                if (markerMode) toggleMarkerMode();
                if (deleteMode) toggleDeleteMode();
            } else {
                btn.textContent = 'ğŸ“ ä¿®æ­£OFF';
                btn.className = 'btn btn-mode-off';
                if (canvas) {
                    canvas.classList.remove('edit-mode');
                    canvas.style.cursor = 'default';
                }
                
                selectedMarkerIndex = null;
                selectedMarkerPage = null;
                movingMarker = false; // v15.01.14: ç§»å‹•ãƒ¢ãƒ¼ãƒ‰ã‚‚ãƒªã‚»ãƒƒãƒˆ
                resizingHandle = null; // v15.01.14: ãƒªã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚‚ãƒªã‚»ãƒƒãƒˆ
                drawMarkers();
            }
        }
        
        function toggleDeleteMode() {
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯æ“ä½œä¸å¯
            if (studyMode) return;
            
            deleteMode = !deleteMode;
            const canvas = document.getElementById('markerCanvas');
            const btn = document.getElementById('deleteModeBtn');
            
            if (deleteMode) {
                btn.textContent = 'ğŸ—‘ï¸ å‰Šé™¤ON';
                btn.className = 'btn btn-mode-on';
                if (canvas) {
                    canvas.classList.add('delete-mode');
                    canvas.style.cursor = 'not-allowed';
                }
                
                if (markerMode) toggleMarkerMode();
                if (editMode) toggleEditMode();
            } else {
                btn.textContent = 'ğŸ—‘ï¸ å‰Šé™¤OFF';
                btn.className = 'btn btn-mode-off';
                if (canvas) {
                    canvas.classList.remove('delete-mode');
                    canvas.style.cursor = 'default';
                }
            }
        }
        
        function toggleRedSheetColor(color) {
            if (color === 'all') {
                const newState = !redSheetColors.all;
                redSheetColors = {
                    yellow: newState,
                    red: newState,
                    green: newState,
                    blue: newState,
                    all: newState
                };
                
                ['yellow', 'red', 'green', 'blue', 'all'].forEach(c => {
                    const btn = document.getElementById('redsheet' + c.charAt(0).toUpperCase() + c.slice(1));
                    if (btn) {
                        if (newState) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                });
            } else {
                redSheetColors[color] = !redSheetColors[color];
                const btn = document.getElementById('redsheet' + color.charAt(0).toUpperCase() + color.slice(1));
                
                if (btn) {
                    if (redSheetColors[color]) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
                
                const allActive = redSheetColors.yellow && redSheetColors.red && 
                                 redSheetColors.green && redSheetColors.blue;
                redSheetColors.all = allActive;
                const allBtn = document.getElementById('redsheetAll');
                if (allBtn) {
                    if (allActive) {
                        allBtn.classList.add('active');
                    } else {
                        allBtn.classList.remove('active');
                    }
                }
            }
            
            // v7.00.2: ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³å¤‰æ›´æ™‚ã«ã‚¯ãƒªãƒƒã‚¯æ˜è»¢çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            sheetClickToggles = {};
            
            drawMarkers();
            
            // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã¯ã‚·ãƒ¼ãƒˆå¤‰æ›´ã§çµ±è¨ˆã‚’å†è¨ˆç®—
            if (studyMode) {
                updateStudyStats();
            }
            
            // v15.01.0: å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒœã‚¿ãƒ³ã‚‚åŒæœŸ
            if (fullscreenMode) {
                ['yellow', 'red', 'green', 'blue'].forEach(c => {
                    const fullscreenBtn = document.getElementById('fullscreenSheet' + c.charAt(0).toUpperCase() + c.slice(1));
                    if (fullscreenBtn) {
                        if (redSheetColors[c]) {
                            fullscreenBtn.classList.add('active');
                        } else {
                            fullscreenBtn.classList.remove('active');
                        }
                    }
                });
            }
        }
        
        // v7.03: å­¦ç¿’çµ±è¨ˆã‚’æ›´æ–°ï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã¯ã‚·ãƒ¼ãƒˆONã®è‰²ã®ã¿é›†è¨ˆï¼‰
        function updateStudyStats() {
            if (!pdfHash || !markers[pdfHash]) return;
            
            let correctCount = 0;
            let incorrectCount = 0;
            let unstudiedCount = 0;
            let weakMarkerCount = 0; // v9.00: è‹¦æ‰‹ãƒãƒ¼ã‚«ãƒ¼æ•°
            
            // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã¯ã‚·ãƒ¼ãƒˆONã®è‰²ã®ã¿é›†è¨ˆã€OFFæ™‚ã¯å…¨ãƒãƒ¼ã‚«ãƒ¼é›†è¨ˆ
            Object.keys(markers[pdfHash]).forEach(pageNum => {
                markers[pdfHash][pageNum].forEach(marker => {
                    // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã¯ã‚·ãƒ¼ãƒˆONã®è‰²ã®ã¿é›†è¨ˆ
                    if (studyMode && !redSheetColors[marker.color]) {
                        return;  // ã‚·ãƒ¼ãƒˆOFFã®è‰²ã¯ã‚¹ã‚­ãƒƒãƒ—
                    }
                    
                    if (marker.studyState === 'correct') {
                        correctCount++;
                    } else if (marker.studyState === 'incorrect') {
                        incorrectCount++;
                    } else {
                        // undefined, 'hidden', 'visible' ã¯ã™ã¹ã¦æœªå­¦ç¿’æ‰±ã„
                        unstudiedCount++;
                    }
                    
                    // v9.00: è‹¦æ‰‹ãƒãƒ¼ã‚«ãƒ¼åˆ¤å®š
                    const markerCorrectCount = marker.correctCount || 0;
                    const markerIncorrectCount = marker.incorrectCount || 0;
                    const markerTotalCount = markerCorrectCount + markerIncorrectCount;
                    if (markerTotalCount >= 2 && markerIncorrectCount / markerTotalCount >= 0.5) {
                        weakMarkerCount++;
                    }
                });
            });
            
            // çµ±è¨ˆè¡¨ç¤ºã‚’æ›´æ–°
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('incorrectCount').textContent = incorrectCount;
            document.getElementById('unstudiedCount').textContent = unstudiedCount;
            document.getElementById('weakMarkerCount').textContent = weakMarkerCount; // v9.00
            
            // æ­£ç­”ç‡ã‚’è¨ˆç®—
            const totalStudied = correctCount + incorrectCount;
            let accuracyRate = 'N/A';
            if (totalStudied > 0) {
                accuracyRate = Math.round((correctCount / totalStudied) * 100) + '%';
            }
            document.getElementById('accuracyRate').textContent = accuracyRate;
        }
        
        // v7.02.1: ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ï¼ˆå®šæœŸä¿å­˜ã‚‚é–‹å§‹ï¼‰
        function startStudyTimer() {
            if (studyTimerInterval) return; // æ—¢ã«å‹•ä½œä¸­
            
            studyStartTime = Date.now() - studyElapsedTime;
            
            studyTimerInterval = setInterval(() => {
                studyElapsedTime = Date.now() - studyStartTime;
                updateTimerDisplay();
            }, 1000);
            
            // v7.02.1: 3ç§’ã”ã¨ã«è‡ªå‹•ä¿å­˜
            if (!autoSaveInterval) {
                autoSaveInterval = setInterval(() => {
                    saveStudySessionToFirebase();
                }, 3000); // 3ç§’
            }
        }
        
        // v7.02.1: ã‚¿ã‚¤ãƒãƒ¼åœæ­¢ï¼ˆå®šæœŸä¿å­˜ã‚‚åœæ­¢ï¼‰
        function pauseStudyTimer() {
            if (studyTimerInterval) {
                clearInterval(studyTimerInterval);
                studyTimerInterval = null;
            }
            
            // v7.02.1: å®šæœŸä¿å­˜ã‚’åœæ­¢
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }
        
        // v7.01: ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
        function resetStudyTimer() {
            pauseStudyTimer();
            studyElapsedTime = 0;
            studyStartTime = null;
            updateTimerDisplay();
        }
        
        // v7.02: ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºæ›´æ–°ï¼ˆä»Šå›å‘¨ã¨ç·å­¦ç¿’æ™‚é–“ï¼‰
        function updateTimerDisplay() {
            // ä»Šå›å‘¨ã®å­¦ç¿’æ™‚é–“
            const totalSeconds = Math.floor(studyElapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            const timeString = 
                String(hours).padStart(2, '0') + ':' +
                String(minutes).padStart(2, '0') + ':' +
                String(seconds).padStart(2, '0');
            
            document.getElementById('studyTime').textContent = timeString;
            
            // ç·å­¦ç¿’æ™‚é–“
            const totalStudySeconds = Math.floor((totalStudyTime + studyElapsedTime) / 1000);
            const totalHours = Math.floor(totalStudySeconds / 3600);
            const totalMinutes = Math.floor((totalStudySeconds % 3600) / 60);
            const totalSecs = totalStudySeconds % 60;
            
            const totalTimeString = 
                String(totalHours).padStart(2, '0') + ':' +
                String(totalMinutes).padStart(2, '0') + ':' +
                String(totalSecs).padStart(2, '0');
            
            document.getElementById('totalStudyTime').textContent = totalTimeString;
        }
        
        // v7.02: å‘¨å›æ•°è¡¨ç¤ºã‚’æ›´æ–°
        function updateLapDisplay() {
            document.getElementById('lapCount').textContent = lapCount;
        }
        
        // v7.02.1: å…¨ãƒªã‚»ãƒƒãƒˆï¼ˆã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’åˆæœŸåŒ–ï¼‰
        async function resetLapFull() {
            if (!pdfHash) return;
            
            if (!confirm('ã“ã®å‘¨ã‚’çµ‚äº†ã—ã¦æ¬¡ã®å‘¨ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ\n\nãƒ»ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹ãŒåˆæœŸåŒ–ã•ã‚Œã¾ã™ï¼ˆæš—è»¢ã«æˆ»ã‚‹ï¼‰\nãƒ»æ­£ç­”ãƒãƒ¼ã‚«ãƒ¼ã‚‚å­¦ç¿’å¯¾è±¡ã«æˆ»ã‚Šã¾ã™\nãƒ»ä»Šå›å‘¨ã®çµ±è¨ˆãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™\nãƒ»ç·å­¦ç¿’æ™‚é–“ã«åŠ ç®—ã•ã‚Œã¾ã™')) {
                return;
            }
            
            // ä»Šå›å‘¨ã®æ™‚é–“ã‚’ç·å­¦ç¿’æ™‚é–“ã«åŠ ç®—
            totalStudyTime += studyElapsedTime;
            
            // å‘¨å›æ•°ã‚’+1
            lapCount++;
            
            // v9.00: ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆã‚’æ›´æ–°ï¼ˆå‘¨å›çµ‚äº†æ™‚ã«ç¢ºå®šï¼‰
            if (markers[pdfHash]) {
                Object.keys(markers[pdfHash]).forEach(pageNum => {
                    markers[pdfHash][pageNum].forEach(marker => {
                        // æ­£ç­”ãƒãƒ¼ã‚«ãƒ¼: correctCount +1ï¼ˆlockedæ¸ˆã¿ã¯é™¤å¤–ï¼‰
                        if (marker.studyState === 'correct' && !marker.locked) {
                            marker.correctCount = (marker.correctCount || 0) + 1;
                            marker.lastStudied = Date.now();
                            // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
                            sessionCorrectCount++;
                        }
                        // èª¤ç­”ãƒãƒ¼ã‚«ãƒ¼: incorrectCount +1
                        else if (marker.studyState === 'incorrect') {
                            marker.incorrectCount = (marker.incorrectCount || 0) + 1;
                            marker.lastStudied = Date.now();
                            // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
                            sessionIncorrectCount++;
                        }
                    });
                });
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹ã‚’åˆæœŸåŒ–ï¼ˆå…¨ãƒšãƒ¼ã‚¸ãƒ»ã™ã¹ã¦ã®ãƒãƒ¼ã‚«ãƒ¼ï¼‰
            if (markers[pdfHash]) {
                Object.keys(markers[pdfHash]).forEach(pageNum => {
                    markers[pdfHash][pageNum].forEach(marker => {
                        delete marker.studyState;  // undefined = æš—è»¢çŠ¶æ…‹
                        delete marker.locked;  // v9.00: ãƒ­ãƒƒã‚¯ã‚‚è§£é™¤
                    });
                });
            }
            
            // ä»Šå›å‘¨ã®çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
            studyElapsedTime = 0;
            studyStartTime = Date.now();  // ã‚¿ã‚¤ãƒãƒ¼ã¯ç¶™ç¶š
            
            // è¡¨ç¤ºã‚’æ›´æ–°
            updateTimerDisplay();
            updateLapDisplay();
            updateStudyStats();
            drawMarkers();
            
            // Firebaseã«ä¿å­˜
            await saveMarkersToFirebase();  // ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹
            await saveStudySessionToFirebase();  // å­¦ç¿’è¨˜éŒ²
        }
        
        // v7.02.1: å¾©ç¿’ãƒªã‚»ãƒƒãƒˆï¼ˆæ­£ç­”ä»¥å¤–ã®ãƒãƒ¼ã‚«ãƒ¼ã®ã¿åˆæœŸåŒ–ï¼‰
        async function resetLapReview() {
            if (!pdfHash) return;
            
            if (!confirm('å¾©ç¿’ãƒªã‚»ãƒƒãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ\n\nãƒ»æ­£ç­”ã—ãŸãƒãƒ¼ã‚«ãƒ¼ã¯ç¶­æŒã•ã‚Œã¾ã™\nãƒ»èª¤ç­”ãƒ»æœªå­¦ç¿’ã®ãƒãƒ¼ã‚«ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¾ã™ï¼ˆæš—è»¢ã«æˆ»ã‚‹ï¼‰\nãƒ»ä»Šå›å‘¨ã®çµ±è¨ˆãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™\nãƒ»ç·å­¦ç¿’æ™‚é–“ã«åŠ ç®—ã•ã‚Œã¾ã™')) {
                return;
            }
            
            // ä»Šå›å‘¨ã®æ™‚é–“ã‚’ç·å­¦ç¿’æ™‚é–“ã«åŠ ç®—
            totalStudyTime += studyElapsedTime;
            
            // å‘¨å›æ•°ã‚’+1
            lapCount++;
            
            // v9.00: ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆã‚’æ›´æ–°ï¼ˆå‘¨å›çµ‚äº†æ™‚ã«ç¢ºå®šï¼‰
            if (markers[pdfHash]) {
                Object.keys(markers[pdfHash]).forEach(pageNum => {
                    markers[pdfHash][pageNum].forEach(marker => {
                        // æ­£ç­”ãƒãƒ¼ã‚«ãƒ¼: correctCount +1 & lockedè¨­å®šï¼ˆlockedæ¸ˆã¿ã¯é™¤å¤–ï¼‰
                        if (marker.studyState === 'correct' && !marker.locked) {
                            marker.correctCount = (marker.correctCount || 0) + 1;
                            marker.lastStudied = Date.now();
                            marker.locked = true;  // v9.00: ã‚¯ãƒªãƒƒã‚¯ä¸å¯ã«ã™ã‚‹
                            // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
                            sessionCorrectCount++;
                        }
                        // èª¤ç­”ãƒãƒ¼ã‚«ãƒ¼: incorrectCount +1
                        else if (marker.studyState === 'incorrect') {
                            marker.incorrectCount = (marker.incorrectCount || 0) + 1;
                            marker.lastStudied = Date.now();
                            // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
                            sessionIncorrectCount++;
                        }
                    });
                });
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹ã‚’åˆæœŸåŒ–ï¼ˆæ­£ç­”ä»¥å¤–ã®ã¿ï¼‰
            if (markers[pdfHash]) {
                Object.keys(markers[pdfHash]).forEach(pageNum => {
                    markers[pdfHash][pageNum].forEach(marker => {
                        // æ­£ç­”ï¼ˆcorrectï¼‰ä»¥å¤–ã‚’åˆæœŸåŒ–
                        if (marker.studyState !== 'correct') {
                            delete marker.studyState;  // undefined = æš—è»¢çŠ¶æ…‹
                            delete marker.locked;  // ãƒ­ãƒƒã‚¯ã‚‚è§£é™¤
                        }
                    });
                });
            }
            
            // ä»Šå›å‘¨ã®çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ
            studyElapsedTime = 0;
            studyStartTime = Date.now();  // ã‚¿ã‚¤ãƒãƒ¼ã¯ç¶™ç¶š
            
            // è¡¨ç¤ºã‚’æ›´æ–°
            updateTimerDisplay();
            updateLapDisplay();
            updateStudyStats();
            drawMarkers();
            
            // Firebaseã«ä¿å­˜
            await saveMarkersToFirebase();  // ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹
            await saveStudySessionToFirebase();  // å­¦ç¿’è¨˜éŒ²
        }
        
        // v7.02.1: å­¦ç¿’è¨˜éŒ²ã‚’Firebaseã«ä¿å­˜ï¼ˆä»Šå›å‘¨ã®æ™‚é–“ã‚‚ä¿å­˜ï¼‰
        async function saveStudySessionToFirebase() {
            if (!pdfHash) return;
            
            // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            if (!incrementWriteCounter()) {
                console.warn('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚PDFå­¦ç¿’è¨˜éŒ²ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                return;
            }
            
            try {
                // æ—¢å­˜ã®ç´¯ç©ãƒ‡ãƒ¼ã‚¿ä¿å­˜
                await db.collection('studySessions').doc(pdfHash).set({
                    totalStudyTime: totalStudyTime,
                    lapCount: lapCount,
                    currentLapElapsedTime: studyElapsedTime,  // ä»Šå›å‘¨ã®ç´¯ç©æ™‚é–“
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’ä¿å­˜
                if (currentSessionStartTime) {
                    const sessionEndTime = Date.now();
                    const sessionDuration = sessionEndTime - currentSessionStartTime;
                    
                    // æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ç”¨ï¼‰
                    if (!incrementWriteCounter()) {
                        console.warn('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        return;
                    }
                    
                    await db.collection('studySessionHistory').add({
                        pdfHash: pdfHash,
                        startTime: firebase.firestore.Timestamp.fromMillis(currentSessionStartTime),
                        endTime: firebase.firestore.Timestamp.fromMillis(sessionEndTime),
                        duration: sessionDuration,
                        correctCount: sessionCorrectCount,
                        incorrectCount: sessionIncorrectCount,
                        studiedMarkerCount: sessionStudiedMarkers.size,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // ã‚»ãƒƒã‚·ãƒ§ãƒ³å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
                    currentSessionStartTime = null;
                }
            } catch (error) {
                console.error('å­¦ç¿’è¨˜éŒ²ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                if (error.code === 'resource-exhausted') {
                    showWriteLimitWarning(FIRESTORE_DAILY_LIMIT);
                }
            }
        }
        
        // v7.02.1: å­¦ç¿’è¨˜éŒ²ã‚’Firebaseã‹ã‚‰èª­ã¿è¾¼ã¿ï¼ˆä»Šå›å‘¨ã®æ™‚é–“ã‚‚å¾©å…ƒï¼‰
        async function loadStudySessionFromFirebase() {
            if (!pdfHash) return;
            
            try {
                const doc = await db.collection('studySessions').doc(pdfHash).get();
                if (doc.exists) {
                    const data = doc.data();
                    totalStudyTime = data.totalStudyTime || 0;
                    lapCount = data.lapCount || 1;
                    studyElapsedTime = data.currentLapElapsedTime || 0;  // ä»Šå›å‘¨ã®æ™‚é–“ã‚’å¾©å…ƒ
                } else {
                    // åˆå›ã¯åˆæœŸå€¤
                    totalStudyTime = 0;
                    lapCount = 1;
                    studyElapsedTime = 0;
                }
                
                updateTimerDisplay();
                updateLapDisplay();
            } catch (error) {
                console.error('å­¦ç¿’è¨˜éŒ²ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                totalStudyTime = 0;
                lapCount = 1;
                studyElapsedTime = 0;
            }
        }
        
        // v7.02.1: éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ¤œçŸ¥ã®åˆæœŸåŒ–
        function initVisibilityChange() {
            document.addEventListener('visibilitychange', async () => {
                if (document.hidden && studyMode) {
                    // ã‚¿ãƒ–ãŒéã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã£ãŸ â†’ è‡ªå‹•ã§å­¦ç¿’OFF
                    await toggleStudyMode();
                }
            });
        }
        
        // v7.02.1: ãƒšãƒ¼ã‚¸ã‚’é›¢ã‚Œã‚‹å‰ã«ä¿å­˜
        window.addEventListener('beforeunload', () => {
            if (studyMode && pdfHash) {
                saveStudySessionToFirebase();
            }
        });
        
        // v7.02.1: åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        initVisibilityChange();
        
        // v7.02: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ãƒˆã‚°ãƒ«
        async function toggleStudyMode() {
            studyMode = !studyMode;
            const btn = document.getElementById('studyModeBtn');
            const canvas = document.getElementById('markerCanvas');
            const statsPanel = document.getElementById('studyStats');
            
            if (studyMode) {
                // å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ON
                btn.textContent = 'å­¦ç¿’ON';
                btn.className = 'btn btn-mode-on';
                
                // æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ‰ã‚’ã™ã¹ã¦OFF
                if (markerMode) toggleMarkerMode();
                if (editMode) toggleEditMode();
                if (deleteMode) toggleDeleteMode();
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚«ãƒ¼ã‚½ãƒ«ã‚’å¤‰æ›´
                if (canvas) {
                    canvas.classList.add('study-mode');
                    canvas.style.cursor = 'pointer';
                }
                
                // ãƒœã‚¿ãƒ³ã‚’ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ
                disableButtons();
                
                // v14.00.9: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰é–‹å§‹å‰ã®ã‚·ãƒ¼ãƒˆçŠ¶æ…‹ã‚’ä¿å­˜
                savedRedSheetColors = { ...redSheetColors };
                
                // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã¯å…¨è‰²ã‚·ãƒ¼ãƒˆã‚’ONã«ã™ã‚‹
                redSheetColors.yellow = true;
                redSheetColors.red = true;
                redSheetColors.green = true;
                redSheetColors.blue = true;
                
                // ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
                ['yellow', 'red', 'green', 'blue'].forEach(color => {
                    const btn = document.getElementById('redsheet' + color.charAt(0).toUpperCase() + color.slice(1));
                    if (btn) {
                        btn.classList.add('active');
                    }
                });
                
                // v7.01: ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ã¨çµ±è¨ˆãƒ‘ãƒãƒ«ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                startStudyTimer();
                if (statsPanel) {
                    statsPanel.classList.remove('inactive');
                }
                updateStudyStats();
                
                // v9.00: ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»ã‚’è¨˜éŒ²
                currentSessionStartTime = Date.now();
                sessionCorrectCount = 0;
                sessionIncorrectCount = 0;
                sessionStudiedMarkers = new Set();
                
            } else {
                // å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰OFF
                btn.textContent = 'å­¦ç¿’OFF';
                btn.className = 'btn btn-mode-off';
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚«ãƒ¼ã‚½ãƒ«ã‚’å…ƒã«æˆ»ã™
                if (canvas) {
                    canvas.classList.remove('study-mode');
                    canvas.style.cursor = 'default';
                }
                
                // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                enableButtons();
                
                // v14.00.9: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰é–‹å§‹å‰ã®ã‚·ãƒ¼ãƒˆçŠ¶æ…‹ã‚’å¾©å…ƒ
                if (savedRedSheetColors) {
                    redSheetColors = { ...savedRedSheetColors };
                    
                    // ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’å¾©å…ƒ
                    ['yellow', 'red', 'green', 'blue'].forEach(color => {
                        const btn = document.getElementById('redsheet' + color.charAt(0).toUpperCase() + color.slice(1));
                        if (btn) {
                            if (redSheetColors[color]) {
                                btn.classList.add('active');
                            } else {
                                btn.classList.remove('active');
                            }
                        }
                    });
                }
                
                // v7.01: ã‚¿ã‚¤ãƒãƒ¼ä¸€æ™‚åœæ­¢ã¨çµ±è¨ˆãƒ‘ãƒãƒ«ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                pauseStudyTimer();
                if (statsPanel) {
                    statsPanel.classList.add('inactive');
                }
                
                // v7.02: å­¦ç¿’è¨˜éŒ²ã‚’ä¿å­˜
                await saveStudySessionToFirebase();
            }
            
            drawMarkers();
            
            // v15.01.0: å…¨ç”»é¢è¡¨ç¤ºã®åˆ‡ã‚Šæ›¿ãˆ
            updateFullscreenDisplay();
        }
        
        // v15.01.0: å…¨ç”»é¢è¡¨ç¤ºã®è¨­å®šã‚’ä¿å­˜
        function saveFullscreenSetting() {
            const checkbox = document.getElementById('fullscreenCheckbox');
            localStorage.setItem('fullscreenMode', checkbox.checked);
            
            // å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ä¸­ã®å ´åˆã¯å³åº§ã«åæ˜ 
            if (studyMode) {
                updateFullscreenDisplay();
            }
        }
        
        // v15.01.0: å…¨ç”»é¢è¡¨ç¤ºã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
        function loadFullscreenSetting() {
            const saved = localStorage.getItem('fullscreenMode');
            const checkbox = document.getElementById('fullscreenCheckbox');
            if (checkbox && saved !== null) {
                checkbox.checked = saved === 'true';
            }
        }
        
        // v15.01.0: å…¨ç”»é¢è¡¨ç¤ºã®æ›´æ–°
        // v15.01.1: å…¨ç”»é¢è¡¨ç¤ºã®æ›´æ–°ï¼ˆä¿®æ­£ç‰ˆï¼‰
        function updateFullscreenDisplay() {
            const checkbox = document.getElementById('fullscreenCheckbox');
            const fullscreenEnabled = checkbox && checkbox.checked;
            
            if (studyMode && fullscreenEnabled) {
                // å…¨ç”»é¢è¡¨ç¤ºON
                fullscreenMode = true;
                
                // v15.01.3: bodyã®èƒŒæ™¯è‰²ã‚’å¤‰æ›´ï¼ˆä¸‹ã®ç´«è‰²ã‚’æ¶ˆã™ï¼‰
                document.body.style.background = '#333';
                
                // é€šå¸¸ã®UIè¦ç´ ã‚’éè¡¨ç¤º
                const container = document.querySelector('.container');
                const tabs = document.querySelector('.tabs');
                const pdfHeader = document.querySelector('.pdf-header');
                const studyStats = document.getElementById('studyStats');
                const h1 = document.querySelector('h1');
                const syncStatus = document.getElementById('syncStatus');
                
                // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’éè¡¨ç¤ºï¼ˆPDF sectionä»¥å¤–ï¼‰
                const sections = ['home-section', 'study-section', 'cards-section', 'stats-section', 'settings-section'];
                sections.forEach(id => {
                    const section = document.getElementById(id);
                    if (section) section.style.display = 'none';
                });
                
                if (tabs) tabs.style.display = 'none';
                if (pdfHeader) pdfHeader.style.display = 'none';
                if (studyStats) studyStats.style.display = 'none';
                if (h1) h1.style.display = 'none';
                if (syncStatus) syncStatus.style.display = 'none';
                
                const pdfControls = document.querySelectorAll('.pdf-controls-row');
                pdfControls.forEach(el => el.style.display = 'none');
                
                const pdfControlsBottom = document.querySelector('.pdf-controls');
                if (pdfControlsBottom) pdfControlsBottom.style.display = 'none';
                
                // PDF canvas containerã®ã¿è¡¨ç¤ºï¼ˆå…¨ç”»é¢ï¼‰
                const canvasContainer = document.querySelector('.pdf-canvas-container');
                if (canvasContainer) {
                    canvasContainer.style.position = 'fixed';
                    canvasContainer.style.top = '70px';  // v15.01.8: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®é«˜ã•åˆ†ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                    canvasContainer.style.left = '0';
                    canvasContainer.style.right = '0';
                    canvasContainer.style.bottom = '0';
                    canvasContainer.style.width = '100%';
                    canvasContainer.style.height = 'calc(100vh - 70px)';  // v15.01.8: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®é«˜ã•ã‚’é™¤ã
                    canvasContainer.style.maxHeight = 'none';  // v15.01.9: max-height: 70vhã‚’è§£é™¤
                    canvasContainer.style.padding = '0';  // v15.01.9: paddingã‚’é™¤å»
                    canvasContainer.style.margin = '0';  // v15.01.9: marginã‚’é™¤å»
                    canvasContainer.style.zIndex = '1000';
                    canvasContainer.style.background = '#333';
                    canvasContainer.style.overflow = 'hidden';  // v15.01.6: ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤º
                }
                
                // v15.01.9: canvas-wrapperã®padding/marginã‚‚é™¤å»
                const canvasWrapper = document.getElementById('canvasWrapper');
                if (canvasWrapper) {
                    canvasWrapper.style.height = '100%';
                    canvasWrapper.style.padding = '0';
                    canvasWrapper.style.margin = '0';
                }
                
                // å…¨ç”»é¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¡¨ç¤ºï¼ˆå…ˆã«è¡¨ç¤ºã—ã¦é«˜ã•ã‚’å–å¾—ï¼‰
                const fullscreenControls = document.getElementById('fullscreenControls');
                if (fullscreenControls) {
                    fullscreenControls.style.display = 'block';
                    fullscreenControls.style.zIndex = '2001';  // v15.01.2: canvas containerã‚ˆã‚Šä¸Šã«
                }
                
                // v15.01.8: å…¨ç”»é¢ç”¨ã«scaleã‚’èª¿æ•´ã—ã¦PDFã‚’å†æç”»ï¼ˆé«˜ã•åŸºæº–ï¼‰
                savedScaleBeforeFullscreen = scale;
                
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
                const controlBarHeight = fullscreenControls ? fullscreenControls.offsetHeight : 70;
                const availableHeight = window.innerHeight - controlBarHeight;
                const availableWidth = window.innerWidth;
                
                console.log('=== v15.01.9 Fullscreen Debug ===');
                console.log('window.innerHeight:', window.innerHeight);
                console.log('window.innerWidth:', window.innerWidth);
                console.log('controlBarHeight:', controlBarHeight);
                console.log('availableHeight:', availableHeight);
                console.log('availableWidth:', availableWidth);
                console.log('savedScaleBeforeFullscreen:', savedScaleBeforeFullscreen);
                
                // v15.01.9: è¨­å®šå¾Œã®canvas containerã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’ç¢ºèª
                if (canvasContainer) {
                    console.log('canvasContainer actual height:', canvasContainer.offsetHeight);
                    console.log('canvasContainer actual width:', canvasContainer.offsetWidth);
                }
                
                if (pdfDoc && currentPage > 0) {
                    pdfDoc.getPage(currentPage).then(page => {
                        const viewport = page.getViewport({ scale: 1 });
                        console.log('PDF viewport (scale=1):', viewport.width, 'x', viewport.height);
                        
                        // v15.01.9: é«˜ã•åŸºæº–ã§99%ï¼ˆç”»é¢ã„ã£ã±ã„ã«è¡¨ç¤ºï¼‰
                        scale = (availableHeight / viewport.height) * 0.99;
                        console.log('calculated scale (height-based 99%):', scale);
                        
                        renderPage(currentPage);
                        console.log('renderPage called with scale:', scale);
                    });
                }
                
                // ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’åŒæœŸ
                ['yellow', 'red', 'green', 'blue'].forEach(color => {
                    const fullscreenBtn = document.getElementById('fullscreenSheet' + color.charAt(0).toUpperCase() + color.slice(1));
                    if (fullscreenBtn) {
                        if (redSheetColors[color]) {
                            fullscreenBtn.classList.add('active');
                        } else {
                            fullscreenBtn.classList.remove('active');
                        }
                    }
                });
                
                // ãƒšãƒ¼ã‚¸æƒ…å ±ã‚’åŒæœŸ
                const fullscreenPageInfo = document.getElementById('fullscreenPageInfo');
                if (fullscreenPageInfo) {
                    fullscreenPageInfo.textContent = `${currentPage} / ${totalPages}`;
                }
                
            } else {
                // å…¨ç”»é¢è¡¨ç¤ºOFFï¼ˆé€šå¸¸è¡¨ç¤ºï¼‰
                fullscreenMode = false;
                
                // v15.01.3: bodyã®èƒŒæ™¯è‰²ã‚’å…ƒã«æˆ»ã™
                document.body.style.background = '';
                
                // é€šå¸¸ã®UIè¦ç´ ã‚’è¡¨ç¤º
                const tabs = document.querySelector('.tabs');
                const pdfHeader = document.querySelector('.pdf-header');
                const studyStats = document.getElementById('studyStats');
                const h1 = document.querySelector('h1');
                const syncStatus = document.getElementById('syncStatus');
                
                // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤ºçŠ¶æ…‹ã«æˆ»ã™ï¼ˆactiveãªã‚‚ã®ã®ã¿è¡¨ç¤ºã•ã‚Œã‚‹ï¼‰
                const sections = ['home-section', 'study-section', 'cards-section', 'stats-section', 'settings-section'];
                sections.forEach(id => {
                    const section = document.getElementById(id);
                    if (section) section.style.display = '';
                });
                
                if (tabs) tabs.style.display = '';
                if (pdfHeader) pdfHeader.style.display = '';
                if (h1) h1.style.display = '';
                if (syncStatus) syncStatus.style.display = '';
                
                // v15.01.12: å­¦ç¿’çµ±è¨ˆã‚’å¸¸ã«è¡¨ç¤ºï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã«é–¢ä¿‚ãªãï¼‰
                if (studyStats) {
                    studyStats.style.display = 'flex';
                    console.log('=== v15.01.12 Study Stats Restored ===');
                    console.log('studyStats.style.display set to: flex');
                }
                
                const pdfControls = document.querySelectorAll('.pdf-controls-row');
                pdfControls.forEach(el => el.style.display = '');
                
                const pdfControlsBottom = document.querySelector('.pdf-controls');
                if (pdfControlsBottom) pdfControlsBottom.style.display = '';
                
                // PDF canvas containerã‚’å…ƒã«æˆ»ã™
                const canvasContainer = document.querySelector('.pdf-canvas-container');
                if (canvasContainer) {
                    canvasContainer.style.position = '';
                    canvasContainer.style.top = '';
                    canvasContainer.style.left = '';
                    canvasContainer.style.right = '';
                    canvasContainer.style.bottom = '';
                    canvasContainer.style.width = '';
                    canvasContainer.style.height = '';
                    canvasContainer.style.maxHeight = '';  // v15.01.9: maxHeightã‚‚ãƒªã‚»ãƒƒãƒˆ
                    canvasContainer.style.padding = '';  // v15.01.9: paddingã‚‚ãƒªã‚»ãƒƒãƒˆ
                    canvasContainer.style.margin = '';  // v15.01.9: marginã‚‚ãƒªã‚»ãƒƒãƒˆ
                    canvasContainer.style.zIndex = '';
                    canvasContainer.style.background = '';
                    canvasContainer.style.overflow = '';  // v15.01.6: overflowã‚‚ãƒªã‚»ãƒƒãƒˆ
                }
                
                // v15.01.9: canvas-wrapperã‚‚ãƒªã‚»ãƒƒãƒˆ
                const canvasWrapper = document.getElementById('canvasWrapper');
                if (canvasWrapper) {
                    canvasWrapper.style.height = '';
                    canvasWrapper.style.padding = '';
                    canvasWrapper.style.margin = '';
                }
                
                // v15.01.9: scaleã‚’å…ƒã«æˆ»ã—ã¦PDFã‚’å†æç”»ï¼ˆãƒ‡ãƒãƒƒã‚°æƒ…å ±ä»˜ãï¼‰
                if (savedScaleBeforeFullscreen !== null) {
                    console.log('=== v15.01.9 Fullscreen OFF Debug ===');
                    console.log('Restoring scale from:', scale, 'to:', savedScaleBeforeFullscreen);
                    scale = savedScaleBeforeFullscreen;
                    savedScaleBeforeFullscreen = null;
                    renderPage(currentPage);
                    console.log('renderPage called with restored scale:', scale);
                }
                
                // å…¨ç”»é¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤º
                const fullscreenControls = document.getElementById('fullscreenControls');
                if (fullscreenControls) {
                    fullscreenControls.style.display = 'none';
                    fullscreenControls.style.zIndex = '';  // v15.01.2: zIndexã‚‚ãƒªã‚»ãƒƒãƒˆ
                }
            }
        }
        
        // v7.00.2: ãƒœã‚¿ãƒ³ã‚’ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆï¼ˆã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚‚è¿½åŠ ï¼‰
        function disableButtons() {
            // ãƒãƒ¼ã‚«ãƒ¼è‰²é¸æŠãƒœã‚¿ãƒ³
            ['markerYellow', 'markerRed', 'markerGreen', 'markerBlue'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.add('disabled');
                    btn.style.pointerEvents = 'none';
                }
            });
            
            // ãƒãƒ¼ã‚«ãƒ¼ON/OFFãƒœã‚¿ãƒ³
            const markerModeBtn = document.getElementById('markerModeBtn');
            if (markerModeBtn) {
                markerModeBtn.classList.add('btn-disabled');
                markerModeBtn.style.pointerEvents = 'none';
            }
            
            // ä¿®æ­£ãƒœã‚¿ãƒ³
            const editModeBtn = document.getElementById('editModeBtn');
            if (editModeBtn) {
                editModeBtn.classList.add('btn-disabled');
                editModeBtn.style.pointerEvents = 'none';
            }
            
            // å‰Šé™¤ãƒœã‚¿ãƒ³
            const deleteModeBtn = document.getElementById('deleteModeBtn');
            if (deleteModeBtn) {
                deleteModeBtn.classList.add('btn-disabled');
                deleteModeBtn.style.pointerEvents = 'none';
            }
            
            // v7.01: ãƒšãƒ¼ã‚¸å†…å…¨å‰Šé™¤ãƒœã‚¿ãƒ³ã¨PDFå†…å…¨å‰Šé™¤ãƒœã‚¿ãƒ³
            const clearPageMarkersBtn = document.getElementById('clearPageMarkersBtn');
            if (clearPageMarkersBtn) {
                clearPageMarkersBtn.classList.add('btn-disabled');
                clearPageMarkersBtn.style.pointerEvents = 'none';
            }
            
            const clearAllMarkersBtn = document.getElementById('clearAllMarkersBtn');
            if (clearAllMarkersBtn) {
                clearAllMarkersBtn.classList.add('btn-disabled');
                clearAllMarkersBtn.style.pointerEvents = 'none';
            }
            
            // v7.03: ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã¯å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ã‚‚æœ‰åŠ¹ï¼ˆã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã—ãªã„ï¼‰
        }
        
        // v7.00.2: ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–ï¼ˆã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚‚è¿½åŠ ï¼‰
        function enableButtons() {
            // ãƒãƒ¼ã‚«ãƒ¼è‰²é¸æŠãƒœã‚¿ãƒ³
            ['markerYellow', 'markerRed', 'markerGreen', 'markerBlue'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.classList.remove('disabled');
                    btn.style.pointerEvents = '';
                }
            });
            
            // ãƒãƒ¼ã‚«ãƒ¼ON/OFFãƒœã‚¿ãƒ³
            const markerModeBtn = document.getElementById('markerModeBtn');
            if (markerModeBtn) {
                markerModeBtn.classList.remove('btn-disabled');
                markerModeBtn.style.pointerEvents = '';
            }
            
            // ä¿®æ­£ãƒœã‚¿ãƒ³
            const editModeBtn = document.getElementById('editModeBtn');
            if (editModeBtn) {
                editModeBtn.classList.remove('btn-disabled');
                editModeBtn.style.pointerEvents = '';
            }
            
            // å‰Šé™¤ãƒœã‚¿ãƒ³
            const deleteModeBtn = document.getElementById('deleteModeBtn');
            if (deleteModeBtn) {
                deleteModeBtn.classList.remove('btn-disabled');
                deleteModeBtn.style.pointerEvents = '';
            }
            
            // v7.01: ãƒšãƒ¼ã‚¸å†…å…¨å‰Šé™¤ãƒœã‚¿ãƒ³ã¨PDFå†…å…¨å‰Šé™¤ãƒœã‚¿ãƒ³
            const clearPageMarkersBtn = document.getElementById('clearPageMarkersBtn');
            if (clearPageMarkersBtn) {
                clearPageMarkersBtn.classList.remove('btn-disabled');
                clearPageMarkersBtn.style.pointerEvents = '';
            }
            
            const clearAllMarkersBtn = document.getElementById('clearAllMarkersBtn');
            if (clearAllMarkersBtn) {
                clearAllMarkersBtn.classList.remove('btn-disabled');
                clearAllMarkersBtn.style.pointerEvents = '';
            }
            
            // v7.03: ã‚·ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã¯å¸¸ã«æœ‰åŠ¹ï¼ˆå­¦ç¿’ãƒ¢ãƒ¼ãƒ‰é–¢ä¿‚ãªã—ï¼‰
        }
        
        function loadInstantDeleteSetting() {
            const saved = localStorage.getItem('instantDeleteMode');
            instantDeleteMode = saved === 'true';
            const checkbox = document.getElementById('instantDeleteCheckbox');
            if (checkbox) {
                checkbox.checked = instantDeleteMode;
            }
        }
        
        function saveInstantDeleteSetting() {
            const checkbox = document.getElementById('instantDeleteCheckbox');
            instantDeleteMode = checkbox.checked;
            localStorage.setItem('instantDeleteMode', instantDeleteMode);
        }

        function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MyAnkiAppDB', 1);
                
                request.onerror = () => {
                    console.error('IndexedDB open error');
                    useFileSystemAPI = false;
                    resolve();
                };
                
                request.onsuccess = (event) => {
                    pdfDB = event.target.result;
                    useFileSystemAPI = true;
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                };
            });
        }

        function setupMarkerEvents(canvas) {
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ã‚«ãƒ¼ã‚½ãƒ«ã‚’å¤‰æ›´
            if (studyMode) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = markerMode ? 'crosshair' : 'default';
            }
            
            canvas.addEventListener('mousedown', handleMarkerMouseDown);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        }
        
        function handleMarkerMouseDown(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒãƒ¼ã‚«ãƒ¼ãƒˆã‚°ãƒ«
            if (studyMode) {
                toggleMarkerState(x, y);
                return;
            }
            
            if (deleteMode) {
                deleteMarkerAt(x, y);
                return;
            }
            
            if (editMode && selectedMarkerIndex !== null) {
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                const scaleRatio = scale / marker.scale;
                const handle = detectHandle(x, y, marker, scaleRatio);
                
                if (handle) {
                    resizingHandle = handle;
                    dragStartX = x;
                    dragStartY = y;
                    return;
                }
                
                // v15.01.14: å››ã¤è§’ä»¥å¤–ã®ãƒãƒ¼ã‚«ãƒ¼å†…ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ç§»å‹•ãƒ¢ãƒ¼ãƒ‰
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    movingMarker = true;
                    dragStartX = x;
                    dragStartY = y;
                    return;
                }
            }
            
            // v7.02.1: ä¿®æ­£ãƒ¢ãƒ¼ãƒ‰æ™‚ã«Shift+ã‚¯ãƒªãƒƒã‚¯ã§è‰²å¤‰æ›´
            if (editMode && e.shiftKey) {
                changeMarkerColorAt(x, y);
                return;
            }
            
            if (editMode) {
                selectMarkerAt(x, y);
                return;
            }
            
            const anyRedSheetActive = redSheetColors.yellow || redSheetColors.red || 
                                     redSheetColors.green || redSheetColors.blue;
            if (anyRedSheetActive) {
                // v7.00.2: ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒãƒ¼ã‚«ãƒ¼ã‚’æ¤œç´¢ã—ã¦ãƒˆã‚°ãƒ«
                const clickedMarkerIndex = getClickedMarkerIndex(x, y);
                if (clickedMarkerIndex !== -1) {
                    const toggleKey = `${currentPage}-${clickedMarkerIndex}`;
                    // çŠ¶æ…‹ã‚’ãƒˆã‚°ãƒ«ï¼ˆæœªå®šç¾©ãªã‚‰falseã€å­˜åœ¨ã™ã‚‹ãªã‚‰åè»¢ï¼‰
                    sheetClickToggles[toggleKey] = !sheetClickToggles[toggleKey];
                    drawMarkers();
                    return;
                }
            }
            
            startDrawing(e);
        }
        
        // v7.00: ãƒãƒ¼ã‚«ãƒ¼çŠ¶æ…‹ãƒˆã‚°ãƒ«ï¼ˆæš—è»¢â†’æ˜è»¢â†’æ­£ç­”â†’èª¤ç­”â†’æš—è»¢ï¼‰
        function toggleMarkerState(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return;
            
            const pageMarkers = markers[pdfHash][currentPage];
            
            for (let i = pageMarkers.length - 1; i >= 0; i--) {
                const marker = pageMarkers[i];
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    // v7.03: ã‚·ãƒ¼ãƒˆOFFã®è‰²ã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚‚åå¿œã—ãªã„ï¼ˆå­¦ç¿’å¯¾è±¡å¤–ï¼‰
                    if (!redSheetColors[marker.color]) {
                        return;  // ã‚·ãƒ¼ãƒˆOFFã®è‰²ã¯ä½•ã‚‚ã—ãªã„
                    }
                    
                    // v9.00: Ctrl+ã‚¯ãƒªãƒƒã‚¯ã§çµ±è¨ˆè¡¨ç¤º
                    if (event.ctrlKey || event.metaKey) {
                        showMarkerStatsTooltip(marker, mx, my, mw, mh);
                        return;
                    }
                    
                    // v9.00: å¾©ç¿’ãƒªã‚»ãƒƒãƒˆå¾Œã®æ­£ç­”ãƒãƒ¼ã‚«ãƒ¼ï¼ˆlockedï¼‰ã®æ‰±ã„
                    if (marker.studyState === 'correct' && marker.locked) {
                        // Shift+ã‚¯ãƒªãƒƒã‚¯ã§æš—è»¢ã«æˆ»ã™ï¼ˆå­¦ç¿’å¯¾è±¡ã«å¾©å¸°ï¼‰
                        if (event.shiftKey) {
                            marker.studyState = 'hidden';
                            delete marker.locked;  // ãƒ­ãƒƒã‚¯è§£é™¤
                            drawMarkers();
                            saveMarkersToFirebase();
                            updateStudyStats();
                            return;
                        }
                        // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯ã¯åå¿œã—ãªã„ï¼ˆå­¦ç¿’å¯¾è±¡å¤–ï¼‰
                        return;
                    }
                    
                    // v7.03: ãƒˆã‚°ãƒ«ã‚µã‚¤ã‚¯ãƒ«: æš—è»¢(åˆæœŸ) â†’ æ˜è»¢(æ ãªã—) â†’ æ­£ç­”(ç·‘æ ) â†’ èª¤ç­”(èµ¤æ ) â†’ æš—è»¢
                    if (!marker.studyState || marker.studyState === 'hidden') {
                        marker.studyState = 'visible';  // æš—è»¢ â†’ æ˜è»¢ï¼ˆæ ãªã—ã€è§£ç­”ç¢ºèªç”¨ï¼‰
                    } else if (marker.studyState === 'visible') {
                        marker.studyState = 'correct';  // æ˜è»¢ â†’ æ­£ç­”ï¼ˆæ˜è»¢+ç·‘æ ï¼‰
                        // v9.00: ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°ã¯å‘¨å›çµ‚äº†æ™‚ã«ç§»å‹•ï¼ˆã“ã“ã§ã¯æ›´æ–°ã—ãªã„ï¼‰
                    } else if (marker.studyState === 'correct') {
                        marker.studyState = 'incorrect';  // æ­£ç­” â†’ èª¤ç­”ï¼ˆæ˜è»¢+èµ¤æ ï¼‰
                        // v9.00: ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°ã¯å‘¨å›çµ‚äº†æ™‚ã«ç§»å‹•ï¼ˆã“ã“ã§ã¯æ›´æ–°ã—ãªã„ï¼‰
                    } else if (marker.studyState === 'incorrect') {
                        marker.studyState = 'hidden';  // èª¤ç­” â†’ æš—è»¢
                    }
                    
                    drawMarkers();
                    saveMarkersToFirebase();
                    // v7.01: çµ±è¨ˆã‚’æ›´æ–°
                    updateStudyStats();
                    return;
                }
            }
        }
        
        // v9.00: ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤º
        function showMarkerStatsTooltip(marker, mx, my, mw, mh) {
            // æ—¢å­˜ã®ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’å‰Šé™¤
            hideMarkerStatsTooltip();
            
            const correctCount = marker.correctCount || 0;
            const incorrectCount = marker.incorrectCount || 0;
            const totalCount = correctCount + incorrectCount;
            const accuracyRate = totalCount > 0 ? Math.round((correctCount / totalCount) * 100) : 0;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®çµ¶å¯¾åº§æ¨™ã‚’å–å¾—
            const canvas = document.getElementById('markerCanvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¦ç´ ã‚’ä½œæˆ
            const tooltip = document.createElement('div');
            tooltip.id = 'markerStatsTooltip';
            tooltip.style.cssText = `
                position: fixed;
                left: ${canvasRect.left + mx}px;
                top: ${canvasRect.top + my - 90}px;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-size: 13px;
                line-height: 1.6;
                z-index: 10000;
                pointer-events: none;
                white-space: nowrap;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            
            tooltip.innerHTML = `
                <div style="border-bottom: 1px solid rgba(255,255,255,0.3); margin-bottom: 6px; padding-bottom: 4px; font-weight: bold;">ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆ</div>
                <div>âœ… æ­£ç­”: ${correctCount}å›</div>
                <div>âŒ èª¤ç­”: ${incorrectCount}å›</div>
                <div>ğŸ“Š åˆè¨ˆ: ${totalCount}å›</div>
                <div>ğŸ“ˆ æ­£ç­”ç‡: ${accuracyRate}%</div>
            `;
            
            document.body.appendChild(tooltip);
            
            // 3ç§’å¾Œã«è‡ªå‹•çš„ã«æ¶ˆã™
            setTimeout(hideMarkerStatsTooltip, 3000);
        }
        
        function hideMarkerStatsTooltip() {
            const tooltip = document.getElementById('markerStatsTooltip');
            if (tooltip) {
                tooltip.remove();
            }
        }
        
        // v7.02.1: ãƒãƒ¼ã‚«ãƒ¼ã®è‰²ã‚’å¤‰æ›´ï¼ˆé»„â†’èµ¤â†’ç·‘â†’é’â†’é»„ï¼‰
        function changeMarkerColorAt(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return;
            
            const pageMarkers = markers[pdfHash][currentPage];
            const colorCycle = ['yellow', 'red', 'green', 'blue'];
            
            for (let i = pageMarkers.length - 1; i >= 0; i--) {
                const marker = pageMarkers[i];
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    // ç¾åœ¨ã®è‰²ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
                    const currentIndex = colorCycle.indexOf(marker.color);
                    // æ¬¡ã®è‰²ã«å¤‰æ›´ï¼ˆå¾ªç’°ï¼‰
                    const nextIndex = (currentIndex + 1) % colorCycle.length;
                    marker.color = colorCycle[nextIndex];
                    
                    drawMarkers();
                    saveMarkersToFirebase();
                    return;
                }
            }
        }
        
        function detectHandle(x, y, marker, scaleRatio) {
            const mx = marker.x * scaleRatio;
            const my = marker.y * scaleRatio;
            const mw = marker.width * scaleRatio;
            const mh = marker.height * scaleRatio;
            
            const handleSize = 10;
            
            const handles = {
                nw: { x: mx, y: my },
                ne: { x: mx + mw, y: my },
                sw: { x: mx, y: my + mh },
                se: { x: mx + mw, y: my + mh }
            };
            
            for (const [name, pos] of Object.entries(handles)) {
                if (Math.abs(x - pos.x) <= handleSize && Math.abs(y - pos.y) <= handleSize) {
                    return name;
                }
            }
            
            return null;
        }

        function selectMarkerAt(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) {
                selectedMarkerIndex = null;
                return;
            }
            
            const pageMarkers = markers[pdfHash][currentPage];
            
            for (let i = pageMarkers.length - 1; i >= 0; i--) {
                const marker = pageMarkers[i];
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    selectedMarkerIndex = i;
                    selectedMarkerPage = currentPage;
                    drawMarkers();
                    return;
                }
            }
            
            selectedMarkerIndex = null;
            drawMarkers();
        }
        
        function deleteMarkerAt(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return;
            
            const pageMarkers = markers[pdfHash][currentPage];
            
            for (let i = pageMarkers.length - 1; i >= 0; i--) {
                const marker = pageMarkers[i];
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    if (instantDeleteMode || confirm('ã“ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                        pageMarkers.splice(i, 1);
                        drawMarkers();
                        saveMarkersToFirebase();
                    }
                    return;
                }
            }
        }
        
        function isClickOnMarker(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return false;
            
            return markers[pdfHash][currentPage].some(marker => {
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                return x >= mx && x <= mx + mw && y >= my && y <= my + mh;
            });
        }
        
        // v7.00.2: ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
        function getClickedMarkerIndex(x, y) {
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return -1;
            
            const pageMarkers = markers[pdfHash][currentPage];
            for (let i = pageMarkers.length - 1; i >= 0; i--) {
                const marker = pageMarkers[i];
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    return i;
                }
            }
            return -1;
        }
        
        function startDrawing(e) {
            if (!markerMode) return;
            isDrawing = true;
            const rect = e.target.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
        }
        
        function draw(e) {
            const canvas = document.getElementById('markerCanvas');
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            // v15.01.14: ç·¨é›†ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«å½¢çŠ¶å¤‰æ›´
            if (editMode && selectedMarkerIndex !== null && !resizingHandle && !movingMarker) {
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                const scaleRatio = scale / marker.scale;
                const handle = detectHandle(currentX, currentY, marker, scaleRatio);
                
                if (handle) {
                    // å››ã¤è§’ï¼šãƒªã‚µã‚¤ã‚ºã‚«ãƒ¼ã‚½ãƒ«
                    switch (handle) {
                        case 'nw':
                            canvas.style.cursor = 'nw-resize';
                            break;
                        case 'ne':
                            canvas.style.cursor = 'ne-resize';
                            break;
                        case 'sw':
                            canvas.style.cursor = 'sw-resize';
                            break;
                        case 'se':
                            canvas.style.cursor = 'se-resize';
                            break;
                    }
                } else {
                    // ãƒãƒ¼ã‚«ãƒ¼å†…ã‹ãƒã‚§ãƒƒã‚¯
                    const mx = marker.x * scaleRatio;
                    const my = marker.y * scaleRatio;
                    const mw = marker.width * scaleRatio;
                    const mh = marker.height * scaleRatio;
                    
                    if (currentX >= mx && currentX <= mx + mw && currentY >= my && currentY <= my + mh) {
                        canvas.style.cursor = 'move';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            }
            
            if (resizingHandle && selectedMarkerIndex !== null) {
                e.preventDefault();
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                
                switch (resizingHandle) {
                    case 'nw':
                        marker.x += deltaX;
                        marker.y += deltaY;
                        marker.width -= deltaX;
                        marker.height -= deltaY;
                        break;
                    case 'ne':
                        marker.y += deltaY;
                        marker.width += deltaX;
                        marker.height -= deltaY;
                        break;
                    case 'sw':
                        marker.x += deltaX;
                        marker.width -= deltaX;
                        marker.height += deltaY;
                        break;
                    case 'se':
                        marker.width += deltaX;
                        marker.height += deltaY;
                        break;
                }
                
                if (marker.width < 10) marker.width = 10;
                if (marker.height < 10) marker.height = 10;
                
                dragStartX = currentX;
                dragStartY = currentY;
                
                drawMarkers();
                return;
            }
            
            // v15.01.14: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•å‡¦ç†
            if (movingMarker && selectedMarkerIndex !== null) {
                e.preventDefault();
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                
                // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                let newX = marker.x + deltaX;
                let newY = marker.y + deltaY;
                
                // Canvasç¯„å›²å†…ã«åˆ¶é™
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                if (newX < 0) newX = 0;
                if (newY < 0) newY = 0;
                if (newX + marker.width > canvasWidth) newX = canvasWidth - marker.width;
                if (newY + marker.height > canvasHeight) newY = canvasHeight - marker.height;
                
                marker.x = newX;
                marker.y = newY;
                
                dragStartX = currentX;
                dragStartY = currentY;
                
                drawMarkers();
                return;
            }
            
            if (!isDrawing || !markerMode) return;
            e.preventDefault();
            
            drawMarkers();
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getMarkerColor(currentMarkerColor);
            
            // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
            if (fixHeightMode && lastMarkerHeight > 0) {
                // é«˜ã•å›ºå®šï¼šYåº§æ¨™ã¯é–‹å§‹ä½ç½®ã‹ã‚‰å›ºå®šé«˜ã•ã€Xåº§æ¨™ã®ã¿å¤‰åŒ–
                ctx.fillRect(Math.min(startX, currentX), startY, 
                            Math.abs(currentX - startX), lastMarkerHeight);
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šè‡ªç”±ã«æç”»
                ctx.fillRect(Math.min(startX, currentX), Math.min(startY, currentY), 
                            Math.abs(currentX - startX), Math.abs(currentY - startY));
            }
        }
        
        function stopDrawing(e) {
            if (resizingHandle) {
                resizingHandle = null;
                saveMarkersToFirebase();
                return;
            }
            
            // v15.01.14: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•çµ‚äº†å‡¦ç†
            if (movingMarker) {
                movingMarker = false;
                saveMarkersToFirebase();
                return;
            }
            
            if (isDraggingMarker) {
                isDraggingMarker = false;
                saveMarkersToFirebase();
                return;
            }
            
            if (!isDrawing || !markerMode) return;
            isDrawing = false;
            
            const canvas = document.getElementById('markerCanvas');
            const rect = canvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            
            // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
            let markerY, markerHeight;
            if (fixHeightMode && lastMarkerHeight > 0) {
                // é«˜ã•å›ºå®šï¼šé–‹å§‹ä½ç½®ã‹ã‚‰å›ºå®šé«˜ã•
                markerY = startY;
                markerHeight = lastMarkerHeight;
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šè‡ªç”±ãªé«˜ã•
                markerY = Math.min(startY, endY);
                markerHeight = Math.abs(endY - startY);
            }
            
            const marker = {
                x: Math.min(startX, endX),
                y: markerY,
                width: Math.abs(endX - startX),
                height: markerHeight,
                color: currentMarkerColor,
                scale: scale,
                // v7.00.2: studyStateã¯è¨­å®šã—ãªã„ï¼ˆundefined = å­¦ç¿’ONæ™‚ã¯æš—è»¢ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆï¼‰
                // v9.00: ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆæƒ…å ±
                correctCount: 0,
                incorrectCount: 0,
                lastStudied: null
            };
            
            if (marker.width > 5 && marker.height > 5) {
                // v15.01.13: é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã§ãƒãƒ¼ã‚«ãƒ¼ã‚’ä½œæˆã—ãŸå ´åˆã€æ¬¡å›ã®é«˜ã•å›ºå®šç”¨ã«é«˜ã•ã‚’è¨˜æ†¶
                if (!fixHeightMode) {
                    lastMarkerHeight = marker.height;
                }
                saveMarker(marker);
                drawMarkers();
            }
        }
        
        function handleTouchStart(e) {
            // v15.00.2: 2æœ¬æŒ‡ã®å ´åˆã¯ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ  + ãƒ‘ãƒ³ï¼ˆæ’ä»–çš„ï¼‰
            if (e.touches.length === 2) {
                e.preventDefault();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // ãƒ”ãƒ³ãƒé–‹å§‹ï¼š2æœ¬æŒ‡ã®è·é›¢ã‚’è¨ˆç®—
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
                pinchStartScale = scale;
                isPinching = true;
                
                // ãƒ‘ãƒ³ç”¨ï¼š2æœ¬æŒ‡ã®ä¸­å¿ƒç‚¹ã‚’è¨˜éŒ²
                pinchCenterX = (touch1.clientX + touch2.clientX) / 2;
                pinchCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                // v15.00.2: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¤å®šã‚’åˆæœŸåŒ–
                gestureMode = null;
                gestureStartTime = Date.now();
                
                // ãƒãƒ¼ã‚«ãƒ¼æç”»ã‚’ä¸­æ–­
                if (isDrawing) {
                    isDrawing = false;
                }
                
                return;
            }
            
            const touch = e.touches[0];
            const rect = e.target.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            e.preventDefault();
            
            // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ãƒãƒ¼ã‚«ãƒ¼ãƒˆã‚°ãƒ«
            if (studyMode) {
                toggleMarkerState(x, y);
                return;
            }
            
            if (deleteMode) {
                deleteMarkerAt(x, y);
                return;
            }
            
            if (editMode && selectedMarkerIndex !== null) {
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                const scaleRatio = scale / marker.scale;
                const handle = detectHandle(x, y, marker, scaleRatio);
                
                if (handle) {
                    resizingHandle = handle;
                    dragStartX = x;
                    dragStartY = y;
                    return;
                }
                
                // v15.01.14: å››ã¤è§’ä»¥å¤–ã®ãƒãƒ¼ã‚«ãƒ¼å†…ã‚’ã‚¿ãƒƒãƒã—ãŸå ´åˆã¯ç§»å‹•ãƒ¢ãƒ¼ãƒ‰
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                if (x >= mx && x <= mx + mw && y >= my && y <= my + mh) {
                    movingMarker = true;
                    dragStartX = x;
                    dragStartY = y;
                    return;
                }
            }
            
            if (editMode) {
                selectMarkerAt(x, y);
                return;
            }
            
            const anyRedSheetActive = redSheetColors.yellow || redSheetColors.red || 
                                     redSheetColors.green || redSheetColors.blue;
            if (anyRedSheetActive) {
                if (isClickOnMarker(x, y)) {
                    // v7.00: 3ç§’ãƒ«ãƒ¼ãƒ«å»ƒæ­¢
                    return;
                }
            }
            
            if (!markerMode) return;
            isDrawing = true;
            startX = x;
            startY = y;
        }
        
        function handleTouchMove(e) {
            // v15.00.2: ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ  + ãƒ‘ãƒ³å‡¦ç†ï¼ˆæ’ä»–çš„ï¼‰
            if (isPinching && e.touches.length === 2) {
                e.preventDefault();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // ç¾åœ¨ã®2æœ¬æŒ‡ã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
                const currentCenterX = (touch1.clientX + touch2.clientX) / 2;
                const currentCenterY = (touch1.clientY + touch2.clientY) / 2;
                
                // ç¾åœ¨ã®2æœ¬æŒ‡ã®è·é›¢ã‚’è¨ˆç®—
                const dx = touch2.clientX - touch1.clientX;
                const dy = touch2.clientY - touch1.clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                // v15.00.2: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¤å®šï¼ˆæœ€åˆã®100mså†…ï¼‰
                if (gestureMode === null && Date.now() - gestureStartTime < gestureDecisionTime) {
                    // åˆ¤å®šæœŸé–“ä¸­ï¼šè·é›¢å¤‰åŒ–ã¨ä¸­å¿ƒç§»å‹•ã‚’è¦³å¯Ÿ
                    const distanceChange = Math.abs(currentDistance - pinchStartDistance);
                    
                    let centerMovement = 0;
                    if (typeof pinchCenterX !== 'undefined') {
                        const centerDx = currentCenterX - pinchCenterX;
                        const centerDy = currentCenterY - pinchCenterY;
                        centerMovement = Math.sqrt(centerDx * centerDx + centerDy * centerDy);
                    }
                    
                    // åˆ¤å®šé–¾å€¤ï¼šè·é›¢å¤‰åŒ–20pxä»¥ä¸Šã§ãƒ”ãƒ³ãƒã€ä¸­å¿ƒç§»å‹•10pxä»¥ä¸Šã§ãƒ‘ãƒ³
                    if (distanceChange > 20) {
                        gestureMode = 'pinch';
                    } else if (centerMovement > 10) {
                        gestureMode = 'pan';
                    }
                    // ã¾ã åˆ¤å®šã§ããªã„å ´åˆã¯nullã®ã¾ã¾ç¶™ç¶š
                    
                } else if (gestureMode === null) {
                    // åˆ¤å®šæœŸé–“çµ‚äº†ã§ã‚‚æ±ºã¾ã‚‰ãªã„ â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ‘ãƒ³
                    gestureMode = 'pan';
                }
                
                // ãƒ¢ãƒ¼ãƒ‰åˆ¥å‡¦ç†
                if (gestureMode === 'pinch') {
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã®ã¿
                    const scaleChange = currentDistance / pinchStartDistance;
                    let newScale = pinchStartScale * scaleChange;
                    
                    // ç¯„å›²åˆ¶é™ï¼ˆ0.5ã€œ3.0ï¼‰
                    if (newScale < 0.5) newScale = 0.5;
                    if (newScale > 3.0) newScale = 3.0;
                    
                    // æ‹¡å¤§ç‡ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã®ã¿å†æç”»
                    if (Math.abs(newScale - scale) > 0.01) {
                        scale = newScale;
                        renderPage(currentPage);
                    }
                    
                } else if (gestureMode === 'pan') {
                    // ãƒ‘ãƒ³ã®ã¿
                    if (typeof pinchCenterX !== 'undefined') {
                        const deltaX = currentCenterX - pinchCenterX;
                        const deltaY = currentCenterY - pinchCenterY;
                        offsetX += deltaX;
                        offsetY += deltaY;
                        updateCanvasPosition();
                    }
                    
                    // æ¬¡å›ã®è¨ˆç®—ã®ãŸã‚ã«ç¾åœ¨ã®ä¸­å¿ƒç‚¹ã‚’ä¿å­˜
                    pinchCenterX = currentCenterX;
                    pinchCenterY = currentCenterY;
                }
                
                return;
            }
            
            const touch = e.touches[0];
            const canvas = document.getElementById('markerCanvas');
            const rect = canvas.getBoundingClientRect();
            const currentX = touch.clientX - rect.left;
            const currentY = touch.clientY - rect.top;
            
            if (resizingHandle && selectedMarkerIndex !== null) {
                e.preventDefault();
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                
                switch (resizingHandle) {
                    case 'nw':
                        marker.x += deltaX;
                        marker.y += deltaY;
                        marker.width -= deltaX;
                        marker.height -= deltaY;
                        break;
                    case 'ne':
                        marker.y += deltaY;
                        marker.width += deltaX;
                        marker.height -= deltaY;
                        break;
                    case 'sw':
                        marker.x += deltaX;
                        marker.width -= deltaX;
                        marker.height += deltaY;
                        break;
                    case 'se':
                        marker.width += deltaX;
                        marker.height += deltaY;
                        break;
                }
                
                if (marker.width < 10) marker.width = 10;
                if (marker.height < 10) marker.height = 10;
                
                dragStartX = currentX;
                dragStartY = currentY;
                
                drawMarkers();
                return;
            }
            
            // v15.01.14: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•å‡¦ç†
            if (movingMarker && selectedMarkerIndex !== null) {
                e.preventDefault();
                const deltaX = currentX - dragStartX;
                const deltaY = currentY - dragStartY;
                
                const marker = markers[pdfHash][currentPage][selectedMarkerIndex];
                
                // æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
                let newX = marker.x + deltaX;
                let newY = marker.y + deltaY;
                
                // Canvasç¯„å›²å†…ã«åˆ¶é™
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                if (newX < 0) newX = 0;
                if (newY < 0) newY = 0;
                if (newX + marker.width > canvasWidth) newX = canvasWidth - marker.width;
                if (newY + marker.height > canvasHeight) newY = canvasHeight - marker.height;
                
                marker.x = newX;
                marker.y = newY;
                
                dragStartX = currentX;
                dragStartY = currentY;
                
                drawMarkers();
                return;
            }
            
            if (!isDrawing || !markerMode) return;
            e.preventDefault();
            
            drawMarkers();
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = getMarkerColor(currentMarkerColor);
            
            // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
            if (fixHeightMode && lastMarkerHeight > 0) {
                // é«˜ã•å›ºå®šï¼šYåº§æ¨™ã¯é–‹å§‹ä½ç½®ã‹ã‚‰å›ºå®šé«˜ã•ã€Xåº§æ¨™ã®ã¿å¤‰åŒ–
                ctx.fillRect(Math.min(startX, currentX), startY, 
                            Math.abs(currentX - startX), lastMarkerHeight);
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šè‡ªç”±ã«æç”»
                ctx.fillRect(Math.min(startX, currentX), Math.min(startY, currentY), 
                            Math.abs(currentX - startX), Math.abs(currentY - startY));
            }
        }
        
        function updateCanvasPosition() {
            const wrapper = document.getElementById('canvasWrapper');
            if (wrapper) {
                wrapper.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }
        }
        
        function handleTouchEnd(e) {
            // v15.00.2: ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ çµ‚äº†ï¼ˆãƒ‘ãƒ³ä½ç½®ã¯ç¶­æŒï¼‰
            if (isPinching) {
                isPinching = false;
                pinchStartDistance = 0;
                pinchStartScale = 1.0;
                pinchCenterX = undefined;
                pinchCenterY = undefined;
                gestureMode = null; // v15.00.2: ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
                return;
            }
            
            if (resizingHandle) {
                e.preventDefault();
                resizingHandle = null;
                saveMarkersToFirebase();
                return;
            }
            
            // v15.01.14: ãƒãƒ¼ã‚«ãƒ¼ç§»å‹•çµ‚äº†å‡¦ç†
            if (movingMarker) {
                movingMarker = false;
                saveMarkersToFirebase();
                return;
            }
            
            if (!isDrawing || !markerMode) return;
            e.preventDefault();
            isDrawing = false;
            
            const touch = e.changedTouches[0];
            const canvas = document.getElementById('markerCanvas');
            const rect = canvas.getBoundingClientRect();
            const endX = touch.clientX - rect.left;
            const endY = touch.clientY - rect.top;
            
            // v15.01.13: é«˜ã•å›ºå®šãƒ¢ãƒ¼ãƒ‰ã®å‡¦ç†
            let markerY, markerHeight;
            if (fixHeightMode && lastMarkerHeight > 0) {
                // é«˜ã•å›ºå®šï¼šé–‹å§‹ä½ç½®ã‹ã‚‰å›ºå®šé«˜ã•
                markerY = startY;
                markerHeight = lastMarkerHeight;
            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ï¼šè‡ªç”±ãªé«˜ã•
                markerY = Math.min(startY, endY);
                markerHeight = Math.abs(endY - startY);
            }
            
            const marker = {
                x: Math.min(startX, endX),
                y: markerY,
                width: Math.abs(endX - startX),
                height: markerHeight,
                color: currentMarkerColor,
                scale: scale
                // v7.00.2: studyStateã¯è¨­å®šã—ãªã„ï¼ˆundefined = å­¦ç¿’ONæ™‚ã¯æš—è»¢ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆï¼‰
            };
            
            if (marker.width > 5 && marker.height > 5) {
                // v15.01.13: é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã§ãƒãƒ¼ã‚«ãƒ¼ã‚’ä½œæˆã—ãŸå ´åˆã€æ¬¡å›ã®é«˜ã•å›ºå®šç”¨ã«é«˜ã•ã‚’è¨˜æ†¶
                if (!fixHeightMode) {
                    lastMarkerHeight = marker.height;
                }
                saveMarker(marker);
                drawMarkers();
            }
        }
        
        function getMarkerColor(color) {
            const colors = {
                'yellow': 'rgba(255, 255, 0, 0.4)',
                'red': 'rgba(255, 0, 0, 0.4)',
                'green': 'rgba(0, 255, 0, 0.4)',
                'blue': 'rgba(0, 150, 255, 0.4)'
            };
            return colors[color] || colors['yellow'];
        }
        
        function saveMarker(marker) {
            if (!pdfHash) return;
            
            if (!markers[pdfHash]) {
                markers[pdfHash] = {};
            }
            if (!markers[pdfHash][currentPage]) {
                markers[pdfHash][currentPage] = [];
            }
            
            markers[pdfHash][currentPage].push(marker);
            
            saveMarkersToFirebase();
        }
        
        function drawMarkers() {
            const canvas = document.getElementById('markerCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!pdfHash || !markers[pdfHash] || !markers[pdfHash][currentPage]) return;
            
            markers[pdfHash][currentPage].forEach((marker, index) => {
                const scaleRatio = scale / marker.scale;
                const mx = marker.x * scaleRatio;
                const my = marker.y * scaleRatio;
                const mw = marker.width * scaleRatio;
                const mh = marker.height * scaleRatio;
                
                // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰OFFæ™‚ã¯é€šå¸¸è¡¨ç¤ºã€ONæ™‚ã¯ã‚·ãƒ¼ãƒˆè¨­å®šã¨studyStateã«å¿œã˜ãŸè¡¨ç¤º
                if (studyMode) {
                    // v7.03: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ONæ™‚ï¼šã‚·ãƒ¼ãƒˆOFFã®è‰²ã¯æ˜è»¢ï¼ˆå­¦ç¿’å¯¾è±¡å¤–ï¼‰ã€ã‚·ãƒ¼ãƒˆONã®è‰²ã¯studyStateã«å¿œã˜ã¦è¡¨ç¤º
                    if (!redSheetColors[marker.color]) {
                        // ã‚·ãƒ¼ãƒˆOFFã®è‰² = æ˜è»¢ï¼ˆå­¦ç¿’å¯¾è±¡å¤–ã¨ã—ã¦èª­ã‚ã‚‹çŠ¶æ…‹ï¼‰
                        ctx.fillStyle = getMarkerColor(marker.color);
                        ctx.fillRect(mx, my, mw, mh);
                    } else {
                        // ã‚·ãƒ¼ãƒˆONã®è‰² = studyStateã«å¿œã˜ãŸè¡¨ç¤º
                        const studyState = marker.studyState;
                        
                        if (!studyState || studyState === 'hidden') {
                            // æš—è»¢ï¼ˆåˆæœŸçŠ¶æ…‹ï¼‰ï¼šé»’è‰²ã®å¡—ã‚Šã¤ã¶ã—
                            ctx.fillStyle = '#000000';
                            ctx.fillRect(mx, my, mw, mh);
                        } else if (studyState === 'visible') {
                            // æ˜è»¢ï¼ˆæ ãªã—ï¼‰ï¼šè§£ç­”ç¢ºèªç”¨
                            ctx.fillStyle = getMarkerColor(marker.color);
                            ctx.fillRect(mx, my, mw, mh);
                        } else if (studyState === 'correct') {
                            // æ­£ç­”ï¼šæ˜è»¢ + ç·‘æ 
                            ctx.fillStyle = getMarkerColor(marker.color);
                            ctx.fillRect(mx, my, mw, mh);
                            ctx.strokeStyle = '#27ae60';
                            ctx.lineWidth = 4;
                            ctx.strokeRect(mx, my, mw, mh);
                        } else if (studyState === 'incorrect') {
                            // èª¤ç­”ï¼šæ˜è»¢ + èµ¤æ 
                            ctx.fillStyle = getMarkerColor(marker.color);
                            ctx.fillRect(mx, my, mw, mh);
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 4;
                            ctx.strokeRect(mx, my, mw, mh);
                        }
                    }
                } else {
                    // v7.00.2: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰OFFæ™‚ï¼šé€šå¸¸è¡¨ç¤ºï¼ˆv6ç³»ã¨åŒã˜ã€ã‚·ãƒ¼ãƒˆæ©Ÿèƒ½æœ‰åŠ¹ï¼‰
                    const toggleKey = `${currentPage}-${index}`;
                    const isToggled = sheetClickToggles[toggleKey];
                    
                    if (redSheetColors[marker.color]) {
                        // ã‚·ãƒ¼ãƒˆãŒæœ‰åŠ¹ãªè‰²ã®å ´åˆ
                        if (isToggled) {
                            // ã‚¯ãƒªãƒƒã‚¯ã§æ˜è»¢ã•ã‚ŒãŸçŠ¶æ…‹
                            ctx.fillStyle = getMarkerColor(marker.color);
                        } else {
                            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æš—è»¢
                            ctx.fillStyle = '#000000';
                        }
                    } else {
                        // ã‚·ãƒ¼ãƒˆç„¡åŠ¹ãªè‰²ã¯é€šå¸¸è¡¨ç¤º
                        ctx.fillStyle = getMarkerColor(marker.color);
                    }
                    ctx.fillRect(mx, my, mw, mh);
                }
                
                if (editMode && selectedMarkerIndex === index) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(mx, my, mw, mh);
                    ctx.setLineDash([]);
                    
                    const handleSize = 10;
                    const handles = [
                        { x: mx, y: my },
                        { x: mx + mw, y: my },
                        { x: mx, y: my + mh },
                        { x: mx + mw, y: my + mh }
                    ];
                    
                    handles.forEach(handle => {
                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(handle.x, handle.y, handleSize / 2, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    });
                }
            });
            
            // v9.00: è‹¦æ‰‹ãƒãƒ¼ã‚«ãƒ¼ã®åˆ¤å®šã¨ãƒ“ãƒƒã‚¯ãƒªãƒãƒ¼ã‚¯è¡¨ç¤º
            if (studyMode && pdfHash && markers[pdfHash] && markers[pdfHash][currentPage]) {
                markers[pdfHash][currentPage].forEach((marker, index) => {
                    const correctCount = marker.correctCount || 0;
                    const incorrectCount = marker.incorrectCount || 0;
                    const totalCount = correctCount + incorrectCount;
                    
                    // ç·å­¦ç¿’å›æ•°ãŒ2å›ä»¥ä¸Šã§èª¤ç­”ç‡50%ä»¥ä¸Šã®å ´åˆã€è‹¦æ‰‹ãƒãƒ¼ã‚«ãƒ¼ã¨åˆ¤å®š
                    if (totalCount >= 2 && incorrectCount / totalCount >= 0.5) {
                        const scaleRatio = scale / marker.scale;
                        const mx = marker.x * scaleRatio;
                        const my = marker.y * scaleRatio;
                        const mw = marker.width * scaleRatio;
                        const mh = marker.height * scaleRatio;
                        
                        // å·¦ä¸Šè§’ã«é»„è‰²ã®ãƒ“ãƒƒã‚¯ãƒªãƒãƒ¼ã‚¯ã‚’æç”»
                        const iconSize = 16;
                        const iconX = mx + 4;
                        const iconY = my + 4;
                        
                        // èƒŒæ™¯å††ï¼ˆé»’ï¼‰
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.beginPath();
                        ctx.arc(iconX + iconSize/2, iconY + iconSize/2, iconSize/2 + 2, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // ãƒ“ãƒƒã‚¯ãƒªãƒãƒ¼ã‚¯ï¼ˆé»„è‰²ï¼‰
                        ctx.fillStyle = '#FFD700';
                        ctx.font = 'bold ' + iconSize + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('âš ', iconX + iconSize/2, iconY + iconSize/2);
                    }
                });
            }
        }
        
        function clearPageMarkers() {
            if (!pdfHash) return;
            
            if (confirm('ã“ã®ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ')) {
                if (markers[pdfHash] && markers[pdfHash][currentPage]) {
                    delete markers[pdfHash][currentPage];
                    drawMarkers();
                    saveMarkersToFirebase();
                    // v7.01: çµ±è¨ˆã‚’æ›´æ–°
                    updateStudyStats();
                }
            }
        }
        
        // v7.01: PDFå†…å…¨å‰Šé™¤
        function clearAllMarkers() {
            if (!pdfHash) return;
            
            if (confirm('ã“ã®PDFã®å…¨ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚')) {
                if (markers[pdfHash]) {
                    markers[pdfHash] = {};
                    drawMarkers();
                    saveMarkersToFirebase();
                    // v7.01: çµ±è¨ˆã‚’æ›´æ–°
                    updateStudyStats();
                }
            }
        }
        
        async function saveMarkersToFirebase() {
            if (!pdfHash) return;
            
            // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            if (!incrementWriteCounter()) {
                console.warn('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ãƒãƒ¼ã‚«ãƒ¼ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                return;
            }
            
            try {
                // v14.00: PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚‚ä¿å­˜
                await db.collection('pdfMarkers').doc(pdfHash).set({
                    markers: markers[pdfHash] || {},
                    fileName: currentPdfMetadata.fileName,
                    totalPages: currentPdfMetadata.totalPages,
                    fileSize: currentPdfMetadata.fileSize,
                    lastUpdated: currentPdfMetadata.lastUpdated,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            } catch (error) {
                console.error('ãƒãƒ¼ã‚«ãƒ¼ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                if (error.code === 'resource-exhausted') {
                    showWriteLimitWarning(FIRESTORE_DAILY_LIMIT);
                }
            }
        }
        
        async function loadMarkersFromFirebase() {
            if (!pdfHash) return;
            
            try {
                const doc = await db.collection('pdfMarkers').doc(pdfHash).get();
                if (doc.exists) {
                    const data = doc.data();
                    markers[pdfHash] = data.markers || {};
                    drawMarkers();
                }
            } catch (error) {
                console.error('ãƒãƒ¼ã‚«ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function closePDF() {
            if (confirm('PDFã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ')) {
                pdfDoc = null;
                currentPDFFile = null;
                pdfHash = null;
                currentPage = 1;
                totalPages = 0;
                scale = 1.0;
                isDrawing = false;
                redSheetMode = false;
                
                editMode = false;
                deleteMode = false;
                redSheetColors = { yellow: false, red: false, green: false, blue: false, all: false };
                selectedMarkerIndex = null;
                selectedMarkerPage = null;
                isDraggingMarker = false;
                resizingHandle = null;
                isPanning = false;
                offsetX = 0;
                offsetY = 0;
                
                // v7.00: å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚‚ãƒªã‚»ãƒƒãƒˆ
                studyMode = false;
                
                const markerBtn = document.getElementById('markerModeBtn');
                const editBtn = document.getElementById('editModeBtn');
                const deleteBtn = document.getElementById('deleteModeBtn');
                const studyBtn = document.getElementById('studyModeBtn');
                if (markerBtn) {
                    markerBtn.textContent = 'ãƒãƒ¼ã‚«ãƒ¼OFF';
                    markerBtn.className = 'btn btn-mode-off';
                }
                if (editBtn) {
                    editBtn.textContent = 'ğŸ“ ä¿®æ­£OFF';
                    editBtn.className = 'btn btn-mode-off';
                }
                if (deleteBtn) {
                    deleteBtn.textContent = 'ğŸ—‘ï¸ å‰Šé™¤OFF';
                    deleteBtn.className = 'btn btn-mode-off';
                }
                if (studyBtn) {
                    studyBtn.textContent = 'å­¦ç¿’OFF';
                    studyBtn.className = 'btn btn-mode-off';
                    studyBtn.style.display = 'none';
                }
                
                ['yellow', 'red', 'green', 'blue', 'all'].forEach(color => {
                    const btn = document.getElementById('redsheet' + color.charAt(0).toUpperCase() + color.slice(1));
                    if (btn) btn.classList.remove('active');
                });
                
                // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
                enableButtons();
                
                document.getElementById('pdfUploadArea').style.display = 'block';
                document.getElementById('pdfViewerContainer').style.display = 'none';
                document.getElementById('pdfFileInput').value = '';
            }
        }
        
        // ========== ãƒ‡ãƒƒã‚­ç®¡ç†æ©Ÿèƒ½ ==========
        
        async function loadDecks() {
            try {
                const snapshot = await db.collection('decks').orderBy('order').get();
                decks = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                displayDecks();
            } catch (error) {
                console.error('ãƒ‡ãƒƒã‚­èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        
        function displayDecks() {
            const deckList = document.getElementById('deckList');
            if (!deckList) return;
            
            if (decks.length === 0) {
                deckList.innerHTML = '<div class="empty-state"><h2>ãƒ‡ãƒƒã‚­ãŒã‚ã‚Šã¾ã›ã‚“</h2><p>ã€Œæ–°è¦ãƒ‡ãƒƒã‚­ä½œæˆã€ãƒœã‚¿ãƒ³ã‹ã‚‰ãƒ‡ãƒƒã‚­ã‚’ä½œæˆã—ã¦ãã ã•ã„</p></div>';
                return;
            }
            
            // v12.00.2: orderé †ã§ã‚½ãƒ¼ãƒˆã€æ¬¡ã«åå‰é †
            const topLevelDecks = decks.filter(d => !d.parentId).sort((a, b) => {
                if ((a.order || 0) !== (b.order || 0)) {
                    return (a.order || 0) - (b.order || 0);
                }
                return a.name.localeCompare(b.name);
            });
            
            let html = '';
            
            topLevelDecks.forEach(deck => {
                html += renderDeckItem(deck, 0);
            });
            
            deckList.innerHTML = html;
            
            // v12.00.2: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            setupDragAndDrop();
            
    
        // v12.00.6: ãƒ‡ãƒƒã‚­ã®éšå±¤æ·±ã•ã‚’è¨ˆç®—
        function getDeckDepth(deckId) {
            let depth = 0;
            let current = decks.find(d => d.id === deckId);
            while (current && current.parentId) {
                depth++;
                current = decks.find(d => d.id === current.parentId);
                if (depth > 10) break; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
            }
            return depth;
        }
        
        // v12.00.6: ãƒ‡ãƒƒã‚­ãƒ„ãƒªãƒ¼ã®æœ€å¤§æ·±ã•ã‚’è¨ˆç®—ï¼ˆãã®ãƒ‡ãƒƒã‚­ã‚’æ ¹ã¨ã—ãŸå ´åˆï¼‰
        function getMaxTreeDepth(deckId) {
            const children = decks.filter(d => d.parentId === deckId);
            if (children.length === 0) {
                return 0;
            }
            let maxChildDepth = 0;
            for (const child of children) {
                const childDepth = getMaxTreeDepth(child.id);
                if (childDepth > maxChildDepth) {
                    maxChildDepth = childDepth;
                }
            }
            return maxChildDepth + 1;
        }

        // v12.00.4: ç©ºç™½ã‚¨ãƒªã‚¢ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—ã§ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«æ˜‡æ ¼
            deckList.addEventListener('dragover', handleEmptyAreaDragOver);
            deckList.addEventListener('drop', handleEmptyAreaDrop);
        }
        
        function renderDeckItem(deck, level) {
            // v12.00.2: childDecksã‚’orderé †ã§ã‚½ãƒ¼ãƒˆ
            const childDecks = decks.filter(d => d.parentId === deck.id).sort((a, b) => {
                if ((a.order || 0) !== (b.order || 0)) {
                    return (a.order || 0) - (b.order || 0);
                }
                return a.name.localeCompare(b.name);
            });
            
            // v6.01.2: ãƒ‡ãƒƒã‚­è‡ªä½“ã®ã‚«ãƒ¼ãƒ‰æ•°ã®ã¿ã‚’è¨ˆç®—ï¼ˆã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’å«ã‚ãªã„ï¼‰
            const deckCards = cards.filter(c => c.deckId === deck.id);
            const cardCount = deckCards.length;
            
            // v8.00: ä»Šæ—¥å­¦ç¿’ã™ã¹ãã‚«ãƒ¼ãƒ‰æ•°ã‚’è¨ˆç®—
            const now = Date.now();
            const dueCards = deckCards.filter(c => {
                const card = initializeCard(c);
                return !card.nextReview || card.nextReview <= now;
            });
            const dueCount = dueCards.length;
            
            // v8.01.1: ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’å«ã‚€è¨­å®šã‚’å–å¾—
            const includeSubdecks = getDeckSetting(deck.id, 'includeSubdecks', true);
            
            // v12.00: æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹ã‚’å–å¾—
            const isCollapsed = collapsedDecks[deck.id] || false;
            const hasChildren = childDecks.length > 0;
            const collapseIcon = hasChildren ? (isCollapsed ? 'â–¶' : 'â–¼') : '';
            
            const depthClass = level === 0 ? '' : (level === 1 ? 'child-deck' : 'grandchild-deck');
            
            // v12.00: ã‚¢ã‚¤ã‚³ãƒ³ã¨è‰²ã®ã‚¹ã‚¿ã‚¤ãƒ«æº–å‚™
            const iconDisplay = deck.icon ? deck.icon + ' ' : '';
            const colorStyle = deck.color ? `background: ${deck.color}20; border-left: 4px solid ${deck.color};` : '';
            
            let html = `
                <div class="deck-item ${depthClass}" draggable="true" data-deck-id="${deck.id}">
                    <div class="deck-header" style="${colorStyle}">
                        <span class="drag-handle" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³æ›¿ãˆ">â‹®â‹®</span>
                        ${hasChildren ? `<button onclick="event.stopPropagation(); toggleDeckCollapse('${deck.id}')" style="background: none; border: none; font-size: 16px; cursor: pointer; padding: 5px; margin-right: 5px; color: #333;">${collapseIcon}</button>` : '<span style="width: 26px; display: inline-block;"></span>'}
                        <div style="cursor: pointer; display: flex; align-items: center; flex: 1;" onclick="viewDeckCards('${deck.id}')">
                            <div class="deck-name">${iconDisplay}${deck.name}</div>
                            <div class="deck-count">${cardCount}æš ${dueCount > 0 ? `<span style="color: #e74c3c; font-weight: bold;">(${dueCount}æšå­¦ç¿’)</span>` : ''}</div>
                        </div>
                        <div class="deck-actions">
                            ${dueCount > 0 ? `<button class="btn btn-small btn-success" onclick="startDeckStudy('${deck.id}')">å­¦ç¿’é–‹å§‹</button>` : ''}
                            ${childDecks.length > 0 ? `
                                <label style="display: inline-flex; align-items: center; gap: 5px; margin: 0 5px; cursor: pointer;">
                                    <input type="checkbox" id="includeSubdecks_${deck.id}" 
                                           ${includeSubdecks ? 'checked' : ''} 
                                           onchange="toggleSubdecks('${deck.id}')" 
                                           style="width: auto; height: auto; cursor: pointer;">
                                    <span style="font-size: 14px;">ã‚µãƒ–ãƒ‡ãƒƒã‚­å«ã‚€</span>
                                </label>
                            ` : ''}
                            <button class="btn btn-small btn-secondary" onclick="editDeck('${deck.id}')">ç·¨é›†</button>
                            ${level < 2 ? `<button class="btn btn-small" onclick="addSubDeck('${deck.id}')">ã‚µãƒ–ãƒ‡ãƒƒã‚­è¿½åŠ </button>` : ''}
                            <button class="btn btn-small btn-danger" onclick="deleteDeck('${deck.id}')">å‰Šé™¤</button>
                        </div>
                    </div>
                </div>
            `;
            
            // v12.00: æŠ˜ã‚ŠãŸãŸã¾ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’è¡¨ç¤º
            if (!isCollapsed) {
                childDecks.forEach(child => {
                    html += renderDeckItem(child, level + 1);
                });
            }
            
            return html;
        }
        
        // v8.01.1: ã‚µãƒ–ãƒ‡ãƒƒã‚­å«ã‚€è¨­å®šã‚’ãƒˆã‚°ãƒ«
        function toggleSubdecks(deckId) {
            const checkbox = document.getElementById(`includeSubdecks_${deckId}`);
            const includeSubdecks = checkbox.checked;
            setDeckSetting(deckId, 'includeSubdecks', includeSubdecks);
            console.log(`ãƒ‡ãƒƒã‚­ ${deckId} ã®ã‚µãƒ–ãƒ‡ãƒƒã‚­å«ã‚€è¨­å®š: ${includeSubdecks}`);
        }
        // v12.00: ãƒ‡ãƒƒã‚­æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½
        function toggleDeckCollapse(deckId) {
            collapsedDecks[deckId] = !collapsedDecks[deckId];
            localStorage.setItem('collapsedDecks', JSON.stringify(collapsedDecks));
            displayDecks();
        }
        
        
        // v8.00: ãƒ›ãƒ¼ãƒ ç”»é¢ã‹ã‚‰ç›´æ¥å­¦ç¿’ã‚’é–‹å§‹
        async function startDeckStudy(deckId) {
            // å­¦ç¿’ã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            
            const studyTab = document.querySelectorAll('.tab')[1]; // å­¦ç¿’ã‚¿ãƒ–
            studyTab.classList.add('active');
            document.getElementById('study-section').classList.add('active');
            
            // ãƒ‡ãƒƒã‚­ã‚’é¸æŠ
            document.getElementById('studyDeckId').value = deckId;
            
            // v8.01.1: ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’å­¦ç¿’ã‚¿ãƒ–ã«åæ˜ 
            const includeSubdecks = getDeckSetting(deckId, 'includeSubdecks', true);
            document.getElementById('includeSubdecks').checked = includeSubdecks;
            
            // å­¦ç¿’é–‹å§‹
            await startStudySession();
        }
        
        // v6.01: ãƒ‡ãƒƒã‚­ã®ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤º

        // v12.01: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
        function renderPagination(filteredCards) {
            totalFilteredCards = filteredCards.length;
            const totalPages = Math.ceil(totalFilteredCards / cardsPerPage);
            
            if (totalPages <= 1) return '';
            
            let html = '<div class="pagination">';
            
            // å‰ã¸ãƒœã‚¿ãƒ³
            html += `<button onclick="changePage(${currentCardPage - 1})" ${currentCardPage === 1 ? 'disabled' : ''}>â† å‰ã¸</button>`;
            
            // ãƒšãƒ¼ã‚¸ç•ªå·
            const maxButtons = 5;
            let startPage = Math.max(1, currentCardPage - Math.floor(maxButtons / 2));
            let endPage = Math.min(totalPages, startPage + maxButtons - 1);
            
            if (endPage - startPage < maxButtons - 1) {
                startPage = Math.max(1, endPage - maxButtons + 1);
            }
            
            if (startPage > 1) {
                html += `<button onclick="changePage(1)">1</button>`;
                if (startPage > 2) html += '<span>...</span>';
            }
            
            for (let i = startPage; i <= endPage; i++) {
                html += `<button onclick="changePage(${i})" class="${i === currentCardPage ? 'current-page' : ''}">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) html += '<span>...</span>';
                html += `<button onclick="changePage(${totalPages})">${totalPages}</button>`;
            }
            
            // æ¬¡ã¸ãƒœã‚¿ãƒ³
            html += `<button onclick="changePage(${currentCardPage + 1})" ${currentCardPage === totalPages ? 'disabled' : ''}>æ¬¡ã¸ â†’</button>`;
            
            // æƒ…å ±è¡¨ç¤º
            const start = (currentCardPage - 1) * cardsPerPage + 1;
            const end = Math.min(currentCardPage * cardsPerPage, totalFilteredCards);
            html += `<span class="pagination-info">${start}-${end} / ${totalFilteredCards}æš</span>`;
            
            html += '</div>';
            return html;
        }
        
        function changePage(page) {
            const totalPages = Math.ceil(totalFilteredCards / cardsPerPage);
            if (page < 1 || page > totalPages) return;
            currentCardPage = page;
            displayCardListWithPagination();
        }
        
        function getPaginatedCards(filteredCards) {
            const start = (currentCardPage - 1) * cardsPerPage;
            const end = start + cardsPerPage;
            return filteredCards.slice(start, end);
        }

        function viewDeckCards(deckId) {
            // v14.02.1.2: ã‚«ãƒ¼ãƒ‰ç®¡ç†ã‚¿ãƒ–ã«æ­£ã—ãåˆ‡ã‚Šæ›¿ãˆ
            switchTab('cards');
            
            // ãƒ‡ãƒƒã‚­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’è¨­å®š
            const deckFilter = document.getElementById('deckFilter');
            if (deckFilter) {
                deckFilter.value = deckId;
                currentDeckFilter = deckId;
                filterCards();
            }
            
            // v6.01.1: æ–°è¦ã‚«ãƒ¼ãƒ‰ä½œæˆã®ãƒ‡ãƒƒã‚­ã‚‚æ›´æ–°
            const deckSelector = document.getElementById('deckId');
            if (deckSelector) {
                deckSelector.value = deckId;
                localStorage.setItem('lastSelectedDeckId', deckId);
            }
        }
        
        // v6.00: ãƒ‡ãƒƒã‚­ã¨ã‚µãƒ–ãƒ‡ãƒƒã‚­ã®ã‚«ãƒ¼ãƒ‰æ•°ã‚’å†å¸°çš„ã«è¨ˆç®—
        function countDeckCards(deckId) {
            const deckCards = cards.filter(c => c.deckId === deckId);
            const childDecks = decks.filter(d => d.parentId === deckId);
            const childCards = childDecks.reduce((sum, child) => {
                return sum + countDeckCards(child.id);
            }, 0);
            return deckCards.length + childCards;
        }
        
        function createNewDeck() {
            currentEditingDeckId = null;
            document.getElementById('deckModalTitle').textContent = 'æ–°è¦ãƒ‡ãƒƒã‚­ä½œæˆ';
            document.getElementById('deckName').value = '';
            document.getElementById('parentDeckId').value = '';
            updateParentDeckOptions(null);
            
            // v8.02.4: è¨­å®šã‚¿ãƒ–ã®åˆæœŸåŒ–
            document.querySelectorAll('#deckModal .card-type-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#deckModal .card-type-tab')[0].classList.add('active');
            document.getElementById('deckModalBasic').style.display = 'block';
            document.getElementById('deckModalSettings').style.display = 'none';
            document.getElementById('deckUseCustomSettings').checked = false;
            document.getElementById('deckCustomSettingsPanel').style.display = 'none';
            
            // v12.00: ã‚¢ã‚¤ã‚³ãƒ³ã¨è‰²ã®ãƒªã‚»ãƒƒãƒˆ
            selectedIcon = null;
            selectedColor = null;
            document.getElementById('selectedDeckIcon').value = '';
            document.getElementById('selectedDeckColor').value = '';
            document.querySelectorAll('.icon-btn').forEach(btn => btn.style.border = '2px solid #ddd');
            document.getElementById('icon-none').style.border = '3px solid #667eea';
            document.querySelectorAll('.color-picker-btn').forEach(btn => btn.style.border = '2px solid #ddd');
            document.querySelectorAll('.color-picker-btn')[0].style.border = '3px solid #667eea';
            
            document.getElementById('deckModal').style.display = 'block';
        }
        
        function addSubDeck(parentId) {
            const depth = getDeckDepth(parentId);
            if (depth >= 2) {
                alert('ã‚µãƒ–ãƒ‡ãƒƒã‚­ã¯æœ€å¤§3éšå±¤ã¾ã§ã§ã™ã€‚');
                return;
            }
            
            currentEditingDeckId = null;
            document.getElementById('deckModalTitle').textContent = 'ã‚µãƒ–ãƒ‡ãƒƒã‚­ä½œæˆ';
            document.getElementById('deckName').value = '';
            updateParentDeckOptions(null);
            document.getElementById('parentDeckId').value = parentId;
            document.getElementById('deckModal').style.display = 'block';
        }
        
        function editDeck(deckId) {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return;
            
            currentEditingDeckId = deckId;
            document.getElementById('deckModalTitle').textContent = 'ãƒ‡ãƒƒã‚­ç·¨é›†';
            document.getElementById('deckName').value = deck.name;
            document.getElementById('parentDeckId').value = deck.parentId || '';
            updateParentDeckOptions(deckId);
            
            // v8.02.4: è¨­å®šã‚¿ãƒ–ã®åˆæœŸåŒ–
            document.querySelectorAll('#deckModal .card-type-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('#deckModal .card-type-tab')[0].classList.add('active');
            document.getElementById('deckModalBasic').style.display = 'block';
            document.getElementById('deckModalSettings').style.display = 'none';
            
            // ãƒ‡ãƒƒã‚­å€‹åˆ¥è¨­å®šã®èª­ã¿è¾¼ã¿
            const useCustom = deck.useCustomSettings || false;
            document.getElementById('deckUseCustomSettings').checked = useCustom;
            document.getElementById('deckCustomSettingsPanel').style.display = useCustom ? 'block' : 'none';
            
            if (useCustom && deck.settings) {
                document.getElementById('deckGraduatingInterval').value = deck.settings.graduatingInterval;
                document.getElementById('deckEasyInterval').value = deck.settings.easyInterval;
                document.getElementById('deckStartingEase').value = deck.settings.startingEase;
                document.getElementById('deckEasyBonus').value = deck.settings.easyBonus;
                document.getElementById('deckIntervalModifier').value = deck.settings.intervalModifier;
                document.getElementById('deckMaximumInterval').value = deck.settings.maximumInterval;
                loadDeckSettingsUI();
            } else {
                document.getElementById('deckGraduatingInterval').value = globalStudySettings.graduatingInterval;
                document.getElementById('deckEasyInterval').value = globalStudySettings.easyInterval;
                document.getElementById('deckStartingEase').value = globalStudySettings.startingEase;
                document.getElementById('deckEasyBonus').value = globalStudySettings.easyBonus;
                document.getElementById('deckIntervalModifier').value = globalStudySettings.intervalModifier;
                document.getElementById('deckMaximumInterval').value = globalStudySettings.maximumInterval;
                loadDeckSettingsUI();
            }
            
            // v12.00: ã‚¢ã‚¤ã‚³ãƒ³ã¨è‰²ã®èª­ã¿è¾¼ã¿
            selectedIcon = deck.icon || null;
            selectedColor = deck.color || null;
            document.getElementById('selectedDeckIcon').value = selectedIcon || '';
            document.getElementById('selectedDeckColor').value = selectedColor || '';
            
            // ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.icon-btn').forEach(btn => btn.style.border = '2px solid #ddd');
            if (selectedIcon) {
                document.querySelectorAll('.icon-btn').forEach(btn => {
                    if (btn.onclick && btn.onclick.toString().includes(selectedIcon)) {
                        btn.style.border = '3px solid #667eea';
                    }
                });
            } else {
                document.getElementById('icon-none').style.border = '3px solid #667eea';
            }
            
            // è‰²ãƒœã‚¿ãƒ³ã®é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.color-picker-btn').forEach(btn => btn.style.border = '2px solid #ddd');
            if (selectedColor) {
                document.querySelectorAll('.color-picker-btn').forEach(btn => {
                    if (btn.onclick && btn.onclick.toString().includes(selectedColor)) {
                        btn.style.border = '3px solid #667eea';
                    }
                });
            } else {
                document.querySelectorAll('.color-picker-btn')[0].style.border = '3px solid #667eea';
            }
            
            document.getElementById('deckModal').style.display = 'block';
        }
        
        function updateParentDeckOptions(currentDeckId) {
            const select = document.getElementById('parentDeckId');
            let html = '<option value="">ãªã—ï¼ˆãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ï¼‰</option>';
            
            decks.forEach(deck => {
                if (currentDeckId && (deck.id === currentDeckId || isDescendant(deck.id, currentDeckId))) {
                    return;
                }
                
                if (getDeckDepth(deck.id) >= 2) {
                    return;
                }
                
                if (currentDeckId) {
                    const newDepth = getDeckDepth(deck.id) + 1 + getMaxDescendantDepth(currentDeckId);
                    if (newDepth > 2) return;
                }
                
                const path = getDeckPath(deck.id);
                html += `<option value="${deck.id}">${path}</option>`;
            });
            
            select.innerHTML = html;
        }
        
        function getDeckDepth(deckId) {
            let depth = 0;
            let currentDeck = decks.find(d => d.id === deckId);
            
            while (currentDeck && currentDeck.parentId) {
                depth++;
                currentDeck = decks.find(d => d.id === currentDeck.parentId);
            }
            
            return depth;
        }
        
        function getMaxDescendantDepth(deckId) {
            const children = decks.filter(d => d.parentId === deckId);
            if (children.length === 0) return 0;
            
            let maxDepth = 0;
            children.forEach(child => {
                const childDepth = 1 + getMaxDescendantDepth(child.id);
                maxDepth = Math.max(maxDepth, childDepth);
            });
            
            return maxDepth;
        }
        
        function isDescendant(deckId, ancestorId) {
            let current = decks.find(d => d.id === deckId);
            
            while (current && current.parentId) {
                if (current.parentId === ancestorId) return true;
                current = decks.find(d => d.id === current.parentId);
            }
            
            return false;
        }
        
        function getDeckPath(deckId) {
            const path = [];
            let currentDeck = decks.find(d => d.id === deckId);
            
            while (currentDeck) {
                path.unshift(currentDeck.name);
                if (!currentDeck.parentId) break;
                currentDeck = decks.find(d => d.id === currentDeck.parentId);
            }
            
            return path.join(' > ');
        }
        
        // v12.00: ã‚¢ã‚¤ã‚³ãƒ³é¸æŠé–¢æ•°
        let selectedIcon = null;
        let selectedColor = null;
        
        function selectDeckIcon(icon) {
            selectedIcon = icon;
            document.getElementById('selectedDeckIcon').value = icon || '';
            
            // å…¨ã¦ã®ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
            document.querySelectorAll('.icon-btn').forEach(btn => {
                btn.style.border = '2px solid #ddd';
            });
            
            // é¸æŠã•ã‚ŒãŸã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (icon === null) {
                document.getElementById('icon-none').style.border = '3px solid #667eea';
            } else {
                event.target.style.border = '3px solid #667eea';
            }
        }
        
        function selectDeckColor(color) {
            selectedColor = color;
            document.getElementById('selectedDeckColor').value = color || '';
            
            // å…¨ã¦ã®è‰²ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
            document.querySelectorAll('.color-picker-btn').forEach(btn => {
                btn.style.border = '2px solid #ddd';
            });
            
            // é¸æŠã•ã‚ŒãŸè‰²ãƒœã‚¿ãƒ³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            event.target.style.border = '3px solid #667eea';
        }
        

        // v12.00.2: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        let draggedDeckId = null;
        let dropTargetDeckId = null;
        
        function setupDragAndDrop() {
            const deckItems = document.querySelectorAll('.deck-item');
            
            deckItems.forEach(item => {
                item.addEventListener('dragstart', handleDeckDragStart);
                item.addEventListener('dragend', handleDeckDragEnd);
                item.addEventListener('dragover', handleDeckDragOver);
                item.addEventListener('dragleave', handleDeckDragLeave);
                item.addEventListener('drop', handleDeckDrop);
            });
        }
        
        function handleDeckDragStart(e) {
            draggedDeckId = e.currentTarget.dataset.deckId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDeckDragEnd(e) {
            e.currentTarget.classList.remove('dragging');
            document.querySelectorAll('.deck-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedDeckId = null;
            dropTargetDeckId = null;
        }
        
        function handleDeckDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const targetDeckId = e.currentTarget.dataset.deckId;
            if (targetDeckId && targetDeckId !== draggedDeckId) {
                e.currentTarget.classList.add('drag-over');
                dropTargetDeckId = targetDeckId;
            }
        }
        
        function handleDeckDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        async function handleDeckDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetDeckId = e.currentTarget.dataset.deckId;
            
            if (!draggedDeckId || !targetDeckId || draggedDeckId === targetDeckId) {
                return;
            }
            
            const draggedDeck = decks.find(d => d.id === draggedDeckId);
            const targetDeck = decks.find(d => d.id === targetDeckId);
            
            if (!draggedDeck || !targetDeck) {
                return;
            }
            
            // å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯
            if (isDescendant(targetDeck, draggedDeck)) {
                alert('ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’è¦ªãƒ‡ãƒƒã‚­ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
                return;
            }
            
            // v12.00.4: è‡ªå‹•åˆ¤å®šï¼ˆåŒéšå±¤=ä¸¦ã³æ›¿ãˆã€ç•°ãªã‚‹éšå±¤=è¦ªå¤‰æ›´ï¼‰
            if (draggedDeck.parentId === targetDeck.parentId) {
                // ä¸¦ã³æ›¿ãˆï¼šåŒã˜è¦ªãƒ‡ãƒƒã‚­å†…ã§orderå€¤ã‚’å…¥ã‚Œæ›¿ãˆ
                const draggedOrder = draggedDeck.order || 0;
                const targetOrder = targetDeck.order || 0;
                
                try {
                    await db.collection('decks').doc(draggedDeckId).update({
                        order: targetOrder,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    await db.collection('decks').doc(targetDeckId).update({
                        order: draggedOrder,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    draggedDeck.order = targetOrder;
                    targetDeck.order = draggedOrder;
                    
                    await displayDecks();
                } catch (error) {
                    console.error('ä¸¦ã³æ›¿ãˆã‚¨ãƒ©ãƒ¼:', error);
                    alert('ä¸¦ã³æ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            } else {
                // è¦ªãƒ‡ãƒƒã‚­å¤‰æ›´
                // å¾ªç’°å‚ç…§ãƒã‚§ãƒƒã‚¯
                if (isDescendant(targetDeck, draggedDeck)) {
                    alert('ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’è¦ªãƒ‡ãƒƒã‚­ã«ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
                    return;
                }
                
                // v12.00.6: éšå±¤æ·±ã•ãƒã‚§ãƒƒã‚¯ï¼ˆ3éšå±¤ã¾ã§ï¼‰
                const targetDepth = getDeckDepth(targetDeckId);
                const draggedTreeDepth = getMaxTreeDepth(draggedDeckId);
                const resultDepth = targetDepth + 1 + draggedTreeDepth;
                
                if (resultDepth > 2) {
                    alert(`ãƒ‡ãƒƒã‚­ã¯3éšå±¤ï¼ˆè¦ªâ†’å­â†’å­«ï¼‰ã¾ã§ã§ã™ã€‚\n\nç§»å‹•å…ˆã®éšå±¤: ${targetDepth + 1}\nç§»å‹•ã™ã‚‹ãƒ‡ãƒƒã‚­ã®ãƒ„ãƒªãƒ¼æ·±ã•: ${draggedTreeDepth}\nçµæœã®æœ€å¤§éšå±¤: ${resultDepth + 1}éšå±¤ç›®`);
                    return;
                }
                
                try {
                    await db.collection('decks').doc(draggedDeckId).update({
                        parentId: targetDeckId,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    draggedDeck.parentId = targetDeckId;
                    await displayDecks();
                } catch (error) {
                    console.error('ãƒ‡ãƒƒã‚­ç§»å‹•ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒ‡ãƒƒã‚­ã®ç§»å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }
        }
        
        // å­å­«ãƒ‡ãƒƒã‚­ãƒã‚§ãƒƒã‚¯
        function isDescendant(potentialAncestor, potentialDescendant) {
            let current = potentialAncestor;
            while (current.parentId) {
                if (current.parentId === potentialDescendant.id) {
                    return true;
                }
                current = decks.find(d => d.id === current.parentId);
                if (!current) break;
            }
            return false;
        }



        // v12.00.6: ãƒ‡ãƒƒã‚­ã®éšå±¤æ·±ã•ã‚’è¨ˆç®—
        function getDeckDepth(deckId) {
            let depth = 0;
            let current = decks.find(d => d.id === deckId);
            while (current && current.parentId) {
                depth++;
                current = decks.find(d => d.id === current.parentId);
                if (depth > 10) break; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
            }
            return depth;
        }
        
        // v12.00.6: ãƒ‡ãƒƒã‚­ãƒ„ãƒªãƒ¼ã®æœ€å¤§æ·±ã•ã‚’è¨ˆç®—ï¼ˆãã®ãƒ‡ãƒƒã‚­ã‚’æ ¹ã¨ã—ãŸå ´åˆï¼‰
        function getMaxTreeDepth(deckId) {
            const children = decks.filter(d => d.parentId === deckId);
            if (children.length === 0) {
                return 0;
            }
            let maxChildDepth = 0;
            for (const child of children) {
                const childDepth = getMaxTreeDepth(child.id);
                if (childDepth > maxChildDepth) {
                    maxChildDepth = childDepth;
                }
            }
            return maxChildDepth + 1;
        }

        // v12.00.4: ç©ºç™½ã‚¨ãƒªã‚¢ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—ã§ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«æ˜‡æ ¼
        function handleEmptyAreaDragOver(e) {
            // ãƒ‡ãƒƒã‚­ã‚¢ã‚¤ãƒ†ãƒ ä¸Šã§ãªã„å ´åˆã®ã¿å‡¦ç†
            if (!e.target.closest('.deck-item')) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }
        }
        
        async function handleEmptyAreaDrop(e) {
            // ãƒ‡ãƒƒã‚­ã‚¢ã‚¤ãƒ†ãƒ ä¸Šã§ãªã„å ´åˆã®ã¿å‡¦ç†
            if (!e.target.closest('.deck-item') && draggedDeckId) {
                e.preventDefault();
                e.stopPropagation();
                
                const draggedDeck = decks.find(d => d.id === draggedDeckId);
                if (!draggedDeck) return;
                
                // æ—¢ã«ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
                if (!draggedDeck.parentId) {
                    return;
                }
                
                try {
                    await db.collection('decks').doc(draggedDeckId).update({
                        parentId: null,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    draggedDeck.parentId = null;
                    await displayDecks();
                } catch (error) {
                    console.error('ãƒ‡ãƒƒã‚­æ˜‡æ ¼ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒ‡ãƒƒã‚­ã®æ˜‡æ ¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }
        }

        async function saveDeck() {
            const name = document.getElementById('deckName').value.trim();
            if (!name) {
                alert('ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            const parentId = document.getElementById('parentDeckId').value || null;
            
            // v8.02.4: ãƒ‡ãƒƒã‚­å€‹åˆ¥è¨­å®šã®å–å¾—
            const useCustomSettings = document.getElementById('deckUseCustomSettings').checked;
            
            // v12.00: ã‚¢ã‚¤ã‚³ãƒ³ã¨è‰²ã®å–å¾—
            const icon = document.getElementById('selectedDeckIcon').value || null;
            const color = document.getElementById('selectedDeckColor').value || null;
            
            let deckData = {
                name: name,
                parentId: parentId,
                useCustomSettings: useCustomSettings,
                icon: icon,
                color: color,
                order: currentEditingDeckId ? (decks.find(d => d.id === currentEditingDeckId)?.order || 0) : 0,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            if (useCustomSettings) {
                const stepInputs = document.querySelectorAll('.deck-learning-step');
                const learningSteps = Array.from(stepInputs).map(input => parseInt(input.value));
                
                deckData.settings = {
                    learningSteps: learningSteps,
                    graduatingInterval: parseInt(document.getElementById('deckGraduatingInterval').value),
                    easyInterval: parseInt(document.getElementById('deckEasyInterval').value),
                    startingEase: parseFloat(document.getElementById('deckStartingEase').value),
                    easyBonus: parseFloat(document.getElementById('deckEasyBonus').value),
                    intervalModifier: parseFloat(document.getElementById('deckIntervalModifier').value),
                    maximumInterval: parseInt(document.getElementById('deckMaximumInterval').value),
                    newCardsPerDay: globalStudySettings.newCardsPerDay,
                    reviewCardsPerDay: globalStudySettings.reviewCardsPerDay
                };
            }
            
            try {
                if (currentEditingDeckId) {
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        return;
                    }
                    
                    await db.collection('decks').doc(currentEditingDeckId).update(deckData);
                } else {
                    // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                    if (!incrementWriteCounter()) {
                        alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒƒã‚­ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã€‚');
                        return;
                    }
                    
                    const order = decks.filter(d => d.parentId === parentId).length;
                    deckData.order = order;
                    deckData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                    await db.collection('decks').add(deckData);
                }
                
                closeModal();
                await loadDecks();
            } catch (error) {
                console.error('ãƒ‡ãƒƒã‚­ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ‡ãƒƒã‚­ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        async function deleteDeck(deckId) {
            const deck = decks.find(d => d.id === deckId);
            if (!deck) return;
            
            const children = decks.filter(d => d.parentId === deckId);
            if (children.length > 0) {
                alert('ã‚µãƒ–ãƒ‡ãƒƒã‚­ãŒã‚ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚å…ˆã«ã‚µãƒ–ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // v6.02: ãƒ‡ãƒƒã‚­ã«ã‚«ãƒ¼ãƒ‰ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const deckCards = cards.filter(c => c.deckId === deckId);
            if (deckCards.length > 0) {
                alert(`ã“ã®ãƒ‡ãƒƒã‚­ã«ã¯${deckCards.length}æšã®ã‚«ãƒ¼ãƒ‰ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚\nãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã™ã‚‹å‰ã«ã€ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã™ã‚‹ã‹åˆ¥ã®ãƒ‡ãƒƒã‚­ã«ç§»å‹•ã—ã¦ãã ã•ã„ã€‚`);
                return;
            }
            
            if (!confirm(`ãƒ‡ãƒƒã‚­ã€Œ${deck.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            try {
                // v8.02.3: æ›¸ãè¾¼ã¿ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                if (!incrementWriteCounter()) {
                    alert('æ›¸ãè¾¼ã¿ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚');
                    return;
                }
                
                await db.collection('decks').doc(deckId).delete();
                await loadDecks();
            } catch (error) {
                console.error('ãƒ‡ãƒƒã‚­å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ‡ãƒƒã‚­ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        function closeModal() {
            document.getElementById('deckModal').style.display = 'none';
        }
        
        // v10.00.1: ãƒ¢ãƒ¼ãƒ€ãƒ«ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const deckModal = document.getElementById('deckModal');
            const cardEditModal = document.getElementById('cardEditModal');
            const deckSelectorModal = document.getElementById('deckSelectorModal');
            const markerSearchModal = document.getElementById('markerSearchModal');
            const markerPreviewModal = document.getElementById('markerPreviewModal');
            
            if (event.target === deckModal) {
                closeModal();
            }
            if (event.target === cardEditModal) {
                closeCardEditModal();
            }
            if (event.target === deckSelectorModal) {
                closeDeckSelectorModal();
            }
            if (event.target === markerSearchModal) {
                closeMarkerSearchModal();
            }
            if (event.target === markerPreviewModal) {
                closeMarkerPreviewModal();
            }
        }
        
        // v8.02.4: ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚¿ãƒ–ã®é–¢æ•°ç¾¤
        function loadGlobalSettingsUI() {
            const container = document.getElementById('learningStepsContainer');
            container.innerHTML = '';
            
            globalStudySettings.learningSteps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.style.cssText = 'display: flex; align-items: center; gap: 5px;';
                stepDiv.innerHTML = `
                    <input type="number" value="${step}" min="1" 
                           onchange="updateLearningStep(${index}, this.value)"
                           style="width: 80px; padding: 8px;">
                    <span>åˆ†</span>
                    <button class="btn btn-danger" onclick="removeLearningStep(${index})" 
                            style="padding: 8px 12px; margin: 0;">å‰Šé™¤</button>
                `;
                container.appendChild(stepDiv);
            });
            
            document.getElementById('graduatingInterval').value = globalStudySettings.graduatingInterval;
            document.getElementById('easyInterval').value = globalStudySettings.easyInterval;
            document.getElementById('startingEase').value = globalStudySettings.startingEase;
            document.getElementById('easyBonus').value = globalStudySettings.easyBonus;
            document.getElementById('intervalModifier').value = globalStudySettings.intervalModifier;
            document.getElementById('maximumInterval').value = globalStudySettings.maximumInterval;
            
            // v14.02.5: ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
            updateDeletePreview();
        }
        
        function addLearningStep() {
            globalStudySettings.learningSteps.push(1);
            loadGlobalSettingsUI();
        }
        
        function updateLearningStep(index, value) {
            globalStudySettings.learningSteps[index] = parseInt(value);
        }
        
        function removeLearningStep(index) {
            if (globalStudySettings.learningSteps.length <= 1) {
                alert('å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—ã¯æœ€ä½1ã¤å¿…è¦ã§ã™');
                return;
            }
            globalStudySettings.learningSteps.splice(index, 1);
            loadGlobalSettingsUI();
        }
        
        function saveGlobalSettings() {
            globalStudySettings.graduatingInterval = parseInt(document.getElementById('graduatingInterval').value);
            globalStudySettings.easyInterval = parseInt(document.getElementById('easyInterval').value);
            globalStudySettings.startingEase = parseFloat(document.getElementById('startingEase').value);
            globalStudySettings.easyBonus = parseFloat(document.getElementById('easyBonus').value);
            globalStudySettings.intervalModifier = parseFloat(document.getElementById('intervalModifier').value);
            globalStudySettings.maximumInterval = parseInt(document.getElementById('maximumInterval').value);
            
            localStorage.setItem('globalStudySettings', JSON.stringify(globalStudySettings));
            alert('è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        function resetToDefaultSettings() {
            if (!confirm('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) return;
            globalStudySettings = {...defaultStudySettings};
            loadGlobalSettingsUI();
            alert('ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«æˆ»ã—ã¾ã—ãŸ');
        }
        
        // v14.02.5: ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
        async function updateDeletePreview() {
            const cardsCheck = document.getElementById('deleteCards');
            const decksCheck = document.getElementById('deleteDecks');
            const sessionsCheck = document.getElementById('deleteSessions');
            const markersCheck = document.getElementById('deleteMarkers');
            const settingsCheck = document.getElementById('deleteSettings');
            
            const cardsCountEl = document.getElementById('deleteCardsCount');
            const decksCountEl = document.getElementById('deleteDecksCount');
            const sessionsCountEl = document.getElementById('deleteSessionsCount');
            const markersCountEl = document.getElementById('deleteMarkersCount');
            const previewEl = document.getElementById('deletePreviewText');
            
            if (!cardsCountEl || !decksCountEl || !sessionsCountEl || !markersCountEl || !previewEl) return;
            
            try {
                // ã‚«ãƒ¼ãƒ‰æ•°
                cardsCountEl.textContent = `${cards.length}ä»¶`;
                
                // ãƒ‡ãƒƒã‚­æ•°
                decksCountEl.textContent = `${decks.length}ä»¶`;
                
                // å­¦ç¿’è¨˜éŒ²æ•°
                const sessionsSnapshot = await db.collection('studySessions').get();
                sessionsCountEl.textContent = `${sessionsSnapshot.size}ä»¶`;
                
                // PDFãƒãƒ¼ã‚«ãƒ¼æ•°
                const markersSnapshot = await db.collection('pdfMarkers').get();
                markersCountEl.textContent = `${markersSnapshot.size}ä»¶`;
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ
                const selected = [];
                if (cardsCheck && cardsCheck.checked) selected.push(`ã‚«ãƒ¼ãƒ‰ ${cards.length}ä»¶`);
                if (decksCheck && decksCheck.checked) selected.push(`ãƒ‡ãƒƒã‚­ ${decks.length}ä»¶`);
                if (sessionsCheck && sessionsCheck.checked) selected.push(`å­¦ç¿’è¨˜éŒ² ${sessionsSnapshot.size}ä»¶`);
                if (markersCheck && markersCheck.checked) selected.push(`PDFãƒãƒ¼ã‚«ãƒ¼ ${markersSnapshot.size}ä»¶`);
                if (settingsCheck && settingsCheck.checked) selected.push('è¨­å®šãƒ‡ãƒ¼ã‚¿');
                
                if (selected.length === 0) {
                    previewEl.textContent = 'é¸æŠã™ã‚‹ã¨å‰Šé™¤å¯¾è±¡ãŒè¡¨ç¤ºã•ã‚Œã¾ã™';
                    previewEl.style.color = '#666';
                } else {
                    previewEl.innerHTML = `<strong style="color: #c62828;">ä»¥ä¸‹ãŒå‰Šé™¤ã•ã‚Œã¾ã™ï¼š</strong><br>${selected.join('ã€')}`;
                }
                
            } catch (error) {
                console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // v14.02.5: ãƒ‡ãƒ¼ã‚¿å®Œå…¨å‰Šé™¤ã‚’å®Ÿè¡Œ
        async function executeCompleteDataDeletion() {
            const cardsCheck = document.getElementById('deleteCards');
            const decksCheck = document.getElementById('deleteDecks');
            const sessionsCheck = document.getElementById('deleteSessions');
            const markersCheck = document.getElementById('deleteMarkers');
            const settingsCheck = document.getElementById('deleteSettings');
            
            // é¸æŠãƒã‚§ãƒƒã‚¯
            if (!cardsCheck.checked && !decksCheck.checked && !sessionsCheck.checked && !markersCheck.checked && !settingsCheck.checked) {
                showToast('å‰Šé™¤å¯¾è±¡ã‚’é¸æŠã—ã¦ãã ã•ã„', 3000, 'warning');
                return;
            }
            
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°1
            const items = [];
            if (cardsCheck.checked) items.push(`ãƒ»ã‚«ãƒ¼ãƒ‰ ${cards.length}ä»¶`);
            if (decksCheck.checked) items.push(`ãƒ»ãƒ‡ãƒƒã‚­ ${decks.length}ä»¶`);
            if (sessionsCheck.checked) items.push('ãƒ»å­¦ç¿’è¨˜éŒ²ï¼ˆã™ã¹ã¦ï¼‰');
            if (markersCheck.checked) items.push('ãƒ»PDFãƒãƒ¼ã‚«ãƒ¼ï¼ˆã™ã¹ã¦ï¼‰');
            if (settingsCheck.checked) items.push('ãƒ»è¨­å®šãƒ‡ãƒ¼ã‚¿');
            
            if (!confirm(`âš ï¸ è­¦å‘Šï¼šä»¥ä¸‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨å‰Šé™¤ã—ã¾ã™\n\n${items.join('\n')}\n\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚\næœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
                return;
            }
            
            // æœ€çµ‚ç¢ºèªï¼ˆDELETEå…¥åŠ›ï¼‰
            const confirmText = prompt('æœ€çµ‚ç¢ºèªï¼šå‰Šé™¤ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€ŒDELETEã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„');
            if (confirmText !== 'DELETE') {
                showToast('å‰Šé™¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 3000, 'info');
                return;
            }
            
            try {
                let deletedCount = 0;
                
                // ã‚«ãƒ¼ãƒ‰å‰Šé™¤
                if (cardsCheck.checked) {
                    showToast('ã‚«ãƒ¼ãƒ‰ã‚’å‰Šé™¤ä¸­...', 1000, 'info');
                    const batch = db.batch();
                    const cardsSnapshot = await db.collection('flashcards').get();
                    cardsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    cards.length = 0;
                    deletedCount++;
                }
                
                // ãƒ‡ãƒƒã‚­å‰Šé™¤
                if (decksCheck.checked) {
                    showToast('ãƒ‡ãƒƒã‚­ã‚’å‰Šé™¤ä¸­...', 1000, 'info');
                    const batch = db.batch();
                    const decksSnapshot = await db.collection('decks').get();
                    decksSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    decks.length = 0;
                    deletedCount++;
                }
                
                // å­¦ç¿’è¨˜éŒ²å‰Šé™¤
                if (sessionsCheck.checked) {
                    showToast('å­¦ç¿’è¨˜éŒ²ã‚’å‰Šé™¤ä¸­...', 1000, 'info');
                    const sessionsSnapshot = await db.collection('studySessions').get();
                    const batches = [];
                    let batch = db.batch();
                    let count = 0;
                    
                    sessionsSnapshot.docs.forEach(doc => {
                        batch.delete(doc.ref);
                        count++;
                        if (count === 500) {
                            batches.push(batch);
                            batch = db.batch();
                            count = 0;
                        }
                    });
                    
                    if (count > 0) batches.push(batch);
                    
                    for (const b of batches) {
                        await b.commit();
                    }
                    deletedCount++;
                }
                
                // PDFãƒãƒ¼ã‚«ãƒ¼å‰Šé™¤
                if (markersCheck.checked) {
                    showToast('PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å‰Šé™¤ä¸­...', 1000, 'info');
                    const batch = db.batch();
                    const markersSnapshot = await db.collection('pdfMarkers').get();
                    markersSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    deletedCount++;
                }
                
                // è¨­å®šãƒ‡ãƒ¼ã‚¿å‰Šé™¤
                if (settingsCheck.checked) {
                    showToast('è¨­å®šãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ä¸­...', 1000, 'info');
                    localStorage.removeItem('theme');
                    localStorage.removeItem('fontSize');
                    localStorage.removeItem('customColors');
                    localStorage.removeItem('globalStudySettings');
                    localStorage.removeItem('deckStudySettings');
                    localStorage.removeItem('collapsedDecks');
                    localStorage.removeItem('cardsPerPage');
                    localStorage.removeItem('lastSelectedDeckId');
                    localStorage.removeItem('instantDeleteMode');
                    deletedCount++;
                }
                
                showToast(`âœ… ${deletedCount}ç¨®é¡ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`, 10000, 'success');
                
                // UIæ›´æ–°
                if (cardsCheck.checked || decksCheck.checked) {
                    loadDecks();
                    displayCardListWithPagination();
                }
                
                // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
                cardsCheck.checked = false;
                decksCheck.checked = false;
                sessionsCheck.checked = false;
                markersCheck.checked = false;
                settingsCheck.checked = false;
                
                updateDeletePreview();
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                showToast('âŒ å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 10000, 'error');
            }
        }
        
        // v8.02.4: ãƒ‡ãƒƒã‚­ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchDeckModalTab(tab) {
            const tabs = document.querySelectorAll('#deckModal .card-type-tab');
            tabs.forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('deckModalBasic').style.display = tab === 'basic' ? 'block' : 'none';
            document.getElementById('deckModalSettings').style.display = tab === 'settings' ? 'block' : 'none';
        }
        
        function toggleDeckCustomSettings() {
            const checked = document.getElementById('deckUseCustomSettings').checked;
            document.getElementById('deckCustomSettingsPanel').style.display = checked ? 'block' : 'none';
        }
        
        function loadDeckSettingsUI() {
            const container = document.getElementById('deckLearningStepsContainer');
            container.innerHTML = '';
            
            const steps = document.getElementById('deckUseCustomSettings').checked && currentEditingDeckId ?
                          (decks.find(d => d.id === currentEditingDeckId)?.settings?.learningSteps || globalStudySettings.learningSteps) :
                          globalStudySettings.learningSteps;
            
            steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.style.cssText = 'display: flex; align-items: center; gap: 5px;';
                stepDiv.innerHTML = `
                    <input type="number" value="${step}" min="1" class="deck-learning-step"
                           style="width: 80px; padding: 8px;">
                    <span>åˆ†</span>
                    <button class="btn btn-danger" onclick="removeDeckLearningStep(${index})" 
                            style="padding: 8px 12px; margin: 0;">å‰Šé™¤</button>
                `;
                container.appendChild(stepDiv);
            });
        }
        
        function addDeckLearningStep() {
            const container = document.getElementById('deckLearningStepsContainer');
            const stepDiv = document.createElement('div');
            stepDiv.style.cssText = 'display: flex; align-items: center; gap: 5px;';
            const index = container.children.length;
            stepDiv.innerHTML = `
                <input type="number" value="1" min="1" class="deck-learning-step"
                       style="width: 80px; padding: 8px;">
                <span>åˆ†</span>
                <button class="btn btn-danger" onclick="removeDeckLearningStep(${index})" 
                        style="padding: 8px 12px; margin: 0;">å‰Šé™¤</button>
            `;
            container.appendChild(stepDiv);
        }
        
        function removeDeckLearningStep(index) {
            const container = document.getElementById('deckLearningStepsContainer');
            if (container.children.length <= 1) {
                alert('å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—ã¯æœ€ä½1ã¤å¿…è¦ã§ã™');
                return;
            }
            container.children[index].remove();
            loadDeckSettingsUI();
        }
        
        function resetDeckToDefaultSettings() {
            if (!confirm('ã“ã®ãƒ‡ãƒƒã‚­ã®è¨­å®šã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) return;
            
            document.getElementById('deckGraduatingInterval').value = globalStudySettings.graduatingInterval;
            document.getElementById('deckEasyInterval').value = globalStudySettings.easyInterval;
            document.getElementById('deckStartingEase').value = globalStudySettings.startingEase;
            document.getElementById('deckEasyBonus').value = globalStudySettings.easyBonus;
            document.getElementById('deckIntervalModifier').value = globalStudySettings.intervalModifier;
            document.getElementById('deckMaximumInterval').value = globalStudySettings.maximumInterval;
            
            loadDeckSettingsUI();
        }
        
        window.addEventListener('load', () => {
            loadDecks();
        });
        
        // ============================================
        // v14.00.2: ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢æ©Ÿèƒ½
        // ============================================
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼šæ¤œç´¢çµæœã‚’ä¿æŒ
        let searchedMarkerData = [];
        let selectedMarkerData = null;
        
        // v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ç”¨ã®å¤‰æ•°
        let previewMode = false;
        let previewMarkerData = null;
        
        // ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openMarkerSearch() {
            if (!pdfHash) {
                alert('PDFãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            // ç¾åœ¨ã®PDFæƒ…å ±ã‚’è¡¨ç¤º
            const currentInfo = `${currentPdfMetadata.fileName} (${currentPdfMetadata.totalPages}ãƒšãƒ¼ã‚¸ã€${(currentPdfMetadata.fileSize / 1024 / 1024).toFixed(2)}MB)`;
            document.getElementById('currentPdfInfo').textContent = currentInfo;
            
            // æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢
            document.getElementById('searchResultsContainer').style.display = 'none';
            document.getElementById('noResultsMessage').style.display = 'none';
            
            document.getElementById('markerSearchModal').style.display = 'block';
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeMarkerSearchModal() {
            document.getElementById('markerSearchModal').style.display = 'none';
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«åã®é¡ä¼¼åº¦ã‚’è¨ˆç®—ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªéƒ¨åˆ†ä¸€è‡´ç‡ï¼‰
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            
            const longer = str1.length > str2.length ? str1.toLowerCase() : str2.toLowerCase();
            const shorter = str1.length > str2.length ? str2.toLowerCase() : str1.toLowerCase();
            
            if (longer.length === 0) return 1.0;
            
            // éƒ¨åˆ†ä¸€è‡´ã®ã‚«ã‚¦ãƒ³ãƒˆ
            let matches = 0;
            for (let i = 0; i < shorter.length; i++) {
                if (longer.includes(shorter[i])) {
                    matches++;
                }
            }
            
            return matches / longer.length;
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’æ¤œç´¢
        async function searchPdfMarkers() {
            if (!pdfHash) {
                alert('PDFãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const searchByFileName = document.getElementById('searchByFileName').checked;
            const searchByPageCount = document.getElementById('searchByPageCount').checked;
            const searchByFileSize = document.getElementById('searchByFileSize').checked;
            
            try {
                // ã™ã¹ã¦ã®pdfMarkersãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
                const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                
                searchedMarkerData = [];
                
                pdfMarkersSnapshot.forEach(doc => {
                    const data = doc.data();
                    const docPdfHash = doc.id;
                    
                    // ç¾åœ¨ã®PDFã¯é™¤å¤–
                    if (docPdfHash === pdfHash) return;
                    
                    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (!data.fileName || !data.totalPages || !data.fileSize) return;
                    
                    let score = 0;
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«åã®ä¸€è‡´åº¦
                    if (searchByFileName) {
                        const similarity = calculateSimilarity(currentPdfMetadata.fileName, data.fileName);
                        if (similarity >= 0.8) {
                            score += 10;
                        } else if (similarity >= 0.5) {
                            score += 7;
                        } else if (similarity >= 0.3) {
                            score += 3;
                        }
                    }
                    
                    // ç·ãƒšãƒ¼ã‚¸æ•°ã®ä¸€è‡´
                    if (searchByPageCount) {
                        const pageDiff = Math.abs(currentPdfMetadata.totalPages - data.totalPages);
                        if (pageDiff === 0) {
                            score += 5;
                        } else if (pageDiff === 1) {
                            score += 3;
                        } else if (pageDiff === 2) {
                            score += 1;
                        } else {
                            // ãƒšãƒ¼ã‚¸æ•°ãŒå¤§ããç•°ãªã‚‹å ´åˆã¯å€™è£œã‹ã‚‰é™¤å¤–
                            return;
                        }
                    }
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã®è¿‘ä¼¼
                    if (searchByFileSize) {
                        const sizeDiff = Math.abs(currentPdfMetadata.fileSize - data.fileSize) / currentPdfMetadata.fileSize;
                        if (sizeDiff <= 0.05) {
                            score += 3;
                        } else if (sizeDiff <= 0.10) {
                            score += 1;
                        }
                    }
                    
                    // ã‚¹ã‚³ã‚¢ãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆã®ã¿è¿½åŠ 
                    if (score > 0) {
                        // ãƒãƒ¼ã‚«ãƒ¼æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                        let markerCount = 0;
                        if (data.markers) {
                            Object.keys(data.markers).forEach(page => {
                                markerCount += data.markers[page].length;
                            });
                        }
                        
                        searchedMarkerData.push({
                            pdfHash: docPdfHash,
                            fileName: data.fileName,
                            totalPages: data.totalPages,
                            fileSize: data.fileSize,
                            lastUpdated: data.lastUpdated,
                            markerCount: markerCount,
                            markers: data.markers,
                            score: score
                        });
                    }
                });
                
                // ã‚¹ã‚³ã‚¢ã®é«˜ã„é †ã«ã‚½ãƒ¼ãƒˆ
                searchedMarkerData.sort((a, b) => b.score - a.score);
                
                // çµæœã‚’è¡¨ç¤º
                displaySearchResults();
                
            } catch (error) {
                console.error('æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
                alert('æ¤œç´¢ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }
        
        // æ¤œç´¢çµæœã‚’è¡¨ç¤º
        function displaySearchResults() {
            const resultsContainer = document.getElementById('searchResults');
            const resultsDiv = document.getElementById('searchResultsContainer');
            const noResultsDiv = document.getElementById('noResultsMessage');
            
            if (searchedMarkerData.length === 0) {
                resultsDiv.style.display = 'none';
                noResultsDiv.style.display = 'block';
                return;
            }
            
            resultsDiv.style.display = 'block';
            noResultsDiv.style.display = 'none';
            
            resultsContainer.innerHTML = '';
            
            searchedMarkerData.forEach(data => {
                const resultItem = document.createElement('div');
                resultItem.style.cssText = 'border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;';
                
                // æ˜Ÿã®è¡¨ç¤º
                const maxStars = 5;
                const stars = Math.min(Math.ceil(data.score / 3), maxStars);
                const starDisplay = 'â˜…'.repeat(stars) + 'â˜†'.repeat(maxStars - stars);
                
                // æœ€çµ‚æ›´æ–°æ—¥æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                const lastUpdatedDate = data.lastUpdated ? new Date(data.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜';
                
                resultItem.innerHTML = `
                    <div style="display: flex; align-items: start; gap: 10px; margin-bottom: 10px;">
                        <div style="font-size: 24px;">ğŸ“„</div>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 16px; margin-bottom: 8px;">${data.fileName}</div>
                            <div style="color: #667eea; margin-bottom: 8px;">ä¸€è‡´åº¦: ${starDisplay} (${data.score}ç‚¹)</div>
                            <div style="color: #666; font-size: 14px; line-height: 1.6;">
                                ãƒšãƒ¼ã‚¸æ•°: ${data.totalPages}ãƒšãƒ¼ã‚¸<br>
                                ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${(data.fileSize / 1024 / 1024).toFixed(2)}MB<br>
                                ãƒãƒ¼ã‚«ãƒ¼æ•°: ${data.markerCount}å€‹<br>
                                æœ€çµ‚æ›´æ–°: ${lastUpdatedDate}
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="btn" onclick="openMarkerPreview('${data.pdfHash}')" style="flex: 1; background: #3498db;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
                        <button class="btn btn-secondary" onclick="directApplyMarkerData('${data.pdfHash}')" style="flex: 1;">ã“ã®æƒ…å ±ã‚’é©ç”¨</button>
                    </div>
                `;
                
                resultsContainer.appendChild(resultItem);
            });
        }
        
        // ç›´æ¥é©ç”¨ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’çµŒç”±ã›ãšç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‹ã‚‰é©ç”¨ï¼‰
        function directApplyMarkerData(pdfHash) {
            const data = searchedMarkerData.find(d => d.pdfHash === pdfHash);
            if (!data) {
                alert('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            selectedMarkerData = data;
            confirmApplyMarkerData();
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’é–‹ã
        function openMarkerPreview(pdfHash) {
            const data = searchedMarkerData.find(d => d.pdfHash === pdfHash);
            if (!data) {
                alert('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            selectedMarkerData = data;
            
            // PDFæƒ…å ±ã‚’è¡¨ç¤º
            const lastUpdatedDate = data.lastUpdated ? new Date(data.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜';
            document.getElementById('previewPdfInfo').innerHTML = `
                <strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> ${data.fileName}<br>
                <strong>ãƒšãƒ¼ã‚¸æ•°:</strong> ${data.totalPages}ãƒšãƒ¼ã‚¸<br>
                <strong>ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:</strong> ${(data.fileSize / 1024 / 1024).toFixed(2)}MB<br>
                <strong>æœ€çµ‚æ›´æ–°:</strong> ${lastUpdatedDate}
            `;
            
            // ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆã‚’è¨ˆç®—
            const colorCounts = { yellow: 0, red: 0, green: 0, blue: 0 };
            const pageMarkerCounts = {};
            let totalMarkers = 0;
            
            if (data.markers) {
                Object.keys(data.markers).forEach(pageNum => {
                    const markers = data.markers[pageNum];
                    pageMarkerCounts[pageNum] = markers.length;
                    totalMarkers += markers.length;
                    
                    markers.forEach(marker => {
                        if (colorCounts[marker.color] !== undefined) {
                            colorCounts[marker.color]++;
                        }
                    });
                });
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆã‚’è¡¨ç¤º
            const yellowPercent = totalMarkers > 0 ? ((colorCounts.yellow / totalMarkers) * 100).toFixed(0) : 0;
            const redPercent = totalMarkers > 0 ? ((colorCounts.red / totalMarkers) * 100).toFixed(0) : 0;
            const greenPercent = totalMarkers > 0 ? ((colorCounts.green / totalMarkers) * 100).toFixed(0) : 0;
            const bluePercent = totalMarkers > 0 ? ((colorCounts.blue / totalMarkers) * 100).toFixed(0) : 0;
            
            document.getElementById('markerStats').innerHTML = `
                <div style="font-size: 16px; margin-bottom: 15px;"><strong>ç·ãƒãƒ¼ã‚«ãƒ¼æ•°:</strong> ${totalMarkers}å€‹</div>
                <div style="display: flex; flex-direction: column; gap: 8px; padding-left: 20px;">
                    <div>â”œ é»„è‰²: ${colorCounts.yellow}å€‹ (${yellowPercent}%)</div>
                    <div>â”œ èµ¤è‰²: ${colorCounts.red}å€‹ (${redPercent}%)</div>
                    <div>â”œ ç·‘è‰²: ${colorCounts.green}å€‹ (${greenPercent}%)</div>
                    <div>â”” é’è‰²: ${colorCounts.blue}å€‹ (${bluePercent}%)</div>
                </div>
            `;
            
            // ãƒšãƒ¼ã‚¸ã”ã¨ã®åˆ†å¸ƒã‚’è¡¨ç¤º
            const distributionHTML = [];
            const sortedPages = Object.keys(pageMarkerCounts).sort((a, b) => parseInt(a) - parseInt(b));
            
            if (sortedPages.length > 0) {
                sortedPages.forEach(pageNum => {
                    distributionHTML.push(`<div style="padding: 5px 0;">ãƒšãƒ¼ã‚¸ ${pageNum}: ${pageMarkerCounts[pageNum]}å€‹</div>`);
                });
            } else {
                distributionHTML.push('<div style="color: #999;">ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>');
            }
            
            document.getElementById('markerDistribution').innerHTML = distributionHTML.join('');
            
            // å­¦ç¿’çµ±è¨ˆï¼ˆå°†æ¥çš„ã«å®Ÿè£…ï¼‰
            document.getElementById('studyStatsSection').style.display = 'none';
            
            document.getElementById('markerPreviewModal').style.display = 'block';
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeMarkerPreviewModal() {
            document.getElementById('markerPreviewModal').style.display = 'none';
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±é©ç”¨ã®ç¢ºèª
        async function confirmApplyMarkerData() {
            if (!selectedMarkerData) {
                alert('é©ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            // ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼æ•°ã‚’ç¢ºèª
            let currentMarkerCount = 0;
            if (markers[pdfHash]) {
                Object.keys(markers[pdfHash]).forEach(pageNum => {
                    currentMarkerCount += markers[pdfHash][pageNum].length;
                });
            }
            
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
            const message = `ä»¥ä¸‹ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’ç¾åœ¨ã®PDFã«é©ç”¨ã—ã¾ã™:\n\n` +
                `ãƒ»å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«å: ${selectedMarkerData.fileName}\n` +
                `ãƒ»ãƒãƒ¼ã‚«ãƒ¼æ•°: ${selectedMarkerData.markerCount}å€‹\n` +
                `ãƒ»æœ€çµ‚æ›´æ–°: ${selectedMarkerData.lastUpdated ? new Date(selectedMarkerData.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜'}\n\n` +
                `æ³¨æ„:\n` +
                `ãƒ»ç¾åœ¨ã®PDFã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ï¼ˆ${currentMarkerCount}å€‹ï¼‰ã¯å¤±ã‚ã‚Œã¾ã™\n` +
                `ãƒ»é©ç”¨å¾Œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“\n` +
                `ãƒ»äº‹å‰ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™\n\n` +
                `é©ç”¨ã—ã¾ã™ã‹ï¼Ÿ`;
            
            if (!confirm(message)) {
                return;
            }
            
            // ãƒšãƒ¼ã‚¸æ•°ä¸ä¸€è‡´ã®å ´åˆã®å‡¦ç†
            if (selectedMarkerData.totalPages !== currentPdfMetadata.totalPages) {
                const pageDiffMessage = `ãƒšãƒ¼ã‚¸æ•°ãŒç•°ãªã‚Šã¾ã™:\n` +
                    `æ—§PDF: ${selectedMarkerData.totalPages}ãƒšãƒ¼ã‚¸\n` +
                    `ç¾åœ¨ã®PDF: ${currentPdfMetadata.totalPages}ãƒšãƒ¼ã‚¸\n\n` +
                    `ç¾åœ¨ã®PDFã«å­˜åœ¨ã™ã‚‹ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚«ãƒ¼ã®ã¿é©ç”¨ã—ã¾ã™ã€‚\n` +
                    `ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`;
                
                if (!confirm(pageDiffMessage)) {
                    return;
                }
            }
            
            // ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’é©ç”¨
            await applyMarkerData();
        }
        
        // ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’é©ç”¨
        async function applyMarkerData() {
            if (!selectedMarkerData || !pdfHash) {
                return;
            }
            
            try {
                // æ–°ã—ã„ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’ä½œæˆ
                const newMarkers = {};
                
                if (selectedMarkerData.markers) {
                    Object.keys(selectedMarkerData.markers).forEach(pageNum => {
                        const pageNumber = parseInt(pageNum);
                        
                        // ç¾åœ¨ã®PDFã®ãƒšãƒ¼ã‚¸ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
                        if (pageNumber >= 1 && pageNumber <= currentPdfMetadata.totalPages) {
                            newMarkers[pageNum] = selectedMarkerData.markers[pageNum];
                        }
                    });
                }
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’æ›´æ–°
                markers[pdfHash] = newMarkers;
                
                // Firestoreã«ä¿å­˜
                await saveMarkersToFirebase();
                
                // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æç”»
                drawMarkers();
                
                // é©ç”¨ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
                let appliedMarkerCount = 0;
                Object.keys(newMarkers).forEach(pageNum => {
                    appliedMarkerCount += newMarkers[pageNum].length;
                });
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
                closeMarkerPreviewModal();
                closeMarkerSearchModal();
                
                // v14.00.14: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†
                if (previewMode) {
                    exitPreviewMode();
                }
                
                // DOMã®æ›´æ–°ã‚’å¾…ã£ã¦ã‹ã‚‰é©ç”¨æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                setTimeout(() => {
                    alert(`âœ… ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’é©ç”¨ã—ã¾ã—ãŸã€‚\n\n` +
                        `é©ç”¨ã•ã‚ŒãŸãƒãƒ¼ã‚«ãƒ¼æ•°: ${appliedMarkerCount}å€‹\n\n` +
                        `âš ï¸ PDFã®å†…å®¹ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å ´åˆã€\n` +
                        `ãƒãƒ¼ã‚«ãƒ¼ä½ç½®ãŒãšã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚\n` +
                        `é©ç”¨å¾Œã€å„ãƒãƒ¼ã‚«ãƒ¼ã®ä½ç½®ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`);
                    
                    // å…ƒã®ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ç¢ºèª
                    confirmDeleteOldMarkerData(selectedMarkerData);
                }, 100);
                
            } catch (error) {
                console.error('é©ç”¨ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã®é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }
        
        // å…ƒã®ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ç¢ºèª
        function confirmDeleteOldMarkerData(oldMarkerData) {
            if (!oldMarkerData) return;
            
            const message = `å…ƒã®ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n\n` +
                `ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«å: ${oldMarkerData.fileName}\n` +
                `ãƒ»ãƒãƒ¼ã‚«ãƒ¼æ•°: ${oldMarkerData.markerCount}å€‹\n` +
                `ãƒ»æœ€çµ‚æ›´æ–°: ${oldMarkerData.lastUpdated ? new Date(oldMarkerData.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜'}\n\n` +
                `å‰Šé™¤ã—ãªã„å ´åˆã€ãã®ã¾ã¾ä¿æŒã•ã‚Œã¾ã™ã€‚`;
            
            if (confirm(message)) {
                deleteOldMarkerData(oldMarkerData.pdfHash);
            }
        }
        
        // å…ƒã®ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
        async function deleteOldMarkerData(oldPdfHash) {
            if (!oldPdfHash) return;
            
            try {
                // Firestoreã‹ã‚‰å‰Šé™¤
                await db.collection('pdfMarkers').doc(oldPdfHash).delete();
                
                // ãƒ­ãƒ¼ã‚«ãƒ«ã®markerså¤‰æ•°ã‹ã‚‰ã‚‚å‰Šé™¤
                if (markers[oldPdfHash]) {
                    delete markers[oldPdfHash];
                }
                
                alert('å…ƒã®ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
                
            } catch (error) {
                console.error('å‰Šé™¤ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }
        
        // ============================================
        // v14.00.14: Canvasä¸Šã§ãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
        // ============================================
        
        // Canvasä¸Šã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’é–‹å§‹
        function startCanvasPreview() {
            if (!selectedMarkerData) {
                alert('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’ON
            previewMode = true;
            previewMarkerData = selectedMarkerData;
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            closeMarkerPreviewModal();
            closeMarkerSearchModal();
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã¨è­¦å‘Šã‚’è¡¨ç¤º
            const previewCanvas = document.getElementById('previewCanvas');
            const warningDiv = document.getElementById('previewModeWarning');
            if (previewCanvas) previewCanvas.style.display = 'block';
            if (warningDiv) warningDiv.style.display = 'block';
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æç”»
            drawPreviewMarkers();
        }
        
        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚’çµ‚äº†
        function exitPreviewMode() {
            previewMode = false;
            previewMarkerData = null;
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼Canvasã¨è­¦å‘Šã‚’éè¡¨ç¤º
            const previewCanvas = document.getElementById('previewCanvas');
            const warningDiv = document.getElementById('previewModeWarning');
            if (previewCanvas) {
                previewCanvas.style.display = 'none';
                const ctx = previewCanvas.getContext('2d');
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            }
            if (warningDiv) warningDiv.style.display = 'none';
        }
        
        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»
        function drawPreviewMarkers() {
            const previewCanvas = document.getElementById('previewCanvas');
            if (!previewCanvas || !previewMode || !previewMarkerData) return;
            
            const pdfCanvas = document.getElementById('pdfCanvas');
            if (!pdfCanvas) return;
            
            // Canvasã‚µã‚¤ã‚ºã‚’åˆã‚ã›ã‚‹
            previewCanvas.width = pdfCanvas.width;
            previewCanvas.height = pdfCanvas.height;
            
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®æ—§ãƒãƒ¼ã‚«ãƒ¼ã‚’å–å¾—
            const oldMarkers = previewMarkerData.markers?.[currentPage];
            
            // ãƒšãƒ¼ã‚¸æƒ…å ±ã‚’æ›´æ–°
            const warningDiv = document.getElementById('previewModeWarning');
            if (warningDiv) {
                const markerCount = oldMarkers ? oldMarkers.length : 0;
                const pageText = markerCount > 0 ? 
                    `âš ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼šã“ã®ãƒšãƒ¼ã‚¸ã«æ—§ãƒãƒ¼ã‚«ãƒ¼ãŒ${markerCount}å€‹ã‚ã‚Šã¾ã™` :
                    `âš ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼šã“ã®ãƒšãƒ¼ã‚¸ã«ã¯æ—§ãƒãƒ¼ã‚«ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“`;
                
                // ãƒœã‚¿ãƒ³ã‚’ä¿æŒã—ãŸã¾ã¾ã€ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’æ›´æ–°
                const buttonHtml = '<button onclick="exitPreviewMode()" style="margin-left: 15px; background: white; color: #e74c3c; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-weight: bold;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼çµ‚äº†</button>';
                warningDiv.innerHTML = pageText + buttonHtml;
            }
            
            if (!oldMarkers || oldMarkers.length === 0) return;
            
            // å„ãƒãƒ¼ã‚«ãƒ¼ã‚’ç‚¹ç·šã§æç”»
            oldMarkers.forEach(marker => {
                const scaleRatio = scale / marker.scale;
                const x = marker.x * scaleRatio;
                const y = marker.y * scaleRatio;
                const width = marker.width * scaleRatio;
                const height = marker.height * scaleRatio;
                
                // è‰²ã«å¿œã˜ãŸç‚¹ç·šè‰²ã‚’è¨­å®š
                let strokeColor;
                switch (marker.color) {
                    case 'yellow': strokeColor = 'rgba(255, 235, 59, 0.9)'; break;
                    case 'red': strokeColor = 'rgba(244, 67, 54, 0.9)'; break;
                    case 'green': strokeColor = 'rgba(76, 175, 80, 0.9)'; break;
                    case 'blue': strokeColor = 'rgba(33, 150, 243, 0.9)'; break;
                    default: strokeColor = 'rgba(255, 0, 0, 0.9)';
                }
                
                // ç‚¹ç·šã§æ ã‚’æç”»
                ctx.setLineDash([8, 4]);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);
                
                // å®Ÿç·šã‚’æˆ»ã™
                ctx.setLineDash([]);
            });
        }
        
        // ============================================
        // v14.00.2: ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢æ©Ÿèƒ½ ã“ã“ã¾ã§
        // ============================================
        
        // ============================================
        // v16.03.00: é¸æŠçš„å¾©å…ƒæ©Ÿèƒ½
        // ============================================
        
        let selectiveRestoreData = null;
        let selectedPdfMarkersForRestore = [];
        
        // é¸æŠçš„å¾©å…ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        function loadSelectiveRestoreFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    selectiveRestoreData = JSON.parse(e.target.result);
                    
                    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±ã‚’è¡¨ç¤º
                    const info = [
                        `ãƒ•ã‚¡ã‚¤ãƒ«å: ${file.name}`,
                        `ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ—¥æ™‚: ${new Date(selectiveRestoreData.exportDate).toLocaleString('ja-JP')}`,
                        `ã‚¢ãƒ—ãƒªãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${selectiveRestoreData.appVersion || 'v14.00'}`,
                    ].join('<br>');
                    document.getElementById('backupInfo').innerHTML = info;
                    
                    // å„é …ç›®ã®ä»¶æ•°ã‚’è¡¨ç¤º
                    const data = selectiveRestoreData.data;
                    document.getElementById('deckCount').textContent = data.decks?.length || 0;
                    document.getElementById('cardCount').textContent = data.flashcards?.length || 0;
                    document.getElementById('sessionCount').textContent = (data.studySessionHistory?.length || data.studySessions?.length) || 0;
                    document.getElementById('pdfMarkerCount').textContent = data.pdfMarkers?.length || 0;
                    document.getElementById('pdfMetadataCount').textContent = data.pdfMetadata?.length || 0;
                    
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
                    document.getElementById('selectiveRestoreModal').style.display = 'block';
                    
                } catch (error) {
                    console.error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\næ­£ã—ã„JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                }
            };
            reader.readAsText(file);
            
            // inputè¦ç´ ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†é¸æŠå¯èƒ½ã«ã™ã‚‹ï¼‰
            event.target.value = '';
        }
        
        // é¸æŠçš„å¾©å…ƒãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeSelectiveRestoreModal() {
            document.getElementById('selectiveRestoreModal').style.display = 'none';
            selectiveRestoreData = null;
            selectedPdfMarkersForRestore = [];
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('#selectiveRestoreModal input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.getElementById('cardRestoreOptions').style.display = 'none';
            document.getElementById('pdfMarkerList').style.display = 'none';
        }
        
        // ã‚«ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ‡æ›¿
        function toggleCardOptions() {
            const checked = document.getElementById('restoreCards').checked;
            document.getElementById('cardRestoreOptions').style.display = checked ? 'block' : 'none';
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è¡¨ç¤ºåˆ‡æ›¿
        function togglePdfMarkerOptions() {
            const checked = document.getElementById('restorePdfMarkers').checked;
            const listDiv = document.getElementById('pdfMarkerList');
            
            if (checked) {
                // PDFãƒãƒ¼ã‚«ãƒ¼ä¸€è¦§ã‚’ç”Ÿæˆ
                const pdfMarkers = selectiveRestoreData.data.pdfMarkers || [];
                let html = '<div style="font-size: 14px; color: #667eea; margin-bottom: 10px; font-weight: bold;">ğŸ“Œ å¾©å…ƒã™ã‚‹PDFã‚’å€‹åˆ¥ã«é¸æŠã—ã¦ãã ã•ã„:</div>';
                
                pdfMarkers.forEach((pm, index) => {
                    const markerCount = pm.markers ? Object.keys(pm.markers).reduce((sum, pageNum) => {
                        return sum + (pm.markers[pageNum]?.length || 0);
                    }, 0) : 0;
                    
                    const lastUpdated = pm.lastUpdated ? new Date(pm.lastUpdated).toLocaleDateString('ja-JP') : 'ä¸æ˜';
                    
                    html += `
                        <label style="display: flex; align-items: center; gap: 12px; cursor: pointer; margin-bottom: 8px; padding: 12px; background: white; border-radius: 5px; border: 1px solid #e0e0e0; transition: all 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='white'">
                            <input type="checkbox" class="pdf-marker-checkbox" data-index="${index}" onchange="updatePdfMarkerSelection()" style="width: 18px; height: 18px; cursor: pointer; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; margin-bottom: 4px; font-size: 15px; color: #333;">${pm.fileName || 'ãƒ•ã‚¡ã‚¤ãƒ«åä¸æ˜'}</div>
                                <div style="font-size: 13px; color: #666;">
                                    ãƒãƒ¼ã‚«ãƒ¼: ${markerCount}å€‹ | æœ€çµ‚æ›´æ–°: ${lastUpdated}
                                </div>
                            </div>
                        </label>
                    `;
                });
                
                if (pdfMarkers.length === 0) {
                    html += '<div style="color: #999; text-align: center; padding: 20px;">PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                }
                
                listDiv.innerHTML = html;
                listDiv.style.display = 'block';
            } else {
                listDiv.style.display = 'none';
                selectedPdfMarkersForRestore = [];
            }
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼é¸æŠã‚’æ›´æ–°
        function updatePdfMarkerSelection() {
            selectedPdfMarkersForRestore = [];
            document.querySelectorAll('.pdf-marker-checkbox:checked').forEach(cb => {
                selectedPdfMarkersForRestore.push(parseInt(cb.dataset.index));
            });
        }
        
        // å¾©å…ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°ï¼ˆå°†æ¥çš„ã«æ‹¡å¼µå¯èƒ½ï¼‰
        function updateRestorePreview() {
            // ç¾åœ¨ã¯ç‰¹ã«ä½•ã‚‚ã—ãªã„ãŒã€å°†æ¥çš„ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã‚’è¿½åŠ å¯èƒ½
        }
        
        // é¸æŠçš„å¾©å…ƒã‚’å®Ÿè¡Œ
        async function executeSelectiveRestore() {
            if (!selectiveRestoreData) {
                alert('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            // é¸æŠã•ã‚ŒãŸé …ç›®ã‚’ç¢ºèª
            const restoreDecks = document.getElementById('restoreDecks').checked;
            const restoreCards = document.getElementById('restoreCards').checked;
            const restoreSessions = document.getElementById('restoreSessions').checked;
            const restorePdfMarkers = document.getElementById('restorePdfMarkers').checked;
            const restorePdfMetadata = document.getElementById('restorePdfMetadata').checked;
            const restoreTheme = document.getElementById('restoreTheme').checked;
            const restoreFontSize = document.getElementById('restoreFontSize').checked;
            const restoreGlobalSettings = document.getElementById('restoreGlobalSettings').checked;
            const restoreDeckSettings = document.getElementById('restoreDeckSettings').checked;
            const restoreUIState = document.getElementById('restoreUIState').checked;
            
            // ä½•ã‚‚é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆ
            if (!restoreDecks && !restoreCards && !restoreSessions && !restorePdfMarkers && !restorePdfMetadata &&
                !restoreTheme && !restoreFontSize && !restoreGlobalSettings && !restoreDeckSettings && !restoreUIState) {
                alert('å¾©å…ƒã™ã‚‹é …ç›®ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ã‚«ãƒ¼ãƒ‰å¾©å…ƒã§CSVå‡ºåŠ›ãŒé¸æŠã•ã‚ŒãŸå ´åˆ
            if (restoreCards) {
                const cardMethod = document.querySelector('input[name="cardRestoreMethod"]:checked').value;
                if (cardMethod === 'csv') {
                    exportCardsToCSV();
                    return;
                }
            }
            
            // PDFãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒã§PDFãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
            if (restorePdfMarkers && selectedPdfMarkersForRestore.length > 0) {
                await showPdfMarkerRestorePreview();
                return;
            }
            
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
            let confirmMsg = 'ä»¥ä¸‹ã®é …ç›®ã‚’å¾©å…ƒã—ã¾ã™:\n\n';
            if (restoreDecks) confirmMsg += '- ãƒ‡ãƒƒã‚­æ§‹é€ \n';
            if (restoreCards) confirmMsg += '- ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿\n';
            if (restoreSessions) confirmMsg += '- å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ²\n';
            if (restorePdfMarkers) confirmMsg += '- PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±\n';
            if (restorePdfMetadata) confirmMsg += '- PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿\n';
            if (restoreTheme || restoreFontSize || restoreGlobalSettings || restoreDeckSettings || restoreUIState) {
                confirmMsg += '- è¨­å®š\n';
            }
            confirmMsg += '\nç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ';
            
            if (!confirm(confirmMsg)) return;
            
            try {
                updateSyncStatus('syncing');
                
                // å¾©å…ƒå‰ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
                await createPreRestoreBackup();
                
                // å„é …ç›®ã‚’å¾©å…ƒ
                if (restoreDecks) await restoreDecksData();
                if (restoreCards) await restoreCardsData();
                if (restoreSessions) await restoreSessionsData();
                if (restorePdfMetadata) await restorePdfMetadataData();
                if (restoreTheme || restoreFontSize || restoreGlobalSettings || restoreDeckSettings || restoreUIState) {
                    await restoreSettingsData({restoreTheme, restoreFontSize, restoreGlobalSettings, restoreDeckSettings, restoreUIState});
                }
                
                updateSyncStatus('synced');
                showToast('âœ… é¸æŠã—ãŸé …ç›®ã®å¾©å…ƒãŒå®Œäº†ã—ã¾ã—ãŸ', 5000, 'success');
                closeSelectiveRestoreModal();
                
            } catch (error) {
                console.error('å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                alert('å¾©å…ƒä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n' + error.message);
                updateSyncStatus('error');
            }
        }
        
        // v16.03.03: å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã›ãšã«ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ï¼‰
        async function exportAllData() {
            try {
                // 1. Firestoreã‹ã‚‰ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const decksSnapshot = await db.collection('decks').orderBy('order').get();
                const flashcardsSnapshot = await db.collection('flashcards').get();
                const studySessionsSnapshot = await db.collection('studySessions').get();
                const pdfMarkersSnapshot = await db.collection('pdfMarkers').get();
                
                // ãƒ‡ãƒ¼ã‚¿ã‚’é…åˆ—ã«å¤‰æ›
                const decks = [];
                decksSnapshot.forEach(doc => {
                    decks.push({ id: doc.id, ...doc.data() });
                });
                
                const flashcards = [];
                flashcardsSnapshot.forEach(doc => {
                    flashcards.push({ id: doc.id, ...doc.data() });
                });
                
                const studySessions = [];
                studySessionsSnapshot.forEach(doc => {
                    studySessions.push({ id: doc.id, ...doc.data() });
                });
                
                const pdfMarkers = [];
                const pdfMetadata = [];
                pdfMarkersSnapshot.forEach(doc => {
                    const data = doc.data();
                    pdfMarkers.push({ 
                        pdfHash: doc.id, 
                        ...data 
                    });
                    // PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å¯¾å¿œè¡¨
                    if (data.fileName) {
                        pdfMetadata.push({
                            pdfHash: doc.id,
                            fileName: data.fileName,
                            totalPages: data.totalPages || 0,
                            fileSize: data.fileSize || 0
                        });
                    }
                });
                
                // 2. localStorageã‹ã‚‰è¨­å®šã‚’å–å¾—
                const settings = {
                    theme: localStorage.getItem('theme') || 'light',
                    fontSize: localStorage.getItem('fontSize') || 'medium',
                    customColors: localStorage.getItem('customColors') || null,
                    deckStudySettings: localStorage.getItem('deckStudySettings') || null,
                    globalStudySettings: localStorage.getItem('globalStudySettings') || null,
                    collapsedDecks: localStorage.getItem('collapsedDecks') || '{}',
                    cardsPerPage: localStorage.getItem('cardsPerPage') || '50',
                    lastSelectedDeckId: localStorage.getItem('lastSelectedDeckId') || null,
                    instantDeleteMode: localStorage.getItem('instantDeleteMode') || 'false'
                };
                
                // 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                const backup = {
                    version: '1.0',
                    userId: null,
                    exportDate: new Date().toISOString(),
                    appVersion: 'v16.03.03',
                    data: {
                        decks: decks,
                        flashcards: flashcards,
                        studySessions: studySessions,
                        pdfMarkers: pdfMarkers,
                        pdfMetadata: pdfMetadata
                    },
                    settings: settings,
                    stats: {
                        deckCount: decks.length,
                        cardCount: flashcards.length,
                        sessionCount: studySessions.length,
                        pdfCount: pdfMarkers.length
                    }
                };
                
                return backup;
                
            } catch (error) {
                console.error('ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                throw error;
            }
        }
        
        // å¾©å…ƒå‰ã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        async function createPreRestoreBackup() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `å¾©å…ƒå‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—_${timestamp}.json`;
            
            // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            const exportData = await exportAllData();
            
            // IndexedDBã«ä¿å­˜ï¼ˆå®¹é‡åˆ¶é™ã«æ³¨æ„ï¼‰
            try {
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                console.log('å¾©å…ƒå‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ:', filename);
                
                // é€šçŸ¥
                showToast(`ğŸ“¦ å¾©å…ƒå‰ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ`, 3000, 'info');
                
            } catch (error) {
                console.warn('å¾©å…ƒå‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆã«å¤±æ•—:', error);
            }
        }
        
        // ãƒ‡ãƒƒã‚­ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
        async function restoreDecksData() {
            const decks = selectiveRestoreData.data.decks || [];
            for (const deck of decks) {
                // IDã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
                const existingDeck = await db.collection('decks').doc(deck.id).get();
                if (!existingDeck.exists) {
                    await db.collection('decks').doc(deck.id).set(deck);
                }
            }
        }
        
        // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
        async function restoreCardsData() {
            const cards = selectiveRestoreData.data.flashcards || [];
            const method = document.querySelector('input[name="cardRestoreMethod"]:checked').value;
            
            if (method === 'replace') {
                // æ—¢å­˜ã‚«ãƒ¼ãƒ‰ã‚’å…¨å‰Šé™¤
                const snapshot = await db.collection('flashcards').get();
                const batch = db.batch();
                snapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
            }
            
            // ã‚«ãƒ¼ãƒ‰ã‚’å¾©å…ƒ
            for (const card of cards) {
                if (method === 'add') {
                    // æ–°è¦è¿½åŠ 
                    await db.collection('flashcards').add(card);
                } else {
                    // ä¸Šæ›¸ãã¾ãŸã¯ç½®ãæ›ãˆ
                    if (card.id) {
                        await db.collection('flashcards').doc(card.id).set(card);
                    } else {
                        await db.collection('flashcards').add(card);
                    }
                }
            }
        }
        
        // å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
        async function restoreSessionsData() {
            const sessions = selectiveRestoreData.data.studySessionHistory || selectiveRestoreData.data.studySessions || [];
            for (const session of sessions) {
                await db.collection('studySessionHistory').add(session);
            }
        }
        
        // PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
        async function restorePdfMetadataData() {
            const metadata = selectiveRestoreData.data.pdfMetadata || [];
            for (const meta of metadata) {
                if (meta.id) {
                    await db.collection('pdfMetadata').doc(meta.id).set(meta);
                } else {
                    await db.collection('pdfMetadata').add(meta);
                }
            }
        }
        
        // è¨­å®šã‚’å¾©å…ƒ
        async function restoreSettingsData(options) {
            const settings = selectiveRestoreData.settings || {};
            
            if (options.restoreTheme && settings.theme) {
                localStorage.setItem('theme', settings.theme);
            }
            if (options.restoreFontSize && settings.fontSize) {
                localStorage.setItem('fontSize', settings.fontSize);
            }
            if (options.restoreGlobalSettings && settings.globalStudySettings) {
                localStorage.setItem('globalStudySettings', settings.globalStudySettings);
            }
            if (options.restoreDeckSettings && settings.deckStudySettings) {
                localStorage.setItem('deckStudySettings', settings.deckStudySettings);
            }
            if (options.restoreUIState) {
                if (settings.collapsedDecks) localStorage.setItem('collapsedDecks', settings.collapsedDecks);
                if (settings.cardsPerPage) localStorage.setItem('cardsPerPage', settings.cardsPerPage);
                if (settings.lastSelectedDeckId) localStorage.setItem('lastSelectedDeckId', settings.lastSelectedDeckId);
            }
        }
        
        // ã‚«ãƒ¼ãƒ‰ã‚’CSVã¨ã—ã¦å‡ºåŠ›
        function exportCardsToCSV() {
            const cards = selectiveRestoreData.data.flashcards || [];
            
            if (cards.length === 0) {
                alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // CSVç”Ÿæˆ
            let csv = '\ufeff'; // BOM
            
            cards.forEach(card => {
                if (card.type === 'cloze') {
                    const clozeText = escapeCSVField(card.text);
                    const deckId = card.deckId || '';
                    const deckName = deckId ? getDeckNameById(deckId) : '';
                    const tags = (card.tags || []).join(' ');
                    csv += `${clozeText},${escapeCSVField(deckName)},${escapeCSVField(tags)}\n`;
                } else if (card.type === 'typing' || card.type === 'basic') {
                    const question = escapeCSVField(card.question);
                    const answer = escapeCSVField(card.answer);
                    const deckId = card.deckId || '';
                    const deckName = deckId ? getDeckNameById(deckId) : '';
                    const tags = (card.tags || []).join(' ');
                    csv += `${question},${answer},${escapeCSVField(deckName)},${escapeCSVField(tags)}\n`;
                }
            });
            
            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            const timestamp = new Date().toISOString().slice(0, 10);
            
            link.setAttribute('href', url);
            link.setAttribute('download', `cards_from_backup_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast(`âœ… ${cards.length}æšã®ã‚«ãƒ¼ãƒ‰ã‚’CSVã§å‡ºåŠ›ã—ã¾ã—ãŸ`, 5000, 'success');
            closeSelectiveRestoreModal();
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
        async function showPdfMarkerRestorePreview() {
            if (selectedPdfMarkersForRestore.length === 0) {
                alert('å¾©å…ƒã™ã‚‹PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚\n\nã€ŒPDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã€ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚ŒãŸå¾Œã€\nè¡¨ç¤ºã•ã‚Œã‚‹ä¸€è¦§ã‹ã‚‰å¾©å…ƒã—ãŸã„PDFã‚’å€‹åˆ¥ã«é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // æœ€åˆã®PDFã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
            const index = selectedPdfMarkersForRestore[0];
            const pdfMarker = selectiveRestoreData.data.pdfMarkers[index];
            
            document.getElementById('previewFileName').textContent = pdfMarker.fileName || 'ãƒ•ã‚¡ã‚¤ãƒ«åä¸æ˜';
            
            // v16.03.02: Firestoreã‹ã‚‰ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’å–å¾—
            let currentMarker = null;
            try {
                const snapshot = await db.collection('pdfMarkers')
                    .where('fileName', '==', pdfMarker.fileName)
                    .get();
                
                if (!snapshot.empty) {
                    currentMarker = snapshot.docs[0].data();
                }
            } catch (error) {
                console.error('ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
            }
            
            if (currentMarker && currentMarker.markers && Object.keys(currentMarker.markers).length > 0) {
                const currentMarkerCount = Object.keys(currentMarker.markers).reduce((sum, pageNum) => {
                    return sum + (currentMarker.markers[pageNum]?.length || 0);
                }, 0);
                
                document.getElementById('currentMarkerInfo').innerHTML = `
                    <div style="margin-bottom: 10px;">ãƒãƒ¼ã‚«ãƒ¼æ•°: <strong>${currentMarkerCount}å€‹</strong></div>
                    <div style="font-size: 12px; color: #666;">
                        æœ€çµ‚æ›´æ–°: ${currentMarker.lastUpdated ? new Date(currentMarker.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜'}
                    </div>
                `;
            } else {
                document.getElementById('currentMarkerInfo').innerHTML = `
                    <div style="color: #999;">ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãªã—</div>
                `;
            }
            
            // å¾©å…ƒå¾Œã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±
            const restoreMarkerCount = pdfMarker.markers ? Object.keys(pdfMarker.markers).reduce((sum, pageNum) => {
                return sum + (pdfMarker.markers[pageNum]?.length || 0);
            }, 0) : 0;
            
            let pageInfo = '';
            if (pdfMarker.markers) {
                const pages = Object.keys(pdfMarker.markers).sort((a, b) => parseInt(a) - parseInt(b));
                pageInfo = pages.map(pageNum => {
                    const count = pdfMarker.markers[pageNum]?.length || 0;
                    return `ãƒšãƒ¼ã‚¸${pageNum}: ${count}å€‹`;
                }).join('<br>');
            }
            
            document.getElementById('restoreMarkerInfo').innerHTML = `
                <div style="margin-bottom: 10px;">ãƒãƒ¼ã‚«ãƒ¼æ•°: <strong>${restoreMarkerCount}å€‹</strong></div>
                <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                    æœ€çµ‚æ›´æ–°: ${pdfMarker.lastUpdated ? new Date(pdfMarker.lastUpdated).toLocaleString('ja-JP') : 'ä¸æ˜'}
                </div>
                ${pageInfo ? `<div style="font-size: 12px; color: #666; border-top: 1px solid #ddd; padding-top: 10px;">${pageInfo}</div>` : ''}
            `;
            
            document.getElementById('pdfMarkerRestorePreviewModal').style.display = 'block';
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
        function closePdfMarkerRestorePreview() {
            document.getElementById('pdfMarkerRestorePreviewModal').style.display = 'none';
        }
        
        // PDFãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒã‚’ç¢ºå®š
        async function confirmPdfMarkerRestore() {
            if (!confirm('é¸æŠã—ãŸPDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ\nç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚')) {
                return;
            }
            
            try {
                updateSyncStatus('syncing');
                
                // å¾©å…ƒå‰ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
                await createPreRestoreBackup();
                
                // é¸æŠã•ã‚ŒãŸPDFãƒãƒ¼ã‚«ãƒ¼ã‚’å¾©å…ƒ
                for (const index of selectedPdfMarkersForRestore) {
                    const pdfMarker = selectiveRestoreData.data.pdfMarkers[index];
                    
                    // æ—¢å­˜ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã‚’æ¤œç´¢
                    const snapshot = await db.collection('pdfMarkers')
                        .where('fileName', '==', pdfMarker.fileName)
                        .get();
                    
                    if (!snapshot.empty) {
                        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                        const docId = snapshot.docs[0].id;
                        await db.collection('pdfMarkers').doc(docId).update({
                            markers: pdfMarker.markers || {},
                            lastUpdated: Date.now(),
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } else {
                        // æ–°è¦ä½œæˆ
                        await db.collection('pdfMarkers').add({
                            userId: currentUser.uid,
                            fileName: pdfMarker.fileName,
                            fileSize: pdfMarker.fileSize,
                            totalPages: pdfMarker.totalPages,
                            pdfHash: pdfMarker.pdfHash,
                            markers: pdfMarker.markers || {},
                            lastUpdated: Date.now(),
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }
                }
                
                updateSyncStatus('synced');
                showToast(`âœ… ${selectedPdfMarkersForRestore.length}å€‹ã®PDFãƒãƒ¼ã‚«ãƒ¼ã‚’å¾©å…ƒã—ã¾ã—ãŸ`, 5000, 'success');
                
                closePdfMarkerRestorePreview();
                closeSelectiveRestoreModal();
                
            } catch (error) {
                console.error('PDFãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFãƒãƒ¼ã‚«ãƒ¼ã®å¾©å…ƒä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n' + error.message);
                updateSyncStatus('error');
            }
        }
        
        // ============================================
        // v16.03.00: é¸æŠçš„å¾©å…ƒæ©Ÿèƒ½ ã“ã“ã¾ã§
        // ============================================
    </script>
    
    <div id="deckModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeModal()">&times;</span>
                <h2 id="deckModalTitle">ãƒ‡ãƒƒã‚­ç·¨é›†</h2>
            </div>
            
            <!-- v8.02.4: ãƒ‡ãƒƒã‚­ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¿ãƒ– -->
            <div class="card-type-tabs">
                <button class="card-type-tab active" onclick="switchDeckModalTab('basic')">åŸºæœ¬æƒ…å ±</button>
                <button class="card-type-tab" onclick="switchDeckModalTab('settings')">å­¦ç¿’è¨­å®š</button>
            </div>
            
            <!-- åŸºæœ¬æƒ…å ±ã‚¿ãƒ– -->
            <div id="deckModalBasic">
                <div class="input-group">
                    <label for="deckName">ãƒ‡ãƒƒã‚­å</label>
                    <input type="text" id="deckName" placeholder="ä¾‹ï¼šè‹±èª">
                </div>
                <div class="input-group">
                    <label for="parentDeckId">è¦ªãƒ‡ãƒƒã‚­</label>
                    <select id="parentDeckId">
                        <option value="">ãªã—ï¼ˆãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ï¼‰</option>
                    </select>
                </div>
                
                <!-- v12.00: ã‚¢ã‚¤ã‚³ãƒ³é¸æŠ -->
                <div class="input-group">
                    <label>ã‚¢ã‚¤ã‚³ãƒ³</label>
                    <div id="deckIconSelector" style="display: flex; flex-wrap: wrap; gap: 8px; max-height: 200px; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                        <button type="button" class="icon-btn" onclick="selectDeckIcon(null)" id="icon-none" style="font-size: 18px; padding: 8px 12px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ãªã—</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“š')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“š</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“–')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“–</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('âœï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">âœï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ““')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ““</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“•')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“•</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“—')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“—</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“™')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“™</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ«')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ«</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ’')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ’</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ”¬')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ”¬</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ§ª')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ§ª</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ§¬')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ§¬</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ”­')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ”­</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ§®')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ§®</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸŒ')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸŒ</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ—ºï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ—ºï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ›ï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ›ï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ¨')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ¨</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ–¼ï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ–¼ï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ­')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ­</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ’»')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ’»</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('âš™ï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">âš™ï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ”§')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ”§</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡¯ğŸ‡µ')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡¯ğŸ‡µ</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡ºğŸ‡¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡ºğŸ‡¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡¬ğŸ‡§')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡¬ğŸ‡§</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡«ğŸ‡·')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡«ğŸ‡·</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡©ğŸ‡ª')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡©ğŸ‡ª</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡ªğŸ‡¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡ªğŸ‡¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡¨ğŸ‡³')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡¨ğŸ‡³</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ‡°ğŸ‡·')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ‡°ğŸ‡·</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ—£ï¸')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ—£ï¸</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ’¬')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ’¬</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“Š')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“Š</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“ˆ')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“ˆ</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('â­')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">â­</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('âœ¨')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">âœ¨</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ’¡')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ’¡</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ“‚')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ“‚</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ¯')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ¯</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ†')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ†</button>
                        <button type="button" class="icon-btn" onclick="selectDeckIcon('ğŸ¥‡')" style="font-size: 24px; padding: 8px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ğŸ¥‡</button>
                    </div>
                    <input type="hidden" id="selectedDeckIcon" value="">
                </div>
                
                <!-- v12.00: è‰²é¸æŠ -->
                <div class="input-group">
                    <label>ãƒ‡ãƒƒã‚­è‰²</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor(null)" style="padding: 10px 16px; border: 2px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">ãªã—</button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#e74c3c')" style="padding: 10px 20px; border: 2px solid #ddd; background: #e74c3c; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#e67e22')" style="padding: 10px 20px; border: 2px solid #ddd; background: #e67e22; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#f39c12')" style="padding: 10px 20px; border: 2px solid #ddd; background: #f39c12; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#f1c40f')" style="padding: 10px 20px; border: 2px solid #ddd; background: #f1c40f; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#2ecc71')" style="padding: 10px 20px; border: 2px solid #ddd; background: #2ecc71; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#1abc9c')" style="padding: 10px 20px; border: 2px solid #ddd; background: #1abc9c; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#3498db')" style="padding: 10px 20px; border: 2px solid #ddd; background: #3498db; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#9b59b6')" style="padding: 10px 20px; border: 2px solid #ddd; background: #9b59b6; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#34495e')" style="padding: 10px 20px; border: 2px solid #ddd; background: #34495e; border-radius: 6px; cursor: pointer;"></button>
                        <button type="button" class="color-picker-btn" onclick="selectDeckColor('#95a5a6')" style="padding: 10px 20px; border: 2px solid #ddd; background: #95a5a6; border-radius: 6px; cursor: pointer;"></button>
                    </div>
                    <input type="hidden" id="selectedDeckColor" value="">
                </div>
            </div>
            
            <!-- å­¦ç¿’è¨­å®šã‚¿ãƒ– -->
            <div id="deckModalSettings" style="display: none;">
                <div class="checkbox-group" style="margin-bottom: 20px;">
                    <input type="checkbox" id="deckUseCustomSettings" onchange="toggleDeckCustomSettings()">
                    <label for="deckUseCustomSettings">ã“ã®ãƒ‡ãƒƒã‚­å°‚ç”¨ã®è¨­å®šã‚’ä½¿ã†</label>
                </div>
                
                <div id="deckCustomSettingsPanel" style="display: none;">
                    <div class="input-group">
                        <label>å­¦ç¿’ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆåˆ†ï¼‰</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;" id="deckLearningStepsContainer"></div>
                        <button class="btn btn-secondary" onclick="addDeckLearningStep()">+ ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿½åŠ </button>
                    </div>
                    
                    <div class="input-group">
                        <label for="deckGraduatingInterval">å’æ¥­é–“éš”ï¼ˆæ—¥ï¼‰</label>
                        <input type="number" id="deckGraduatingInterval" min="1" value="1">
                    </div>
                    
                    <div class="input-group">
                        <label for="deckEasyInterval">ç°¡å˜é–“éš”ï¼ˆæ—¥ï¼‰</label>
                        <input type="number" id="deckEasyInterval" min="1" value="4">
                    </div>
                    
                    <div class="input-group">
                        <label for="deckStartingEase">åˆæœŸé›£æ˜“åº¦</label>
                        <input type="number" id="deckStartingEase" min="1.3" max="5.0" step="0.1" value="2.5">
                    </div>
                    
                    <div class="input-group">
                        <label for="deckEasyBonus">ç°¡å˜ãƒœãƒ¼ãƒŠã‚¹</label>
                        <input type="number" id="deckEasyBonus" min="1.0" max="3.0" step="0.1" value="1.3">
                    </div>
                    
                    <div class="input-group">
                        <label for="deckIntervalModifier">é–“éš”èª¿æ•´ä¿‚æ•°</label>
                        <input type="number" id="deckIntervalModifier" min="0.5" max="2.0" step="0.05" value="1.0">
                    </div>
                    
                    <div class="input-group">
                        <label for="deckMaximumInterval">æœ€å¤§é–“éš”ï¼ˆæ—¥ï¼‰</label>
                        <input type="number" id="deckMaximumInterval" min="1" max="36500" value="36500">
                    </div>
                    
                    <button class="btn btn-secondary" onclick="resetDeckToDefaultSettings()">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã«æˆ»ã™</button>
                </div>
            </div>
            
            <button class="btn" onclick="saveDeck()">ä¿å­˜</button>
            <button class="btn btn-secondary" onclick="closeModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>
    
    <!-- ã‚«ãƒ¼ãƒ‰ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="cardEditModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeCardEditModal()">&times;</span>
                <h2>ã‚«ãƒ¼ãƒ‰ã‚’ç·¨é›†</h2>
            </div>
            <!-- v6.00: ãƒ‡ãƒƒã‚­é¸æŠ -->
            <div class="input-group">
                <label for="editDeckId">ãƒ‡ãƒƒã‚­</label>
                <select id="editDeckId">
                    <option value="">ãƒ‡ãƒƒã‚­ã‚’é¸æŠã—ã¦ãã ã•ã„</option>
                </select>
            </div>
            <div class="input-group">
                <label for="editCardType">ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—</label>
                <select id="editCardType" onchange="switchEditCardType()">
                    <option value="basic">åŸºæœ¬ã‚«ãƒ¼ãƒ‰</option>
                    <option value="cloze">ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰</option>
                    <option value="typing">ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰</option>
                </select>
            </div>
            
            <!-- åŸºæœ¬ã‚«ãƒ¼ãƒ‰ç·¨é›† -->
            <div id="editBasicInputs">
                <div class="input-group">
                    <label for="editQuestion">å•é¡Œ</label>
                    <textarea id="editQuestion" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ãŒæ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸå¹´ã¯ï¼Ÿ"></textarea>
                </div>
                <div class="input-group">
                    <label for="editAnswer">ç­”ãˆ</label>
                    <textarea id="editAnswer" placeholder="ä¾‹ï¼š1603å¹´"></textarea>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="editEnableReverse">
                    <label for="editEnableReverse">é€†æ–¹å‘ã‚‚å­¦ç¿’ï¼ˆç­”ãˆâ†’å•é¡Œï¼‰</label>
                </div>
            </div>
            
            <!-- ç©´åŸ‹ã‚ã‚«ãƒ¼ãƒ‰ç·¨é›† -->
            <div id="editClozeInputs" style="display: none;">
                <div class="input-group">
                    <label for="editClozeText">ãƒ†ã‚­ã‚¹ãƒˆ</label>
                    <textarea id="editClozeText" oninput="updateEditClozePreview()" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ã¯1603å¹´ã«æ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸã€‚"></textarea>
                </div>
                <div class="cloze-controls">
                    <button class="btn btn-secondary" onclick="insertEditCloze()">é¸æŠç¯„å›²ã‚’ç©´åŸ‹ã‚ã«</button>
                    <button class="btn btn-secondary" onclick="removeEditCloze()">ç©´åŸ‹ã‚ã‚’å‰Šé™¤</button>
                </div>
                <div class="cloze-preview">
                    <div class="cloze-preview-label">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼:</div>
                    <div id="editClozePreview" class="cloze-text">ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</div>
                </div>
            </div>
            
            <!-- ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å¼ã‚«ãƒ¼ãƒ‰ç·¨é›† -->
            <div id="editTypingInputs" style="display: none;">
                <div class="input-group">
                    <label for="editTypingQuestion">å•é¡Œ</label>
                    <textarea id="editTypingQuestion" placeholder="ä¾‹ï¼šå¾³å·å®¶åº·ãŒæ±Ÿæˆ¸å¹•åºœã‚’é–‹ã„ãŸå¹´ã¯ï¼Ÿ"></textarea>
                </div>
                <div class="input-group">
                    <label for="editTypingAnswer">æ­£è§£</label>
                    <input type="text" id="editTypingAnswer" placeholder="ä¾‹ï¼š1603å¹´">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="editTypingCaseSensitive">
                    <label for="editTypingCaseSensitive">å¤§æ–‡å­—å°æ–‡å­—ãƒ»å…¨è§’åŠè§’ã‚’åŒºåˆ¥ã™ã‚‹</label>
                </div>
            </div>
            
            <!-- v10.01: ã‚¿ã‚°å…¥åŠ›æ¬„ï¼ˆç·¨é›†ç”¨ï¼‰ -->
            <div class="input-group">
                <label for="editCardTags">ã‚¿ã‚°ï¼ˆåŠè§’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šï¼‰</label>
                <input type="text" id="editCardTags" placeholder="ä¾‹ï¼šé‡è¦ è©¦é¨“ç¯„å›² ç¬¬3ç« ">
                <small style="color: #666;">éšå±¤ã‚¿ã‚°ã¯::ã§åŒºåˆ‡ã‚Šã¾ã™ï¼ˆä¾‹ï¼šæ•°å­¦::å¾®åˆ†::åŸºæœ¬ï¼‰</small>
            </div>
            
            <button class="btn" onclick="saveEditedCard()">å¤‰æ›´ã‚’ä¿å­˜</button>
            <button class="btn btn-secondary" onclick="closeCardEditModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
    </div>
    
    <!-- v10.00.1: ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="deckSelectorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeDeckSelectorModal()">&times;</span>
                <h2>ç§»å‹•å…ˆãƒ‡ãƒƒã‚­ã‚’é¸æŠ</h2>
            </div>
            <div style="margin-bottom: 20px; color: #666;">
                <strong id="moveCardCount">0</strong>æšã®ã‚«ãƒ¼ãƒ‰ã‚’ç§»å‹•ã—ã¾ã™
            </div>
            <div id="deckSelectorList" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
            </div>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="confirmDeckMove()" id="confirmMoveBtn" disabled>ç§»å‹•ã™ã‚‹</button>
                <button class="btn btn-secondary" onclick="closeDeckSelectorModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>
    
    <!-- v14.00.2: ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="markerSearchModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeMarkerSearchModal()">&times;</span>
                <h2>ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±æ¤œç´¢</h2>
            </div>
            
            <!-- ç¾åœ¨ã®PDFæƒ…å ± -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="font-weight: bold; margin-bottom: 10px; color: #667eea;">ç¾åœ¨ã®PDF:</div>
                <div id="currentPdfInfo" style="color: #666;"></div>
            </div>
            
            <!-- æ¤œç´¢ã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: bold; margin-bottom: 10px;">æ¤œç´¢æ¡ä»¶:</div>
                <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-start;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                        <input type="checkbox" id="searchByFileName" checked>
                        <span>ãƒ•ã‚¡ã‚¤ãƒ«åã§æ¤œç´¢</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                        <input type="checkbox" id="searchByPageCount" checked>
                        <span>ç·ãƒšãƒ¼ã‚¸æ•°ã§çµã‚Šè¾¼ã¿</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                        <input type="checkbox" id="searchByFileSize" checked>
                        <span>ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã§çµã‚Šè¾¼ã¿</span>
                    </label>
                </div>
            </div>
            
            <button class="btn" onclick="searchPdfMarkers()" style="width: 100%; margin-bottom: 20px;">æ¤œç´¢</button>
            
            <!-- æ¤œç´¢çµæœ -->
            <div id="searchResultsContainer" style="display: none;">
                <div style="font-weight: bold; margin-bottom: 15px; color: #667eea;">å€™è£œãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ˆä¸€è‡´åº¦ã®é«˜ã„é †ï¼‰</div>
                <div id="searchResults" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            
            <div id="noResultsMessage" style="display: none; text-align: center; padding: 40px; color: #999;">
                ä¸€è‡´ã™ã‚‹å€™è£œãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ
            </div>
            
            <button class="btn btn-secondary" onclick="closeMarkerSearchModal()" style="width: 100%; margin-top: 20px;">é–‰ã˜ã‚‹</button>
        </div>
    </div>
    
    <!-- v14.00.2: ãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="markerPreviewModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <span class="close" onclick="closeMarkerPreviewModal()">&times;</span>
                <h2>ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
            </div>
            
            <!-- PDFæƒ…å ± -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div id="previewPdfInfo" style="color: #666;"></div>
            </div>
            
            <!-- ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆ -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">ãƒãƒ¼ã‚«ãƒ¼çµ±è¨ˆ</h3>
                <div id="markerStats" style="background: white; padding: 15px; border: 1px solid #ddd; border-radius: 8px;"></div>
            </div>
            
            <!-- ãƒšãƒ¼ã‚¸ã”ã¨ã®åˆ†å¸ƒ -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">ãƒšãƒ¼ã‚¸ã”ã¨ã®ãƒãƒ¼ã‚«ãƒ¼åˆ†å¸ƒ</h3>
                <div id="markerDistribution" style="background: white; padding: 15px; border: 1px solid #ddd; border-radius: 8px; max-height: 200px; overflow-y: auto;"></div>
            </div>
            
            <!-- å­¦ç¿’çµ±è¨ˆ -->
            <div id="studyStatsSection" style="display: none; margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">å­¦ç¿’çµ±è¨ˆ</h3>
                <div id="studyStats" style="background: white; padding: 15px; border: 1px solid #ddd; border-radius: 8px;"></div>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="startCanvasPreview()" style="flex: 1; background: #f39c12; border-color: #f39c12;">ğŸ“ Canvasä¸Šã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
                <button class="btn" onclick="confirmApplyMarkerData()" style="flex: 1;">ã“ã®æƒ…å ±ã‚’é©ç”¨</button>
                <button class="btn btn-secondary" onclick="closeMarkerPreviewModal()" style="flex: 1;">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>
    
    <!-- v16.03.00: é¸æŠçš„å¾©å…ƒãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="selectiveRestoreModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <span class="close" onclick="closeSelectiveRestoreModal()">&times;</span>
                <h2>ğŸ” é¸æŠçš„å¾©å…ƒ</h2>
            </div>
            
            <!-- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ± -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="font-weight: bold; margin-bottom: 10px; color: #667eea;">ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±</div>
                <div id="backupInfo" style="color: #666; font-size: 14px;"></div>
            </div>
            
            <!-- å¾©å…ƒé …ç›®é¸æŠ -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">å¾©å…ƒã™ã‚‹é …ç›®ã‚’é¸æŠ</h3>
                
                <!-- ãƒ‡ãƒ¼ã‚¿é …ç›® -->
                <div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; text-align: left;">
                    <div style="font-weight: bold; margin-bottom: 10px;">ğŸ“¦ ãƒ‡ãƒ¼ã‚¿</div>
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-start;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreDecks" onchange="updateRestorePreview()">
                            <span>ãƒ‡ãƒƒã‚­æ§‹é€  (<span id="deckCount">0</span>å€‹)</span>
                        </label>
                        <div style="margin-left: 30px; font-size: 12px; color: #999; margin-top: -5px; margin-bottom: 5px;">
                            â€»é€šå¸¸ã¯ã‚«ãƒ¼ãƒ‰ã¨ä¸€ç·’ã«å¾©å…ƒã•ã‚Œã‚‹ãŸã‚ä¸è¦
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreCards" onchange="toggleCardOptions()">
                            <span>ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ (<span id="cardCount">0</span>æš)</span>
                        </label>
                        <div id="cardRestoreOptions" style="display: none; margin-left: 30px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                            <div style="margin-bottom: 10px; font-size: 13px; color: #666;">å¾©å…ƒæ–¹æ³•ã‚’é¸æŠ:</div>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 5px; white-space: nowrap;">
                                <input type="radio" name="cardRestoreMethod" value="add" checked>
                                <span style="font-size: 14px;">æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ </span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 5px; white-space: nowrap;">
                                <input type="radio" name="cardRestoreMethod" value="overwrite">
                                <span style="font-size: 14px;">æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ã</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 5px; white-space: nowrap;">
                                <input type="radio" name="cardRestoreMethod" value="replace">
                                <span style="font-size: 14px;">æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦å¾©å…ƒ</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                                <input type="radio" name="cardRestoreMethod" value="csv">
                                <span style="font-size: 14px;">CSVãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦å‡ºåŠ›</span>
                            </label>
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreSessions" onchange="updateRestorePreview()">
                            <span>å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³è¨˜éŒ² (<span id="sessionCount">0</span>ä»¶)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restorePdfMarkers" onchange="togglePdfMarkerOptions()">
                            <span>PDFãƒãƒ¼ã‚«ãƒ¼æƒ…å ± (<span id="pdfMarkerCount">0</span>å€‹)</span>
                        </label>
                        <div id="pdfMarkerList" style="display: none; margin-left: 30px; max-height: 200px; overflow-y: auto; background: #f8f9fa; border-radius: 5px; padding: 10px;">
                            <!-- PDFãƒãƒ¼ã‚«ãƒ¼ä¸€è¦§ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restorePdfMetadata" onchange="updateRestorePreview()">
                            <span>PDFãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å¯¾å¿œè¡¨ (<span id="pdfMetadataCount">0</span>ä»¶)</span>
                        </label>
                        <div style="margin-left: 30px; font-size: 12px; color: #999; margin-top: -5px;">
                            â€»PDFãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆé€šå¸¸ã¯ä¸è¦ï¼‰
                        </div>
                    </div>
                </div>
                
                <!-- è¨­å®šé …ç›® -->
                <div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; text-align: left;">
                    <div style="font-weight: bold; margin-bottom: 10px;">âš™ï¸ è¨­å®š</div>
                    <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-start;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreTheme" onchange="updateRestorePreview()">
                            <span>ãƒ†ãƒ¼ãƒè¨­å®š</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreFontSize" onchange="updateRestorePreview()">
                            <span>ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreGlobalSettings" onchange="updateRestorePreview()">
                            <span>ã‚°ãƒ­ãƒ¼ãƒãƒ«å­¦ç¿’è¨­å®š</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreDeckSettings" onchange="updateRestorePreview()">
                            <span>ãƒ‡ãƒƒã‚­åˆ¥å­¦ç¿’è¨­å®š</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; white-space: nowrap;">
                            <input type="checkbox" id="restoreUIState" onchange="updateRestorePreview()">
                            <span>UIçŠ¶æ…‹è¨­å®š</span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- å®Ÿè¡Œãƒœã‚¿ãƒ³ -->
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="executeSelectiveRestore()" id="executeRestoreBtn" style="flex: 1;">å¾©å…ƒå®Ÿè¡Œ</button>
                <button class="btn btn-secondary" onclick="closeSelectiveRestoreModal()" style="flex: 1;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>
    
    <!-- v16.03.00: PDFãƒãƒ¼ã‚«ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="pdfMarkerRestorePreviewModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <span class="close" onclick="closePdfMarkerRestorePreview()">&times;</span>
                <h2>ğŸ“„ ãƒãƒ¼ã‚«ãƒ¼å¾©å…ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="font-weight: bold; margin-bottom: 10px; color: #667eea;">ãƒ•ã‚¡ã‚¤ãƒ«å</div>
                <div id="previewFileName" style="color: #333; font-size: 16px; margin-bottom: 20px;"></div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼ -->
                    <div>
                        <div style="font-weight: bold; margin-bottom: 10px; color: #666;">ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼</div>
                        <div id="currentMarkerInfo" style="background: #f8f9fa; padding: 15px; border-radius: 8px; min-height: 150px;"></div>
                    </div>
                    
                    <!-- å¾©å…ƒå¾Œã®ãƒãƒ¼ã‚«ãƒ¼ -->
                    <div>
                        <div style="font-weight: bold; margin-bottom: 10px; color: #667eea;">å¾©å…ƒå¾Œã®ãƒãƒ¼ã‚«ãƒ¼</div>
                        <div id="restoreMarkerInfo" style="background: #e3f2fd; padding: 15px; border-radius: 8px; min-height: 150px;"></div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 4px solid #f39c12;">
                    <strong>âš ï¸ æ³¨æ„:</strong> å¾©å…ƒã™ã‚‹ã¨ç¾åœ¨ã®ãƒãƒ¼ã‚«ãƒ¼æƒ…å ±ã¯ä¸Šæ›¸ãã•ã‚Œã¾ã™
                </div>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="confirmPdfMarkerRestore()" style="flex: 1;">å¾©å…ƒå®Ÿè¡Œ</button>
                <button class="btn btn-secondary" onclick="closePdfMarkerRestorePreview()" style="flex: 1;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>
    
    <!-- v14.02.1.2: ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ -->
    <div id="toastContainer" style="position: fixed; bottom: 20px; right: 20px; z-index: 10000;"></div>
    
    <!-- v14.02.8.9: CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ãƒ‡ãƒƒã‚­é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="csvDeckSelectorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close" onclick="closeCsvDeckSelectorModal()">&times;</span>
                <h2>ã‚¤ãƒ³ãƒãƒ¼ãƒˆå…ˆãƒ‡ãƒƒã‚­ã‚’é¸æŠ</h2>
            </div>
            <div style="margin-bottom: 20px; color: #666;">
                CSVãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ãŸãƒ‡ãƒƒã‚­ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™
            </div>
            
            <!-- æ—¢å­˜ãƒ‡ãƒƒã‚­ã‹ã‚‰é¸æŠ -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">æ—¢å­˜ã®ãƒ‡ãƒƒã‚­ã‹ã‚‰é¸æŠ</h3>
                <div id="csvDeckSelectorList" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px;">
                </div>
            </div>
            
            <!-- ã¾ãŸã¯æ–°è¦ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ -->
            <div style="margin-bottom: 20px;">
                <h3 style="color: #667eea; margin-bottom: 15px;">ã¾ãŸã¯æ–°è¦ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ</h3>
                <input type="text" id="newDeckNameForImport" placeholder="æ–°ã—ã„ãƒ‡ãƒƒã‚­åã‚’å…¥åŠ›" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
            </div>
            
            <div style="margin-top: 20px;">
                <button class="btn" onclick="confirmCsvImport()" id="confirmCsvImportBtn" disabled>ã“ã®è¨­å®šã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                <button class="btn btn-secondary" onclick="closeCsvDeckSelectorModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>
</body>
</html>

